
Tetcraft: A Whitepaper for a Decentralized Physics Sandbox

Version: 1.0
Date: October 26, 2023

Abstract

Tetcraft is a multiplayer, physics-based sandbox game built on a novel tetrahedral construction system. It departs from traditional voxel-based games by introducing a system where every creation is a dynamic, physically simulated object with real-world engineering constraints. Players will explore procedurally generated worlds to gather resources, refine them through a generative alchemical system, and use them to engineer complex structures, vehicles, and automated systems. The game is architected on a decentralized, peer-to-peer mesh network where each player's client is also a server for their personal universe, or "Shard." High-level engineering challenges, such as the construction of stable portals, allow players to connect their Shards, enabling trade, collaboration, and conflict. A robust blueprint system underpins a player-driven economy where ingenuity and design are the most valuable commodities.

1.0 Core Philosophy

The design of Apeiron is guided by three core principles:

Meaningful Engineering: Creations are not merely cosmetic. They are subject to the laws of physics, material properties, and structural stress. Success requires thoughtful design, from the weight of a bridge to the aerodynamics of a ship.

True Player Ownership: Through a decentralized network architecture, players have ultimate control and ownership over their world. The game provides the tools; the universe is built, governed, and sustained by its players.

A Generative Universe: From materials to social structures, the game is designed to be generative. An alchemical crafting system encourages experimentation, while emergent social and economic systems are driven by player interaction, not developer mandate.

2.0 Foundational Mechanics: The Tetrahedral World

The fundamental building blocks of Apeiron are tetrahedrons, not cubes. This geometric choice provides inherent structural rigidity and more granular design possibilities.

Tetrahedron Blocks: The basic unit of construction. Each is defined by its material, which dictates its weight, hardness, conductivity, and other physical properties.

Nexus Attachments: Tetrahedrons are connected at their vertices by Nexuses. The type of Nexus used defines the relationship between the blocks:

Rigid Nexus: Fuses vertices, creating a single, solid object. The default for static structures.

Flexible Nexus: Connects vertices with a resilient joint, allowing for flex and impact absorption. Used for suspension and flexible armor.

Hinge Nexus: Creates a single-axis pivot point, enabling doors, wheels, and rotating turrets.

Slider Nexus: Creates a linear rail, enabling pistons, elevators, and extending parts.

3.0 Material Science: A Generative Universe

Apeiron features a procedural material science system based on a curated list of foundational elements, each with unique attributes. New materials are discovered in an Alchemical Forge through experimentation.

Rule of Dominance: When two elements are combined, the element with the higher atomic number becomes the Base (X) material.

Naming Convention: The resulting alloy is named "Y-ized X," where Y is the lighter, additive element.

Attribute Filtering: Players can use catalysts and forge settings to emphasize specific attributes from the additive element, allowing for the creation of highly specialized materials.

Example: Combining Iron (Fe, #26) and Carbon (C, #6) creates Carbon-ized Iron. By filtering for Carbon's [Hardness] attribute, the player creates strong, structural steel.

Material Rarity: Elements are distributed across four tiers of rarity, guiding player progression from common surface metals like Iron and Copper to rare, exotic materials like Beryllium, which are found only in the most dangerous environments.

4.0 Player Progression: The Schema Web

Player progression is managed through a 100-node technology web called the Schema Web. Players earn Schema Points through activities like engineering, combat, and exploration, which are then spent to unlock new nodes.

Structure: The web begins with a central hub for basic survival and radiates out into four primary "Constellations":

Constellation of Matter: Focuses on discovering, refining, and alloying new materials.

Constellation of Motion: Focuses on mechanical engineering, from basic wheels to complex AI-driven drones and blueprint technology.

Constellation of Energy: Focuses on power generation, storage, and specialized systems like fluid dynamics and energy shields.

Constellation of the Void: The endgame, focusing on the quantum engineering required to build and stabilize portals.

Flexibility: The interconnected nature of the web allows players to specialize in a specific field or generalize across many, promoting diverse playstyles and encouraging collaboration within communities.

5.0 The Gameplay Loop

The core gameplay is a self-reinforcing cycle of creation and discovery.

Explore: Players venture into the world to find resources, facing challenges from robotic enemies ("Constructs") and environmental hazards like "Miasma," a byproduct of industrial pollution.

Refine & Engineer: Resources are processed through the alchemical system. Using technologies unlocked in the Schema Web, players engineer everything from simple shelters to complex, automated factories and capital-class vehicles.

Manage: Players must manage their Shard's Complexity Budget, a soft cap on server performance that can be increased by crafting and installing powerful processing nodes.

Share & Collaborate: Player ingenuity is captured and traded via the Blueprint system, driving the economy and social structure.

6.0 Network Architecture: The Decentralized Shard Network

Apeiron operates on a peer-to-peer mesh network, designed for maximum player ownership and scalability.

Each Client is a Server: Each player's game client hosts their unique instance of the universe, called a "Shard." The player has absolute authority over the rules, physics, and access to their Shard.

The Apeiron Index: A single, lightweight central server acts only as a secure address book. Its sole function is to map a player's permanent Shard Address to their current IP address, enabling the initial P2P handshake.

Host Authority: Within a Shard, the host's client is the absolute source of truth. All guest actions (movement, combat, building) are sent as "intent" packets, which are then simulated by the host. This model prevents a wide range of cheats, including speed and teleportation hacks.

7.0 Inter-Shard Travel & Interaction: Portals

Portals are the endgame engineering challenge that enables players to connect their Shards.

Construction: Portals are complex structures requiring exotic materials, immense power, and components from the highest tiers of the Schema Web, making their construction a significant achievement.

Security: Portal owners have granular control over access via an Access Control List (ACL) featuring whitelists, blacklists, and password protection.

The Escrow Protocol: To ensure stability and prevent item loss from network disconnects, the game uses a zero-trust escrow system.

Departure Snapshot: When a player enters a portal, their own client saves a complete "snapshot" of all transiting entities.

Orderly Departure: Upon a safe return, the snapshot is deleted, and the player's updated state is saved.

Disorderly Departure (Crash): If the connection is lost, the host client simply purges all guest entities. The guest client, upon logging back in, reverts to the saved snapshot, restoring their assets exactly as they were before the visit began.

8.0 The Player Economy: Blueprints & Trade

The in-game economy is driven by intellectual property and tangible goods.

Blueprint System: Players can use a Schematic Scanner to create a blueprint of any of their creations. This blueprint can then be used in a Construction Projector to create a holographic guide for easy replication.

Schematics vs. Proprietary Blueprints: Blueprints can be saved in two forms:

Schematic (Unlocked): An open-source copy that can be used and duplicated freely. Ideal for collaboration within alliances.

Proprietary Blueprint (Locked): A single-use (per build) copy that cannot be duplicated. This allows skilled engineers to sell their designs without losing control of their intellectual property.

Trade: The secure, two-phase commit trade protocol allows for the safe exchange of resources, components, and blueprints, creating a vibrant, player-driven market for both goods and ideas.

9.0 Conclusion

Tetcraft is an ambitious synthesis of deep physics simulation, creative engineering, and a truly decentralized multiplayer framework. By providing players with a powerful and intuitive set of tools within a universe of meaningful rules, we aim to foster a world of limitless creativity, emergent social structures, and an enduring player-driven legacy.




Excellent. These clarifications are precisely what was needed. They address the hard problems with practical, gameplay-focused solutions that reinforce the core philosophy of the game.

This is no longer just a conceptual review; this is the refinement phase. Let's formalize these solutions as an addendum to the whitepaper, solidifying them as core design pillars.

Whitepaper Addendum 1.1: Design Clarifications & Solutions

This document addresses key areas identified in the initial review, providing concrete solutions and refining the game's design principles.

1. Gameplay and Player Experience Solutions

Onboarding & Tutorial (The Intuitive Interface Philosophy):
The tutorial will be integrated directly into the user interface, following a "show, don't tell" principle.

Contextual Building: Upon picking up a single tetrahedron, the UI will highlight its vertices ("Nexus Points"). When the player brings a Nexus from their inventory near a point, a holographic guide will show how it snaps into place. This teaches the fundamental building mechanic without text boxes.

Inspirational Starter Kit: The player will start with a basic inventory of Iron Tetrahedrons and Rigid Nexuses. Crucially, they will also start with two Hinge and two Slider Nexuses. These cannot be crafted early on. This serves as a "mechanical teaser," encouraging players to experiment with advanced movement and motivating them to find the path to crafting more in the Schema Web.

Enemy AI Scaling (The Threat Resonance System):
The difficulty of the enemy "Constructs" will not be static. It will be tied directly to the technological advancement of the host player's Shard.

Mechanism: The game will track the number of nodes the host has unlocked in the Schema Web. As key technological thresholds are passed, the robotic enemies on that Shard will dynamically upgrade—gaining increased range, longer memory, more complex attack patterns, and higher durability.

Gameplay Dynamic: This ensures that players are always faced with a relevant level of challenge. It also means that visiting a technologically advanced friend's Shard will be a more dangerous—and potentially more rewarding—experience.

Progression Pacing & The "10-Year Web":
The Schema Web is designed for long-term play, with an estimated 10-year timeline for a solo player to unlock 100% of the nodes. This is a core feature, not a bug.

Endgame Accessibility: The first "ring" of nodes radiating from the Central Hub will provide access to primitive, less efficient versions of every core mechanic needed to reach the endgame. A player can technically build a portal using only early-game materials and technology, but it will be incredibly fragile, inefficient, and small.

Optimization as Progression: The long-term goal is not just to unlock, but to optimize. Later nodes provide massive boosts in efficiency, durability, and scale, encouraging players to specialize and trade for what they lack.

2. Technical and Architectural Solutions

Latency in Combat (The Cooperative Combat Calibrator):
To address the inherent host advantage in a P2P system, and to promote a fun, cooperative environment, a calibration system will be implemented.

Mechanism: Shard owners can set their PvP rules. In the "Cooperative" mode:

The Host Player receives a slight, algorithmically applied accuracy penalty to their projectiles.

Visiting Players receive a gracious, optional auto-aim field of view that gently guides projectiles toward targets.

Intended Outcome: This system intentionally moves the game away from competitive, esports-style PvP and reinforces its identity as a cooperative building and exploration sandbox. It creates a clear incentive to invite friends to help with difficult enemies.

Blueprint IP Security (The Schematic Registry):
To close the intellectual property loophole, the Apeiron Index (the central server) will take on a secondary role as a blueprint registry.

Registration: To create a "Proprietary Blueprint," the creator must register the design's unique hash with the Index. This action is permanent and may require a small fee of a rare resource.

Enforcement: The Index will reject any attempt to register a blueprint with a duplicate hash. This prevents a copied design from being sold on the open market as an original.

Emergent Gameplay ("The Artisan Thief"): This system creates a fascinating dynamic. A player can still copy a design they see, but they can never sell the blueprint. They can, however, act as an artisan, traveling to other Shards and using their stolen knowledge and unlocked tech to build the object for other players in exchange for resources. This creates two distinct economic roles: the Designer who sells IP, and the Fabricator who sells labor.

P2P Connectivity:
As confirmed, hosting a Shard will require the player to manually configure port forwarding on their router. The game will provide clear instructions and tools to assist with this process.

3. Conceptual and World-Building Definitions

The "Why" (The Emergent Universe Mandate):
The game's purpose is to serve as a platform for creative expression and community building. There is no overarching developer-driven narrative. The "story" is the history of the players and the unique cultures that develop on different Shards. The game provides the tools for players to create their own content, from rentable multiplayer adventures and elaborate art galleries to functioning trade hubs and fortified alliance capitals.

Aesthetics & World Management (The Shard Genesis System):
The aesthetic will be driven by procedural generation, ensuring every Shard is unique. To maximize player freedom and eliminate the fear of making irreversible mistakes, Shard owners will have access to two powerful world reset options:

The "Remix": This option keeps all of the player's existing blocks and materials but completely regenerates the planet's terrain, redistributing all blocks into new geological formations. This provides a fresh canvas without losing any progress.

The "Rebirth": This is a complete and total reset to the default starting conditions.

User Interface (The Minimalist Philosophy):
The guiding principle is "minimal rules, maximal creativity." The UI will be clean, contextual, and unobtrusive. The only persistent on-screen elements will be a health/energy display. All other menus, including the Schema Web and inventory, will be a single button press away, ensuring the player's view of their creation is as unobstructed as possible.



This is another excellent round of refinements. You've made some decisive choices that dramatically solidify the game's identity, leaning hard into the "frustration-as-feature" engineering mindset and simplifying the social mechanics to their absolute core.

This is a critical step, as it defines what the game is not, which is just as important as defining what it is.

Let's integrate these decisions. This feels like the final "policy" pass on the design.

Whitepaper Addendum 1.2: Core Identity & Gameplay Finalization

This document finalizes key gameplay and interaction systems based on a philosophy of minimalist rules, emergent complexity, and a focus on challenging, consequence-driven engineering.

1. Core Gameplay Systems & Mechanics Finalized

Resource Gathering (The Matter Beam):
The primary tool for interaction with the world is the Matter Beam. This tool handles both resource gathering and construction.

Functionality:

Left-Click (Deconstruct): A focused beam that "zaps" a single targeted tetrahedron block, instantly depositing it into the player's inventory.

Right-Click (Construct): Projects a holographic guide for block placement. Clicking again "zaps" the required block from the player's inventory into the world, solidifying it.

Progressive Revelation: The material composition of the world is tied to the player's technological progression.

Initial State: A new player's Matter Beam can only perceive and deconstruct the most basic elements. The entire world appears to be made of only Iron and Carbon.

Unlocked Perception: As a player unlocks a new material (e.g., "Aluminum Electrolysis") in the Schema Web, their Matter Beam is upgraded. They can now "perceive" that material, and pre-existing blocks in the world that were always Bauxite will now be revealed and become gatherable. This seamlessly integrates exploration with technological advancement.

The Avatar (The "Spider-Bot" Revelation):
The player experience is designed to be a surprising reveal.

First-Person Perspective: The game is played from a standard first-person view, giving the player the impression of being a humanoid character.

The Reveal: The player avatar is, in fact, a three-legged, spider-like robot that fits within a roughly spherical/octahedral space. This is only discovered when the player first sees another player or uses a potential third-person camera. This reinforces the game's identity as being about mechanical engineering, not human survival.

Survival Mechanics: The avatar has a health bar and can be destroyed by enemy constructs or (if enabled) other players. There are no other survival needs (e.g., hunger, oxygen).

The Consequence of Physics ("Frustration by Design"):
The game will not provide players with "quality-of-life" tools to circumvent the consequences of physics.

No Magic Fixes: If a vehicle flips over, it must be righted using physics-based tools the player engineers, such as cranes, pistons, or simply by nudging it with another vehicle. There are no "gravity guns" or "reset vehicle" buttons.

Destruction is Final: If a creation shatters due to structural failure, it must be manually repaired or rebuilt from its blueprint. This philosophy elevates the role of the engineer; good design isn't just a suggestion, it's a requirement for success.

2. Social and Multi-Shard Interaction Rules Finalized

Guest Permissions (The "Museum" Protocol):
The rules for guest players are now strictly defined and simplified to eliminate griefing and complex permission management.

World Interaction: Guest players can only interact with their own Transient Entities (the blocks, vehicles, and items they brought with them). The host's Shard and all its contents are effectively indestructible and immovable to guests.

Permitted Actions: Guests are limited to three actions:

Exploration: Moving through the host's world.

Combat: Engaging hostile enemy Constructs.

PvP: Fighting the host player or other guests (only if explicitly enabled by the host).

Rationale: This turns visiting another Shard into an act of tourism, exploration, or cooperative defense, not collaborative building. Large-scale collaborative projects will require the out-of-game social contract of sharing a single account or Shard.

Social Structures (The Emergent Mandate):
Alliances and rivalries will remain purely conceptual, player-driven social constructs.

No In-Game Systems: There will be no formal, in-game mechanics for creating alliances, declaring war, or setting standings.

Function: This forces players to rely on the game's core communication and access control tools (Whitelist/Blacklist) to manage their relationships. An "alliance" is simply a group of players who have all whitelisted each other. This adheres to the "minimal rules, maximal creativity" philosophy.

Portal Permanence and World Resets:
The fate of a portal is now directly and irrevocably tied to the state of its host Shard.

Rule: If a player executes a "Remix" or "Rebirth" on their Shard, any existing portal structure is instantly destroyed.

Consequence: A world reset is a significant decision. It offers a fresh start at the cost of severing all existing portal connections. Any player wishing to reconnect their Shard must rebuild their portal from scratch, re-establishing the link through their own effort. This makes portals feel like significant, hard-won achievements that require maintenance and protection.

This is the final polish. Your answers to the last round of questions have resolved the remaining ambiguities with clear, uncompromising design choices that reinforce the game's core identity. You are consistently choosing minimalist, player-driven mechanics over complex, developer-mandated systems.

The design is now internally consistent and robust. Let's formalize these final rules.

Whitepaper Addendum 1.3: Systemic Rulebook & Finalization

This document codifies the final set of rules governing physics, player mechanics, and the in-game economy, completing the foundational design of Tetcraft.

1. Physics and Interaction Rules Finalized

Transient-on-Host Collision Model:
The consequence of a guest's vehicle colliding with a host's invulnerable structures is governed by the Escrow Protocol. The vehicle will take realistic physical damage from the impact. If the damage is catastrophic or the vehicle becomes irrecoverably stuck, the player's ultimate recourse is to disconnect. This will trigger the State Reversion process, returning their vehicle and inventory to their home Shard in the exact state it was in before they departed. Any fuel or ammunition expended during the visit is lost, representing the "cost" of the failed expedition.

Transient Object Placement & Interaction:
Guests can attach their own transient blocks to the host's static world. This enables actions like building a temporary bridge or setting up a defensive wall.

Ownership & Transience: Ownership is never transferred. These transient blocks remain fully interactable for the guest but are intangible and invulnerable to the host.

Resource Transfer: Guests can use their own devices (e.g., a refinery) to process the host's resources, provided the host grants them permission to access a resource container. The "work" (the refined material) remains on the host Shard; the guest's machine is merely a tool.

Departure Purge: Upon the guest's departure, all of their transient blocks are purged from the host world and returned via the Escrow Protocol.

Projectile Interaction:
To ensure the strategic integrity of the host's structures in PvP, any projectile fired by a guest that impacts a host-owned block will instantly vanish. It will not ricochet or deal damage. This makes the host's environment a true, impenetrable shield and a core tactical element.

2. The Player and Core Tool Mechanics Finalized

The Matter Beam (Final Specification):
The Matter Beam is a fundamental tool, not a piece of upgradable technology. It is the player's hands.

Range: It has a fixed, short range of approximately 10 meters (roughly 10 block lengths).

Power/Progression: It requires no power and has no progression path in the Schema Web. Its capabilities (i.e., which materials it can perceive) are upgraded automatically and passively as the player unlocks the relevant tech nodes.

Player Death and Respawn:
The consequences of death are simple, punitive, and player-managed.

Penalty: Upon death, the player instantly drops any and all items they were holding in their active inventory slots (not their entire inventory).

Respawn Location: The player respawns instantly at their designated Spawn Tetrahedron, a unique, indestructible block generated with their Shard. The location of this block is not explicitly marked on a map, making the "adventure" of securing and building around one's spawn point a key early-game objective.

Anti-Camping: The PvP menu (allowing the player to disable PvP on their Shard or blacklist the offending player) will be fully accessible during the respawn process to prevent griefing.

3. Economy and Resource Lifecycle Finalized

Resource Finiteness (The Infinite Universe):
The resources on any given Shard are finite. However, the universe of Shards is effectively infinite.

Gameplay Dynamic: This is not a problem to be solved, but a core goal to be pursued. It encourages the creation of "specialist" Shards (e.g., a "Beryllium-rich" Shard) and makes inter-shard trade the true engine of the endgame economy. The ultimate limit on a Shard's wealth is not the game, but the hardware it runs on and the time invested by the player.

Resource Discovery (The Self-Directed Researcher):
The game will not provide explicit guidance or breadcrumb trails for discovering new materials.

Mechanism: The Schema Web nodes will clearly state what they unlock (e.g., "Enables perception and refining of Titanium"). It is entirely the player's responsibility to read the tech web, form hypotheses, and choose their research path. Wasting resources on a sub-optimal path is a valid and intended part of the learning experience.

The Act of Trading (The Handshake Deal):
Trade will be handled via a minimalist, player-driven interface.

Mechanism: Players will use a chat command (e.g., /trade [playername]) to initiate a secure, face-to-face trade window. The existence of this command will be taught through player-to-player communication, reinforcing the community-centric nature of the game. Asynchronous trade via "vending machines" will not be implemented, prioritizing direct player interaction.

Endgame Resource Sinks (The Cosmic Dream):
The primary endgame resource sink is the boundless ambition of the players.

High-Cost Technology: The natural progression of the Schema Web means that higher-tier items (advanced ammo, portal fuel, superior alloys) inherently cost more in terms of both rare materials and manufacturing complexity.

Player-Driven Goals: The game will not create artificial resource sinks. Instead, it provides the tools for players to create their own "cosmic dreams"—be it a 1:1 scale replica of a famous sci-fi ship, a city-sized art installation, or a Dyson sphere. The pursuit of these player-defined megaprojects will be the ultimate driver of the late-game economy.

With these rules codified, the conceptual design of Tetcraft is complete. It stands as a challenging, minimalist, and deeply player-driven sandbox universe.


------

Below is a **concrete, implementable standalone client specification** for **Tetcraft**, designed to be the **authoritative Shard host + player client** in one executable.
This is not marketing or concept art — it is a **software blueprint** you could hand to an engine team and begin building immediately.

I’ll structure this as:

1. **What “Standalone Client” means for Tetcraft**
2. **High-level architecture**
3. **Subsystem breakdown**
4. **Networking model (Shard hosting)**
5. **Physics & tetrahedral engine**
6. **Data formats (blueprints, materials, snapshots)**
7. **Minimal vertical-slice implementation plan**
8. **Recommended tech stack (pragmatic, not dogmatic)**

---

## 1. What “Standalone Client” Means for Tetcraft

A Tetcraft client is **not** just a renderer or a thin frontend.

Each client is:

* 🎮 A **full game client**
* 🌍 A **Shard authority server**
* 🔗 A **P2P networking node**
* 💾 A **world database**
* ⚙️ A **deterministic physics simulator**

> There is no separate “dedicated server” binary.
>
> **Running the client = hosting your universe.**

---

## 2. High-Level Architecture

```
┌───────────────────────────┐
│        Tetcraft.exe       │
│                           │
│  ┌─────────────────────┐ │
│  │ Rendering / UI      │ │
│  └─────────────────────┘ │
│            │              │
│  ┌─────────────────────┐ │
│  │ Player Input        │ │
│  └─────────────────────┘ │
│            │ Intent       │
│  ┌─────────────────────┐ │
│  │ Shard Authority     │◄──────── Guests
│  │ (Physics + Rules)   │ │
│  └─────────────────────┘ │
│            │              │
│  ┌─────────────────────┐ │
│  │ World Persistence   │ │
│  └─────────────────────┘ │
│            │              │
│  ┌─────────────────────┐ │
│  │ P2P Network Stack   │◄──────── Apeiron Index
│  └─────────────────────┘ │
└───────────────────────────┘
```

**Key principle:**

> *All gameplay state flows through the Shard Authority, even for the host player.*

This guarantees:

* Determinism
* Cheat resistance
* Identical logic paths for host and guests

---

## 3. Subsystem Breakdown

### 3.1 Rendering & UI Layer

Responsibilities:

* Visualize tetrahedral geometry
* Display Nexus joints (hinge, slider, rigid)
* Minimalist UI overlays
* Schema Web visualization
* Blueprint holograms

**Important:**
Rendering is **stateless**. It reflects authoritative simulation only.

---

### 3.2 Input → Intent System

Players never send “results”.

They send **intent packets**:

```json
{
  "type": "ATTEMPT_PLACE_BLOCK",
  "block_id": "tet_iron",
  "nexus_type": "hinge",
  "target_vertex": [123.0, 45.2, -9.1],
  "timestamp": 189234.23
}
```

Shard Authority decides:

* Is this legal?
* Does inventory allow it?
* Does physics permit it?

---

### 3.3 Shard Authority (Core of the Client)

This is the **heart of Tetcraft**.

Responsibilities:

* Physics simulation
* Material rules
* Enemy AI
* Schema Web validation
* Guest permissions
* Escrow Protocol enforcement

This runs:

* **Always**
* **Even in single-player**
* **Even if no one joins**

---

### 3.4 World Persistence Layer

World state is stored locally.

#### Saved Data:

* Tetrahedron graph
* Nexus graph
* Material composition
* Player spawn tetrahedron
* Schema Web progress
* Portal definitions
* Blueprint registry hashes

#### Not Saved:

* Guest transient entities
* Projectile state
* Temporary physics impulses

**Format:** chunked binary + JSON headers (details below)

---

### 3.5 P2P Network Stack

Responsibilities:

* NAT traversal (manual port forwarding assumed)
* Peer handshake
* Intent replication
* Snapshot escrow
* Trade protocol
* Portal connections

The **Apeiron Index** is only contacted for:

* Shard address lookup
* Blueprint hash registration

---

## 4. Networking Model (Shard Hosting)

### 4.1 Host Authority Model

* Host client = absolute truth
* Guests send:

  * Movement intent
  * Build intent
  * Combat intent
* Host sends:

  * World snapshots (delta)
  * Physics results
  * Damage events

No reconciliation.
No rollback.
No client-side authority.

---

### 4.2 Guest Lifecycle

1. Guest contacts Apeiron Index
2. Receives host IP
3. Direct TCP/UDP handshake
4. Host sends:

   * World terrain mesh
   * Host-owned structures (read-only)
5. Guest spawns **Transient Entity Root**
6. Escrow snapshot saved locally

---

### 4.3 Escrow Snapshot (Crash Safety)

```json
{
  "player_id": "guest_8472",
  "inventory": [...],
  "vehicles": [...],
  "fuel_state": {...},
  "timestamp": 189234.23
}
```

If disconnect:

* Host purges transient entities
* Guest reloads snapshot
* No reconciliation attempt

---

## 5. Physics & Tetrahedral Engine

### 5.1 Core Representation

```cpp
struct Tetrahedron {
    Vec3 vertices[4];
    MaterialID material;
}

struct Nexus {
    TetraID a;
    TetraID b;
    NexusType type;
    Constraint constraint;
}
```

All structures are **graphs**, not grids.

---

### 5.2 Physics Rules

* Mass = sum(material density × tetra volume)
* Stress propagates via Nexus constraints
* Failure = Nexus break, not “block delete”
* Flexible Nexus absorbs impulse
* Hinge Nexus limits rotation axis
* Slider Nexus limits translation axis

There is **no “weld all” fallback**.

---

### 5.3 Destruction

When constraints exceed tolerance:

* Nexus snaps
* Structure fragments
* Fragments become independent physics bodies
* Nothing auto-stabilizes

---

## 6. Data Formats

### 6.1 Blueprint File (`.tcbp`)

```json
{
  "hash": "SHA256(...)",
  "tetrahedrons": [...],
  "nexuses": [...],
  "materials": [...],
  "schema_requirements": [...],
  "locked": true
}
```

Hash registered with Apeiron Index if proprietary.

---

### 6.2 World Chunk (`.tcw`)

Binary:

* Vertex arrays
* Nexus arrays
* Material tables

JSON header:

```json
{
  "seed": 882173,
  "biome": "iron_mesa",
  "version": "1.0"
}
```

---

### 6.3 Schema Web

Pure data, no scripts:

```json
{
  "node_id": "MOTION_23",
  "unlocks": ["hinge_nexus_crafting"],
  "dependencies": ["MOTION_12", "ENERGY_04"]
}
```

---

## 7. Minimal Vertical-Slice Implementation Plan

If you were building this **tomorrow**, here’s the order:

### Phase 1 – Offline Single-Shard

* Tetrahedral placement
* Rigid Nexus only
* Matter Beam construct/deconstruct
* Save/load world

### Phase 2 – Physics

* Constraint solver
* Destruction
* Vehicle movement
* Hinge + Slider Nexuses

### Phase 3 – Shard Authority Loop

* Intent system
* Host-only simulation
* Enemy Constructs (basic)

### Phase 4 – P2P

* Guest join
* Transient entities
* Escrow snapshot
* Projectile rules

### Phase 5 – Schema + Materials

* Material perception gating
* Alchemical forge
* Blueprint scanner/projector

### Phase 6 – Portals

* Snapshot transfer
* ACL enforcement
* Portal destruction on Remix/Rebirth

---

## 8. Recommended Tech Stack (Pragmatic)

This is **not mandatory**, just realistic.

### Engine

* **Godot 4 (C++ modules)** or **Unity DOTS**
* Custom physics layer (do **not** use stock rigidbodies)

### Language

* Core: **C++**
* Tools/UI glue: **C# or GDScript**
* Networking serialization: **FlatBuffers or Cap’n Proto**

### Networking

* UDP for intents + snapshots
* TCP fallback for trades & portal handshakes

### Storage

* Binary chunk files
* JSON metadata
* SHA-256 for blueprint hashes

---

## Final Note

What you have designed is **not a game in the conventional sense**.

It is:

* A **distributed simulation platform**
* A **physics-enforced creative economy**
* A **social system that emerges from scarcity and effort**

This standalone client architecture **fully honors**:

* Player sovereignty
* Consequence-driven engineering
* Decentralized ownership
* Minimal rules, maximal emergence

Excellent — this is the **hard core** of Tetcraft.
I’ll keep this strictly **engineering-grade**, no fluff.

Below are **two tightly coupled specs**:

1. **Tetrahedral Constraint Solver** (deterministic, failure-capable, network-safe)
2. **Exact Network Packet Schemas** (byte-level intent & state replication)

Everything here is designed so that:

* Physics is authoritative on the host
* Guests cannot desync or cheat
* Destruction is inevitable, not patched over
* Simulation remains deterministic enough for P2P

---

# PART I — Tetrahedral Constraint Solver

## 1. Core Design Goals

The solver must:

1. Support **rigid + articulated structures**
2. Allow **partial failure** (nexus breakage)
3. Be **order-independent** (important for determinism)
4. Avoid floating-point chaos where possible
5. Scale from:

   * 10 tetrahedrons → tools
   * 10,000+ tetrahedrons → vehicles / factories

### Explicit Non-Goals

* Perfect real-world accuracy
* Infinite stiffness
* Fully continuous collision resolution

Tetcraft values **engineering consequence**, not aerospace simulation fidelity.

---

## 2. Fundamental Representation

### 2.1 Tetrahedron

```cpp
struct Tetrahedron {
    uint32_t id;
    Vec3 pos;            // center of mass
    Quat rot;            // orientation
    Vec3 linVel;
    Vec3 angVel;

    float mass;
    Mat3 inertiaTensor;

    MaterialID material;
    bool isStatic;       // true for host-owned terrain
}
```

Each tetrahedron is a **rigid body**, not a mesh fragment.

---

### 2.2 Nexus (Constraint)

```cpp
enum NexusType : uint8_t {
    RIGID,
    FLEXIBLE,
    HINGE,
    SLIDER
};

struct Nexus {
    uint32_t id;
    uint32_t tetA;
    uint32_t tetB;

    NexusType type;

    Vec3 localAnchorA;
    Vec3 localAnchorB;

    // Limits
    float maxForce;
    float maxTorque;
    float breakThreshold;   // accumulated stress

    // Runtime
    float accumulatedStress;
    bool broken;
}
```

> **Important:** Nexuses break due to **stress accumulation**, not instant impulse.

---

## 3. Solver Architecture

### 3.1 Solver Type

Use a **Position-Based Dynamics (PBD)** variant with **stress accounting**.

Why:

* Stable at large timesteps
* Easy constraint breaking
* Deterministic iteration count
* Widely used in destruction-capable games

---

### 3.2 Simulation Step Order (Authoritative)

```
1. Apply forces (gravity, engines, impacts)
2. Integrate velocities (semi-implicit Euler)
3. Predict positions
4. Solve constraints (iterative)
5. Accumulate stress
6. Break nexuses
7. Resolve collisions
8. Commit positions & velocities
```

**No rollback. No rewind.**

---

## 4. Constraint Solving (By Nexus Type)

### 4.1 Common Math

For each nexus:

```cpp
worldA = tetA.pos + tetA.rot * localAnchorA
worldB = tetB.pos + tetB.rot * localAnchorB

delta = worldB - worldA
```

---

### 4.2 Rigid Nexus

**Goal:** Keep anchors coincident

Constraint:

```
C = |delta|
```

Correction:

```cpp
Vec3 correction = delta * stiffness
tetA.pos += correction * invMassA
tetB.pos -= correction * invMassB
```

Stress accumulation:

```cpp
accumulatedStress += |correction| * effectiveMass
```

Break if:

```
accumulatedStress > breakThreshold
```

---

### 4.3 Flexible Nexus

Same as rigid, but:

* Lower stiffness
* Stress accumulation scaled by velocity delta
* Damping applied

```cpp
accumulatedStress += |delta| * flexCoefficient
```

Used for:

* Suspension
* Armor
* Shock absorption

---

### 4.4 Hinge Nexus

**Constraints enforced:**

1. Anchor coincidence
2. Rotation allowed only around axis

Implementation:

* Use **two orthogonal angular constraints**
* Allow rotation around hinge axis only

If angular velocity exceeds limits:

```cpp
angularCorrection = clamp(...)
accumulatedStress += |angularCorrection|
```

---

### 4.5 Slider Nexus

**Constraints enforced:**

1. Anchor locked to a line
2. Translation allowed only along axis
3. Optional min/max limits

Break stress increases if:

* Lateral deviation
* Limit collision
* Sudden impulse reversal

---

## 5. Stress & Failure Model (Critical)

Stress is **not reset each frame**.

```cpp
accumulatedStress = lerp(accumulatedStress, 0, stressRecoveryRate)
```

Meaning:

* Repeated abuse causes eventual failure
* Overengineering matters
* “One bad landing” may be survivable — three won’t be

When broken:

* Nexus is removed
* No auto-repair
* Structure fragments immediately

---

## 6. Collision Model

* Tetrahedron vs tetrahedron (simplified convex hull)
* Guest projectile vs host terrain → **auto-vanish**
* Guest vehicle vs host terrain → impulse applies to guest only

Collision impulses also feed stress into nexuses.

---

## 7. Determinism Rules

To keep host & guests sane:

* Fixed timestep (e.g. 60 Hz)
* Fixed iteration count (e.g. 12)
* No random numbers inside solver
* Break events broadcast explicitly

---

# PART II — Network Packet Schemas

Everything here is **explicit**, no “engine magic”.

---

## 1. Transport Layer

| Purpose            | Protocol |
| ------------------ | -------- |
| Intents            | UDP      |
| State snapshots    | UDP      |
| Trade / Portal     | TCP      |
| Blueprint registry | HTTPS    |

---

## 2. Packet Header (All Packets)

```c
struct PacketHeader {
    uint16_t packetType;
    uint16_t size;
    uint32_t shardID;
    uint32_t senderID;
    uint32_t tick;       // authoritative tick
}
```

---

## 3. Intent Packets (Client → Host)

### 3.1 Movement Intent

```c
struct MoveIntent {
    PacketHeader h;
    Vec3 desiredDirection;
    bool jump;
}
```

---

### 3.2 Construct / Deconstruct Intent

```c
struct BuildIntent {
    PacketHeader h;
    uint32_t tetraID;
    NexusType nexusType;
    uint32_t targetTetra;
    uint8_t targetVertex;
}
```

Host validates:

* Inventory
* Permissions
* Physics feasibility

---

### 3.3 Combat Intent

```c
struct FireIntent {
    PacketHeader h;
    uint32_t weaponID;
    Vec3 aimDir;
}
```

---

## 4. Authoritative State Packets (Host → Clients)

### 4.1 Tetrahedron State Delta

```c
struct TetraState {
    uint32_t tetraID;
    Vec3 pos;
    Quat rot;
    Vec3 linVel;
    Vec3 angVel;
}
```

Sent:

* Only for visible entities
* Delta-compressed

---

### 4.2 Nexus Break Event

```c
struct NexusBreak {
    PacketHeader h;
    uint32_t nexusID;
}
```

This is **non-negotiable truth**.

---

### 4.3 Damage Event

```c
struct DamageEvent {
    PacketHeader h;
    uint32_t targetID;
    float damage;
}
```

---

## 5. Escrow Protocol Packets

### 5.1 Departure Snapshot (Client-local, not sent)

But host is notified:

```c
struct PortalExit {
    PacketHeader h;
    uint32_t portalID;
}
```

---

### 5.2 Disorderly Disconnect

Host:

* Purges transient entities
* Sends nothing

Client:

* Loads snapshot locally

---

## 6. Trade Protocol (TCP, Two-Phase Commit)

### 6.1 Trade Offer

```json
{
  "offerer": "playerA",
  "items": [...],
  "blueprints": [...],
  "checksum": "SHA256"
}
```

### 6.2 Trade Accept → Commit

Only when both sides confirm checksum.

---

## 7. Blueprint Registry (Apeiron Index)

```json
POST /registerBlueprint
{
  "hash": "SHA256",
  "creator": "playerID",
  "locked": true
}
```

Duplicate hash → rejected.

---

# Closing Notes

What you now have is:

* A **breakable, stress-driven physics core**
* A **clean, minimal, cheat-resistant network model**
* A system where:

  * Engineering skill matters
  * Copying designs has limits
  * Physics failures tell stories

This is **absolutely buildable**.




---------------------


Below is a **single, coherent, end-to-end pseudocode implementation** of the **Tetcraft standalone client**.

This is written as if it were the **authoritative reference implementation**:
one executable, one process, hosting a Shard, rendering, simulating, networking.

It is intentionally language-neutral but **strongly typed**, closer to C++/Rust than scripting.

---

# TETCRAFT STANDALONE CLIENT — FULL PSEUDOCODE

---

## 0. Entry Point

```pseudocode
function main():
    Config.load()
    Logger.init()

    Client = TetcraftClient()
    Client.initialize()
    Client.run()
```

---

## 1. Core Client Object

```pseudocode
class TetcraftClient:
    Renderer renderer
    InputSystem input
    NetworkManager network
    ShardAuthority shard
    WorldPersistence persistence
    UIManager ui
    Clock clock

    bool running = true

    function initialize():
        renderer.init()
        input.init()
        ui.init()

        persistence.loadOrCreateShard()
        shard = ShardAuthority(persistence.worldData)

        network.init(shard)
        clock.setFixedTimestep(1 / 60)

    function run():
        while running:
            clock.beginFrame()

            input.poll()
            intents = input.collectIntents()
            shard.enqueueLocalIntents(intents)

            network.poll()          // receive guest intents / packets
            shard.update(clock.dt)  // authoritative simulation

            network.broadcastState(shard.exportNetState())
            renderer.draw(shard, ui)

            clock.endFrame()
```

---

## 2. Shard Authority (Authoritative Simulation Core)

```pseudocode
class ShardAuthority:
    World world
    PhysicsSolver physics
    IntentQueue intentQueue
    SchemaWeb schema
    EnemySystem enemies
    PermissionSystem permissions
    EscrowManager escrow
    TickCounter tick

    function update(dt):
        tick.increment()

        processIntents()
        physics.step(world, dt)
        enemies.update(world, dt)
        cleanupDestroyedEntities()

    function enqueueLocalIntents(intents):
        for intent in intents:
            intentQueue.push(intent)

    function enqueueRemoteIntent(intent):
        if permissions.validate(intent.sender):
            intentQueue.push(intent)

    function processIntents():
        while intentQueue.notEmpty():
            intent = intentQueue.pop()
            resolveIntent(intent)

    function resolveIntent(intent):
        switch intent.type:
            case MOVE:
                world.applyMovement(intent)
            case BUILD:
                world.tryPlaceBlock(intent)
            case DECONSTRUCT:
                world.tryRemoveBlock(intent)
            case FIRE:
                world.spawnProjectile(intent)
```

---

## 3. World Representation

```pseudocode
class World:
    Map<uint32, Tetrahedron> tetrahedrons
    Map<uint32, Nexus> nexuses
    Map<uint32, PlayerAvatar> players
    Terrain staticTerrain

    function applyMovement(intent):
        avatar = players[intent.sender]
        avatar.applyForce(intent.direction)

    function tryPlaceBlock(intent):
        if inventoryCheck(intent.sender, intent.block):
            createTetrahedron(intent)

    function tryRemoveBlock(intent):
        if permissions.canModify(intent.sender, intent.target):
            removeTetrahedron(intent.target)
```

---

## 4. Physics Solver (Constraint-Based, Breakable)

```pseudocode
class PhysicsSolver:
    const ITERATIONS = 12
    const GRAVITY = Vec3(0, -9.8, 0)

    function step(world, dt):
        applyForces(world)
        integrateVelocities(world, dt)
        predictPositions(world, dt)

        for i in 1..ITERATIONS:
            solveConstraints(world)

        accumulateStress(world)
        breakFailedNexuses(world)
        resolveCollisions(world)
        commitPositions(world)

    function applyForces(world):
        for tet in world.tetrahedrons:
            if not tet.isStatic:
                tet.linVel += GRAVITY * dt

    function solveConstraints(world):
        for nexus in world.nexuses:
            if nexus.broken:
                continue
            solveNexus(nexus, world)

    function solveNexus(nexus, world):
        A = world.tetrahedrons[nexus.tetA]
        B = world.tetrahedrons[nexus.tetB]

        worldA = A.pos + A.rot * nexus.localAnchorA
        worldB = B.pos + B.rot * nexus.localAnchorB
        delta = worldB - worldA

        switch nexus.type:
            case RIGID:
                correction = delta * 0.5
            case FLEXIBLE:
                correction = delta * 0.2
            case HINGE:
                correction = projectOffAxis(delta, nexus.axis)
            case SLIDER:
                correction = clampToAxis(delta, nexus.axis)

        applyCorrection(A, B, correction)
        nexus.accumulatedStress += length(correction)

    function breakFailedNexuses(world):
        for nexus in world.nexuses:
            if nexus.accumulatedStress > nexus.breakThreshold:
                nexus.broken = true
                world.emitEvent(NEXUS_BREAK, nexus.id)
```

---

## 5. Player Avatar (Spider-Bot)

```pseudocode
class PlayerAvatar:
    Vec3 pos
    Vec3 vel
    float health
    Inventory inventory
    SpawnTetra spawn

    function applyForce(dir):
        vel += normalize(dir) * MOVE_FORCE

    function update(dt):
        pos += vel * dt
```

---

## 6. Matter Beam

```pseudocode
class MatterBeam:
    const RANGE = 10.0

    function deconstruct(target):
        if distance(player.pos, target.pos) <= RANGE:
            inventory.add(target.material)
            world.removeTetrahedron(target.id)

    function construct(blueprint):
        if inventory.has(blueprint.requirements):
            world.instantiateBlueprint(blueprint)
```

---

## 7. Networking Layer

```pseudocode
class NetworkManager:
    UdpSocket udp
    TcpSocket tcp
    ShardAuthority shard

    function init(shard):
        this.shard = shard
        udp.bind(Config.port)

    function poll():
        packets = udp.receive()
        for packet in packets:
            handlePacket(packet)

    function handlePacket(packet):
        switch packet.type:
            case INTENT:
                shard.enqueueRemoteIntent(packet.payload)
            case TRADE:
                handleTrade(packet)

    function broadcastState(state):
        udp.sendToAll(state)
```

---

## 8. Escrow Manager

```pseudocode
class EscrowManager:
    Map<PlayerID, Snapshot> snapshots

    function saveSnapshot(player):
        snapshots[player.id] = serialize(player)

    function restoreSnapshot(player):
        player = deserialize(snapshots[player.id])
```

---

## 9. Persistence

```pseudocode
class WorldPersistence:
    WorldData worldData

    function loadOrCreateShard():
        if exists("world.tcw"):
            worldData = load("world.tcw")
        else:
            worldData = generateNewWorld()
```

---

## 10. Renderer (Stateless)

```pseudocode
class Renderer:
    function draw(shard, ui):
        for tet in shard.world.tetrahedrons:
            drawTetrahedron(tet)

        for nexus in shard.world.nexuses:
            if not nexus.broken:
                drawNexus(nexus)

        ui.draw()
```

---

## 11. UI System (Minimalist)

```pseudocode
class UIManager:
    function draw():
        drawHealthBar()
        if keyPressed(TAB):
            drawInventory()
        if keyPressed(SCHEMA_KEY):
            drawSchemaWeb()
```

---

## 12. Shutdown

```pseudocode
onExit():
    persistence.save(world)
    network.shutdown()
    renderer.shutdown()
```

---

# FINAL NOTES

What you now have is:

* A **complete executable mental model**
* No hidden systems
* No hand-waving
* Every rule enforced in code, not policy

This is **not** a toy architecture.
It is a **distributed physics engine wearing a game as an interface**.



-------------------



pseudocode main.py:

# ============================================================
# TETCRAFT STANDALONE CLIENT (REFERENCE IMPLEMENTATION)
# ============================================================

import time
import math
from collections import deque
from dataclasses import dataclass, field
from typing import Dict, List, Tuple, Optional

# ============================================================
# BASIC MATH
# ============================================================

@dataclass
class Vec3:
    x: float
    y: float
    z: float

    def __add__(self, o): return Vec3(self.x+o.x, self.y+o.y, self.z+o.z)
    def __sub__(self, o): return Vec3(self.x-o.x, self.y-o.y, self.z-o.z)
    def __mul__(self, s): return Vec3(self.x*s, self.y*s, self.z*s)

    def length(self):
        return math.sqrt(self.x*self.x + self.y*self.y + self.z*self.z)

    def normalize(self):
        l = self.length()
        return self if l == 0 else self * (1.0 / l)


# ============================================================
# CORE DATA TYPES
# ============================================================

class NexusType:
    RIGID = 0
    FLEXIBLE = 1
    HINGE = 2
    SLIDER = 3


@dataclass
class Tetrahedron:
    id: int
    pos: Vec3
    vel: Vec3
    mass: float
    is_static: bool = False


@dataclass
class Nexus:
    id: int
    a: int
    b: int
    type: int
    break_threshold: float
    accumulated_stress: float = 0.0
    broken: bool = False


# ============================================================
# WORLD
# ============================================================

class World:
    def __init__(self):
        self.tetrahedrons: Dict[int, Tetrahedron] = {}
        self.nexuses: Dict[int, Nexus] = {}
        self.next_tet_id = 1
        self.next_nexus_id = 1

    def add_tetra(self, pos, mass=1.0, static=False):
        t = Tetrahedron(self.next_tet_id, pos, Vec3(0,0,0), mass, static)
        self.tetrahedrons[t.id] = t
        self.next_tet_id += 1
        return t.id

    def add_nexus(self, a, b, ntype, threshold):
        n = Nexus(self.next_nexus_id, a, b, ntype, threshold)
        self.nexuses[n.id] = n
        self.next_nexus_id += 1
        return n.id


# ============================================================
# INTENTS
# ============================================================

class IntentType:
    MOVE = 0
    BUILD = 1
    FIRE = 2


@dataclass
class Intent:
    sender: int
    type: int
    data: dict


# ============================================================
# PHYSICS SOLVER
# ============================================================

class PhysicsSolver:
    GRAVITY = Vec3(0, -9.8, 0)
    ITERATIONS = 12

    def step(self, world: World, dt: float):
        self.apply_forces(world, dt)
        self.integrate(world, dt)

        for _ in range(self.ITERATIONS):
            self.solve_constraints(world)

        self.break_nexuses(world)

    def apply_forces(self, world, dt):
        for t in world.tetrahedrons.values():
            if not t.is_static:
                t.vel = t.vel + self.GRAVITY * dt

    def integrate(self, world, dt):
        for t in world.tetrahedrons.values():
            if not t.is_static:
                t.pos = t.pos + t.vel * dt

    def solve_constraints(self, world):
        for n in world.nexuses.values():
            if n.broken:
                continue

            a = world.tetrahedrons[n.a]
            b = world.tetrahedrons[n.b]
            delta = b.pos - a.pos

            if n.type == NexusType.RIGID:
                correction = delta * 0.5
            elif n.type == NexusType.FLEXIBLE:
                correction = delta * 0.2
            else:
                correction = delta * 0.3

            if not a.is_static:
                a.pos = a.pos + correction
            if not b.is_static:
                b.pos = b.pos - correction

            n.accumulated_stress += correction.length()

    def break_nexuses(self, world):
        for n in world.nexuses.values():
            if not n.broken and n.accumulated_stress > n.break_threshold:
                n.broken = True
                print(f"[PHYSICS] Nexus {n.id} broke!")


# ============================================================
# SHARD AUTHORITY
# ============================================================

class ShardAuthority:
    def __init__(self, world: World):
        self.world = world
        self.physics = PhysicsSolver()
        self.intents = deque()
        self.tick = 0

    def enqueue_intent(self, intent: Intent):
        self.intents.append(intent)

    def update(self, dt):
        self.tick += 1
        self.process_intents()
        self.physics.step(self.world, dt)

    def process_intents(self):
        while self.intents:
            i = self.intents.popleft()
            if i.type == IntentType.MOVE:
                self.handle_move(i)

    def handle_move(self, intent):
        tet = self.world.tetrahedrons.get(intent.sender)
        if tet:
            direction = intent.data["dir"].normalize()
            tet.vel = tet.vel + direction * 5.0


# ============================================================
# NETWORK (SIMULATED)
# ============================================================

class NetworkManager:
    def __init__(self, shard: ShardAuthority):
        self.shard = shard

    def poll(self):
        pass  # placeholder for UDP/TCP

    def broadcast_state(self):
        pass


# ============================================================
# RENDERER (TEXT MODE)
# ============================================================

class Renderer:
    def draw(self, world: World):
        print("---- WORLD STATE ----")
        for t in world.tetrahedrons.values():
            print(f"Tet {t.id}: pos=({t.pos.x:.2f},{t.pos.y:.2f},{t.pos.z:.2f})")
        for n in world.nexuses.values():
            if n.broken:
                print(f"Nexus {n.id}: BROKEN")
        print("---------------------")


# ============================================================
# CLIENT
# ============================================================

class TetcraftClient:
    def __init__(self):
        self.world = World()
        self.shard = ShardAuthority(self.world)
        self.network = NetworkManager(self.shard)
        self.renderer = Renderer()
        self.running = True

    def initialize(self):
        # Create a simple test structure
        a = self.world.add_tetra(Vec3(0,0,0), static=True)
        b = self.world.add_tetra(Vec3(0,2,0))
        self.world.add_nexus(a, b, NexusType.RIGID, threshold=5.0)

    def run(self):
        last = time.time()
        while self.running:
            now = time.time()
            dt = now - last
            last = now

            self.network.poll()

            # Fake local input
            self.shard.enqueue_intent(Intent(
                sender=2,
                type=IntentType.MOVE,
                data={"dir": Vec3(1,0,0)}
            ))

            self.shard.update(dt)
            self.renderer.draw(self.world)

            time.sleep(1/10)


# ============================================================
# ENTRY POINT
# ============================================================

if __name__ == "__main__":
    client = TetcraftClient()
    client.initialize()
    client.run()


---------------------


4.1 Extend Nexus Definition

Replace your existing Nexus dataclass with this:

@dataclass
class Nexus:
    id: int
    a: int
    b: int
    type: int
    break_threshold: float

    axis: Vec3 = Vec3(0, 1, 0)     # hinge / slider axis
    min_limit: float = -math.inf  # slider
    max_limit: float = math.inf

    accumulated_stress: float = 0.0
    broken: bool = False

4.2 Add Vector Projection Helpers

Add these utility functions near Vec3:

def dot(a: Vec3, b: Vec3) -> float:
    return a.x*b.x + a.y*b.y + a.z*b.z

def project(v: Vec3, axis: Vec3) -> Vec3:
    n = axis.normalize()
    return n * dot(v, n)

def reject(v: Vec3, axis: Vec3) -> Vec3:
    return v - project(v, axis)


4.3 Replace solve_constraints in PhysicsSolver

Replace the entire method with this version:

def solve_constraints(self, world):
    for n in world.nexuses.values():
        if n.broken:
            continue

        a = world.tetrahedrons[n.a]
        b = world.tetrahedrons[n.b]

        delta = b.pos - a.pos
        correction = Vec3(0,0,0)

        if n.type == NexusType.RIGID:
            correction = delta * 0.5

        elif n.type == NexusType.FLEXIBLE:
            correction = delta * 0.2

        elif n.type == NexusType.HINGE:
            # allow motion along axis, reject perpendicular drift
            lateral = reject(delta, n.axis)
            correction = lateral * 0.5

        elif n.type == NexusType.SLIDER:
            # allow only motion along axis
            along = project(delta, n.axis)
            dist = along.length()

            if dist < n.min_limit:
                correction = along.normalize() * (n.min_limit - dist)
            elif dist > n.max_limit:
                correction = along.normalize() * (n.max_limit - dist)
            else:
                correction = reject(delta, n.axis) * 0.5

        if not a.is_static:
            a.pos = a.pos + correction
        if not b.is_static:
            b.pos = b.pos - correction

        n.accumulated_stress += correction.length()

5.1 Material Definitions

Add this section near the top:

@dataclass
class Material:
    name: str
    atomic_number: int
    density: float
    hardness: float
    conductivity: float


Base element registry:

BASE_MATERIALS = {
    "Iron": Material("Iron", 26, 7.8, 6.0, 1.0),
    "Carbon": Material("Carbon", 6, 2.2, 10.0, 0.1),
    "Copper": Material("Copper", 29, 8.9, 3.0, 5.0),
}

5.2 Alchemical Forge

Add this class:

class AlchemicalForge:
    def combine(self, a: Material, b: Material, filter_attr: str):
        # Rule of Dominance
        if a.atomic_number >= b.atomic_number:
            base, additive = a, b
        else:
            base, additive = b, a

        name = f"{additive.name}-ized {base.name}"

        def blend(x, y):
            return (x * 0.8) + (y * 0.2)

        density = blend(base.density, additive.density)
        hardness = blend(base.hardness, additive.hardness)
        conductivity = blend(base.conductivity, additive.conductivity)

        # Attribute filtering
        if filter_attr == "hardness":
            hardness = additive.hardness
        elif filter_attr == "conductivity":
            conductivity = additive.conductivity
        elif filter_attr == "density":
            density = additive.density

        return Material(
            name=name,
            atomic_number=base.atomic_number,
            density=density,
            hardness=hardness,
            conductivity=conductivity
        )

5.3 Material Discovery (Schema-Gated Perception)

Add to ShardAuthority:

class ShardAuthority:
    def __init__(self, world):
        ...
        self.discovered_materials = {"Iron", "Carbon"}


Add helper:

def can_perceive(self, material_name):
    return material_name in self.discovered_materials


Later, when Schema nodes unlock:

self.discovered_materials.add("Copper")


💡 This directly enforces:

“The world was always copper — you just couldn’t see it.”

5.4 Using Materials in Tetrahedrons

Modify Tetrahedron:

@dataclass
class Tetrahedron:
    id: int
    pos: Vec3
    vel: Vec3
    mass: float
    material: Material
    is_static: bool = False


Mass can now be:

mass = material.density * VOLUME_CONSTANT


Structural failure now naturally emerges from material choice.


1.1 Extend Nexus (Angular State)

Replace / extend your Nexus definition:

@dataclass
class Nexus:
    id: int
    a: int
    b: int
    type: int
    break_threshold: float

    axis: Vec3 = Vec3(0,1,0)

    # Linear limits (slider)
    min_limit: float = -math.inf
    max_limit: float = math.inf

    # Angular state (hinge only)
    angle: float = 0.0
    angular_velocity: float = 0.0
    angular_damping: float = 0.98
    torque: float = 0.0
    min_angle: float = -math.pi
    max_angle: float = math.pi

    accumulated_stress: float = 0.0
    broken: bool = False

1.2 Torque Application API

Add this helper (used by player, AI, machines):

def apply_torque(world, nexus_id, torque):
    n = world.nexuses[nexus_id]
    if n.type == NexusType.HINGE and not n.broken:
        n.torque += torque

1.3 Update Physics Solver (Angular Integration)

Inside PhysicsSolver.step(), before constraint solving, add:

def integrate_hinges(self, world, dt):
    for n in world.nexuses.values():
        if n.broken or n.type != NexusType.HINGE:
            continue

        # Angular acceleration (unit inertia)
        n.angular_velocity += n.torque * dt
        n.angular_velocity *= n.angular_damping
        n.angle += n.angular_velocity * dt

        # Angular limits
        if n.angle < n.min_angle:
            n.angle = n.min_angle
            n.angular_velocity = 0
        elif n.angle > n.max_angle:
            n.angle = n.max_angle
            n.angular_velocity = 0

        # Torque produces stress
        n.accumulated_stress += abs(n.torque)

        # Reset torque after application
        n.torque = 0.0


Call it from step():

self.integrate_hinges(world, dt)
self.solve_constraints(world)

1.4 How Hinge Rotation Affects Position

Inside solve_constraints, replace the hinge section:

elif n.type == NexusType.HINGE:
    # perpendicular correction
    lateral = reject(delta, n.axis)

    # rotational displacement
    radius = lateral.length()
    rot_effect = n.axis.cross(lateral.normalize()) * (n.angular_velocity * radius)

    correction = (lateral * 0.5) + (rot_effect * 0.5)


This gives:

Doors that swing

Momentum carry-through

Torque-based failure

No Euler angle madness

PART 3 — MATERIAL-DRIVEN STRESS & FAILURE

Now hinges don’t just break — they fatigue based on what they’re made of.

3.1 Extend Material

Replace your Material class:

@dataclass
class Material:
    name: str
    atomic_number: int
    density: float
    hardness: float
    conductivity: float

    tensile_strength: float
    fatigue_limit: float


Example base materials:

BASE_MATERIALS = {
    "Iron": Material("Iron", 26, 7.8, 6.0, 1.0, 250.0, 120.0),
    "Carbon": Material("Carbon", 6, 2.2, 10.0, 0.1, 500.0, 300.0),
    "Copper": Material("Copper", 29, 8.9, 3.0, 5.0, 210.0, 80.0),
}

3.2 Assign Material to Nexus (Critical)

Modify nexus creation so it inherits the weaker material:

def nexus_material(world, a_id, b_id):
    ma = world.tetrahedrons[a_id].material
    mb = world.tetrahedrons[b_id].material
    return ma if ma.tensile_strength < mb.tensile_strength else mb


Store it:

n.material = nexus_material(world, a, b)


Add to Nexus:

material: Material = None

3.3 Stress Evaluation & Failure

Add this method to PhysicsSolver:

def evaluate_failure(self, world):
    for n in world.nexuses.values():
        if n.broken:
            continue

        mat = n.material
        if mat is None:
            continue

        # Instant failure
        if n.accumulated_stress > mat.tensile_strength:
            n.broken = True
            continue

        # Fatigue failure
        if n.accumulated_stress > mat.fatigue_limit:
            if random.random() < 0.01:
                n.broken = True


Call after constraint solving:

self.evaluate_failure(world)






----------




basic v.01 demo:


import pygame
import math
import random
import sys

# -----------------------------
# Physics Constants
# -----------------------------
DT = 0.016  # physics timestep
MAX_STRESS = 120.0
FATIGUE_RATE = 0.6
DAMPING = 0.995

# -----------------------------
# Hinge Constraint
# -----------------------------
class Hinge:
    def __init__(self):
        self.angle = 0.0
        self.angular_velocity = 0.0
        self.accumulated_stress = 0.0
        self.broken = False

    def apply_torque(self, torque):
        if self.broken:
            return

        self.angular_velocity += torque * DT

    def step(self):
        if self.broken:
            return

        self.angle += self.angular_velocity * DT
        self.angular_velocity *= DAMPING

        stress = abs(self.angular_velocity) * 25
        self.accumulated_stress += stress * FATIGUE_RATE

        if self.accumulated_stress > MAX_STRESS:
            print("💥 FATIGUE FAILURE: hinge finally gave way")
            self.broken = True
            self.angular_velocity = 0.0

# -----------------------------
# Pygame Setup
# -----------------------------
pygame.init()
WIDTH, HEIGHT = 800, 600
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Tetcraft — Hinge Constraint Demo")

clock = pygame.time.Clock()
font = pygame.font.SysFont("consolas", 18)

# -----------------------------
# Scene Setup
# -----------------------------
hinge = Hinge()
pivot = (WIDTH // 2, HEIGHT // 2)
arm_length = 180

# -----------------------------
# Main Loop
# -----------------------------
running = True
time_elapsed = 0.0

while running:
    clock.tick(60)
    time_elapsed += DT

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    # -----------------------------
    # Input → Torque
    # -----------------------------
    torque = 0.0
    keys = pygame.key.get_pressed()
    if keys[pygame.K_LEFT]:
        torque = -6.0
    if keys[pygame.K_RIGHT]:
        torque = 6.0

    hinge.apply_torque(torque)
    hinge.step()

    # -----------------------------
    # Rendering
    # -----------------------------
    screen.fill((20, 20, 25))

    # Pivot
    pygame.draw.circle(screen, (200, 200, 200), pivot, 8)

    # Arm
    if not hinge.broken:
        x = pivot[0] + math.cos(hinge.angle) * arm_length
        y = pivot[1] + math.sin(hinge.angle) * arm_length
        color = (255, 100, 100) if hinge.accumulated_stress > 0.7 * MAX_STRESS else (100, 200, 255)
        pygame.draw.line(screen, color, pivot, (x, y), 6)
        pygame.draw.circle(screen, color, (int(x), int(y)), 10)
    else:
        # Broken visualization
        pygame.draw.line(screen, (100, 100, 100), pivot,
                         (pivot[0] + 40, pivot[1] + 40), 4)

    # -----------------------------
    # UI Text
    # -----------------------------
    status = "BROKEN" if hinge.broken else "ACTIVE"
    stress_ratio = hinge.accumulated_stress / MAX_STRESS

    info = [
        f"Angle: {hinge.angle:+.2f} rad",
        f"ω: {hinge.angular_velocity:+.2f}",
        f"Stress: {hinge.accumulated_stress:.1f} / {MAX_STRESS}",
        f"State: {status}",
        "",
        "← / → : Apply torque",
        "Fatigue failure is permanent"
    ]

    for i, text in enumerate(info):
        label = font.render(text, True, (220, 220, 220))
        screen.blit(label, (20, 20 + i * 22))

    # Stress bar
    pygame.draw.rect(screen, (60, 60, 60), (20, HEIGHT - 40, 200, 12))
    pygame.draw.rect(
        screen,
        (255, 80, 80),
        (20, HEIGHT - 40, int(200 * min(stress_ratio, 1.0)), 12),
    )

    pygame.display.flip()

pygame.quit()
sys.exit()










--------------- v.02



import pygame
import math
import socket
import json
import sys

# ==============================
# Config
# ==============================
WIDTH, HEIGHT = 900, 600
DT = 0.016

HOST_PORT = 50051
CLIENT_PORT = 50052

HINGE_MAX_STRESS = 120
SLIDER_MAX_STRESS = 90

DRAG_TORQUE_SCALE = 0.12
DRAG_FORCE_SCALE = 0.18
GRAB_RADIUS = 50  # MUCH larger

# ==============================
# Networking
# ==============================
class Peer:
    def __init__(self):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sock.setblocking(False)

        try:
            self.sock.bind(("127.0.0.1", HOST_PORT))
            self.local_port = HOST_PORT
            self.remote_port = CLIENT_PORT
        except OSError:
            self.sock.bind(("127.0.0.1", CLIENT_PORT))
            self.local_port = CLIENT_PORT
            self.remote_port = HOST_PORT

        print(f"[NET] Bound to port {self.local_port}")

    def send(self, data):
        try:
            self.sock.sendto(
                json.dumps(data).encode(),
                ("127.0.0.1", self.remote_port)
            )
        except:
            pass

    def recv(self):
        try:
            msg, _ = self.sock.recvfrom(4096)
            return json.loads(msg.decode())
        except:
            return None

# ==============================
# Physics
# ==============================
class Hinge:
    def __init__(self):
        self.angle = 0.0
        self.omega = 0.0
        self.stress = 0.0
        self.broken = False

    def apply_torque(self, t):
        if not self.broken:
            self.omega += t * DT

    def step(self):
        if self.broken:
            return
        self.angle += self.omega * DT
        self.omega *= 0.99
        self.stress += abs(self.omega) * 25
        if self.stress > HINGE_MAX_STRESS:
            self.broken = True
            self.omega = 0.0
            self.angle += math.copysign(0.4, self.angle)

class Slider:
    def __init__(self):
        self.offset = 120
        self.velocity = 0.0
        self.stress = 0.0
        self.broken = False
        self.min = 60
        self.max = 200

    def apply_force(self, f):
        if not self.broken:
            self.velocity += f * DT

    def step(self):
        if self.broken:
            return
        self.offset += self.velocity * DT
        self.velocity *= 0.97

        if self.offset <= self.min or self.offset >= self.max:
            self.stress += abs(self.velocity) * 20

        self.offset = max(self.min, min(self.max, self.offset))

        if self.stress > SLIDER_MAX_STRESS:
            self.broken = True
            self.velocity = 0.0

class System:
    def __init__(self):
        self.hinge = Hinge()
        self.slider = Slider()

    def step(self):
        self.hinge.step()
        self.slider.step()

    def apply_intent(self, intent):
        self.hinge.apply_torque(intent["torque"])
        self.slider.apply_force(intent["force"])

    def serialize(self):
        return {
            "angle": self.hinge.angle,
            "hinge_stress": self.hinge.stress,
            "hinge_broken": self.hinge.broken,
            "slider": self.slider.offset,
            "slider_stress": self.slider.stress,
            "slider_broken": self.slider.broken
        }

# ==============================
# Pygame
# ==============================
pygame.init()
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Tetcraft — Drag VERIFIED")
font = pygame.font.SysFont("consolas", 16)
clock = pygame.time.Clock()

peer = Peer()
system = System()
remote_state = system.serialize()

pivot = (WIDTH // 2, HEIGHT // 2)
mode = "HOST" if peer.local_port == HOST_PORT else "CLIENT"

dragging = False
last_mouse = (0, 0)

print(f"[MODE] {mode}")

# ==============================
# Main Loop
# ==============================
running = True
while running:
    clock.tick(60)

    state = system.serialize() if mode == "HOST" else remote_state
    angle = state["angle"]
    length = state["slider"]
    end_pos = (
        pivot[0] + math.cos(angle) * length,
        pivot[1] + math.sin(angle) * length
    )

    for e in pygame.event.get():
        if e.type == pygame.QUIT:
            running = False

        if e.type == pygame.KEYDOWN and e.key == pygame.K_h:
            mode = "CLIENT" if mode == "HOST" else "HOST"
            print("[MODE]", mode)

        if e.type == pygame.MOUSEBUTTONDOWN and mode == "HOST":
            mx, my = e.pos
            # distance to LINE (not just endpoint)
            px, py = pivot
            ex, ey = end_pos
            t = max(0, min(1, ((mx-px)*(ex-px)+(my-py)*(ey-py)) /
                              ((ex-px)**2+(ey-py)**2)))
            cx = px + t * (ex-px)
            cy = py + t * (ey-py)

            if math.hypot(mx - cx, my - cy) < GRAB_RADIUS:
                dragging = True
                last_mouse = (mx, my)
                print(">>> GRAB START")

        if e.type == pygame.MOUSEBUTTONUP:
            if dragging:
                print("<<< GRAB END")
            dragging = False

    intent = {"torque": 0.0, "force": 0.0}

    if dragging:
        mx, my = pygame.mouse.get_pos()
        dx = mx - last_mouse[0]
        dy = my - last_mouse[1]
        last_mouse = (mx, my)

        intent["torque"] = dx * DRAG_TORQUE_SCALE
        intent["force"] = dy * DRAG_FORCE_SCALE

    if mode == "HOST":
        system.apply_intent(intent)
        system.step()
        peer.send({"state": system.serialize()})
    else:
        peer.send({"intent": intent})
        msg = peer.recv()
        if msg and "state" in msg:
            remote_state = msg["state"]

    # Render
    screen.fill((20, 20, 28))
    pygame.draw.circle(screen, (240, 240, 240), pivot, 6)

    arm_color = (255, 255, 80) if dragging else (120, 200, 255)
    if state["hinge_broken"]:
        arm_color = (255, 80, 80)

    pygame.draw.line(screen, arm_color, pivot, end_pos, 6)
    pygame.draw.circle(screen, (160, 255, 160), (int(end_pos[0]), int(end_pos[1])), 10)

    hud = [
        f"MODE: {mode} (press H)",
        "Grab ANYWHERE on arm",
        f"Dragging: {dragging}",
        f"Hinge stress: {state['hinge_stress']:.1f}",
        f"Slider stress: {state['slider_stress']:.1f}",
    ]

    for i, t in enumerate(hud):
        screen.blit(font.render(t, True, (220, 220, 220)), (20, 20 + i * 18))

    pygame.display.flip()

pygame.quit()
sys.exit()






--------------------




Tetcraft Whitepaper v2.0
Field-Emergent Constraint Mechanics for Modular Physical Construction
Abstract

Tetcraft is a physics-driven construction framework based on tetrahedral primitives whose interactions are governed by field-based cohesion and repulsion, rather than explicit joint types or designer-authored constraints. Structural behavior—hinges, sliders, rigid bonds, and failure—emerges automatically from proximity, material rigidity, and player interaction.

This paper defines the mathematical model, interaction rules, constraint solver, stress accumulation, failure mechanics, and a scalable progression system. The result is a system that is simpler to implement, richer to explore, deterministic under networking, and discoverable through play.

1. Design Principles

Emergence over designation
No explicit “hinge”, “slider”, or “fixed joint” flags exist.

Fields over joints
All binding is driven by attraction and repulsion fields.

Minimal player verbs
The player only grabs and moves tetrahedra.

Stress is continuous, not binary
Structures degrade before they fail.

Determinism first
Multiplayer synchronization depends on field rules, not events.

2. Fundamental Primitive: The Tetrahedron

Each tetrahedron consists of:

4 vertices:
𝑣
𝑖
∈
𝑅
2
v
i
	​

∈R
2
 or
𝑅
3
R
3

6 edges: implicit distance constraints

1 center of mass

Stored Properties
Property	Symbol	Description
Edge length
𝐿
L	Rest edge length
Rigidity
𝑘
𝑟
k
r
	​

	Constraint stiffness
Cohesion strength
𝑘
𝑐
k
c
	​

	Attraction field magnitude
Repulsion strength
𝑘
𝑝
k
p
	​

	Exclusion field magnitude
Yield stress
𝜎
𝑦
σ
y
	​

	Maximum tolerable accumulated stress
3. Field Model
3.1 Cohesion (Attraction) Field

Each vertex emits a spherical (radial) attraction field.

Radius
𝑅
𝑐
=
𝛼
𝐿
where
𝛼
=
0.75
R
c
	​

=αLwhere α=0.75
Force Law

For two vertices
𝑣
𝑎
v
a
	​

 and
𝑣
𝑏
v
b
	​

 belonging to different tetrahedra:

Let:

𝑑
=
∥
𝑣
𝑏
−
𝑣
𝑎
∥
d=∥v
b
	​

−v
a
	​

∥

If:

𝑑
<
𝑅
𝑐
d<R
c
	​


Then attraction force is applied:

𝐹
⃗
𝑐
=
𝑘
𝑐
(
1
−
𝑑
𝑅
𝑐
)
𝑛
^
where
𝑛
^
=
𝑣
𝑏
−
𝑣
𝑎
𝑑
F
c
	​

=k
c
	​

(1−
R
c
	​

d
	​

)
n
^
where
n
^
=
d
v
b
	​

−v
a
	​

	​


This creates a soft distance constraint whose rest length trends toward zero.

3.2 Emergent Binding Rule

A binding constraint is instantiated automatically when:

𝑑
<
𝑅
𝑐
d<R
c
	​


Each binding stores:

Rest length
𝑑
0
=
𝑑
d
0
	​

=d (at formation)

Rigidity
𝑘
𝑟
k
r
	​


Accumulated stress
𝜎
σ

No joint type is stored.

4. Repulsion (Exclusion) Field

Each tetrahedron emits a repulsion field from its center of mass.

Radius
𝑅
𝑝
=
𝑅
𝑐
R
p
	​

=R
c
	​

Force Law

For another tetrahedron center at distance
𝑑
d:

𝐹
⃗
𝑝
=
𝑘
𝑝
(
1
−
𝑑
𝑅
𝑝
)
(
−
𝑛
^
)
if
𝑑
<
𝑅
𝑝
F
p
	​

=k
p
	​

(1−
R
p
	​

d
	​

)(−
n
^
)if d<R
p
	​


Repulsion ensures:

No singular collapse

Clean separation when pulled apart

Stability under multi-binding

5. Emergent Mechanical Behavior
Number of Active Bindings	Emergent Behavior
1	Free rotation + sliding
2	Hinge (1 rotational DOF)
3	Planar rigidity
4	Full rigid fusion

No special logic is required—this follows naturally from constraint geometry.

6. Constraint Solver
Distance Constraint

For a binding between vertices
𝑖
i and
𝑗
j:

Δ
𝑑
=
∥
𝑣
𝑗
−
𝑣
𝑖
∥
−
𝑑
0
Δd=∥v
j
	​

−v
i
	​

∥−d
0
	​


Correction applied symmetrically:

𝐶
⃗
=
𝑘
𝑟
⋅
Δ
𝑑
⋅
𝑛
^
C
=k
r
	​

⋅Δd⋅
n
^

Applied as:

𝑣
𝑖
+
=
1
2
𝐶
⃗
,
𝑣
𝑗
−
=
1
2
𝐶
⃗
v
i
	​

+=
2
1
	​

C
,v
j
	​

−=
2
1
	​

C

This is compatible with Verlet, semi-implicit Euler, or PBD solvers.

7. Stress Accumulation & Failure
Stress Update

For each binding per timestep:

𝜎
←
𝜎
+
∣
Δ
𝑑
∣
⋅
𝑘
𝑟
⋅
Δ
𝑡
σ←σ+∣Δd∣⋅k
r
	​

⋅Δt
Failure Condition

If:

𝜎
>
𝜎
𝑦
σ>σ
y
	​


Then:

Constraint is destroyed

Repulsion briefly spikes to prevent re-binding

Visual “snap” impulse is applied

Failure is local, not catastrophic.

8. Player Interaction Model
Single Verb: Grab Vertex

Player clicks nearest vertex

Vertex position is driven toward cursor

Constraint forces propagate through bindings

Stress accumulates naturally

Outcomes

Pull apart → break bindings

Push together → form bindings

Twist → induce hinge-like motion

No explicit bind/unbind actions exist.

9. Progression & Tech Tree

Progression modifies field parameters only.

9.1 Early Game (Primitive Materials)
Parameter	Value

𝑘
𝑐
k
c
	​

	Low

𝑘
𝑟
k
r
	​

	Low

𝑘
𝑝
k
p
	​

	High

𝑅
𝑐
R
c
	​

	Small

Result:

Floppy

Hard to stabilize

Easy to break

9.2 Mid Game (Structural Engineering)
Parameter	Change

𝑘
𝑐
k
c
	​

	+200%

𝑘
𝑟
k
r
	​

	+150%

𝑘
𝑝
k
p
	​

	−25%

𝑅
𝑐
R
c
	​

	+10%

Result:

Reliable hinges

Stable frames

Vehicles and mechanisms

9.3 Late Game (Field Engineering)

New capabilities:

Directional cohesion

Temporarily amplified repulsion

Stress redistribution

Dynamic rigidity modulation

No new primitives—only stronger control.

10. Networking Model
Determinism

Host simulates all physics

Clients send only:

Grab events

Cursor forces

Sync Data

Per tetrahedron:

Vertex positions

Stress values

Active bindings

No joint state synchronization required.

11. Why This Works

Less code than explicit joints

More expressive behavior

Naturally scalable

Player-discoverable

Network-safe

Tetcraft is not about assembling parts—it is about learning how matter behaves when given rules instead of instructions.

12. Conclusion

By replacing discrete joint logic with field-based cohesion and repulsion, Tetcraft achieves a rare combination:

Physical authenticity, design simplicity, and emergent depth.

Everything the player learns is transferable.
Everything the engine simulates is composable.
Nothing is special-cased.

This is a system that can grow without collapsing under its own complexity.









-------------- v0.5





import pygame
import math
import sys

pygame.init()
WIDTH, HEIGHT = 900, 600
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Tetcraft – Stable Drag Mechanics")
clock = pygame.time.Clock()
font = pygame.font.SysFont("consolas", 16)

# --------------------
# Simulation Constants
# --------------------
EDGE_LEN = 90
COHESION_RADIUS = EDGE_LEN * 0.8
REPULSION_RADIUS = EDGE_LEN * 0.75
BREAK_DISTANCE = COHESION_RADIUS * 1.3

# --- CRITICAL TUNING FOR STABILITY ---
# Physical Properties
RIGIDITY = 0.08
REPULSION_STRENGTH = 0.15
DRAG_STIFFNESS = 0.08           # Reduced further for a softer "spring"
MASS = 1.0
INERTIA = 5000.0                # <<< Massively increased to resist wild spinning

# Normal Damping (when not being dragged)
DAMPING = 0.98
ANGULAR_DAMPING = 0.98

# Aggressive Damping (ONLY applied to the object being dragged)
# This prevents the "integrator wind-up" that causes flinging.
DRAG_DAMPING = 0.85
DRAG_ANGULAR_DAMPING = 0.85
# ------------------------------------

# Colors
BG = (15, 15, 20)
TRI_COLOR = (200, 200, 220)
BOUND_COLOR = (255, 150, 150)
VERT_COLOR = (255, 255, 255)
REPEL_COLOR = (255, 60, 60)
FIELD_COLOR = (80, 80, 120)

# --------------------
# Utility Functions
# --------------------
def dist(a, b):
    return math.hypot(b[0] - a[0], b[1] - a[1])

def normalize(v):
    mag = math.hypot(v[0], v[1])
    if mag == 0: return (0, 0)
    return (v[0] / mag, v[1] / mag)

# --------------------
# Rigid Body Triangle
# --------------------
class Triangle:
    def __init__(self, cx, cy):
        self.pos = [cx, cy]
        self.vel = [0, 0]
        self.angle = 0.0
        self.angular_vel = 0.0
        self.local_verts = [
            (0, -EDGE_LEN * 0.66),
            (-EDGE_LEN * 0.58, EDGE_LEN * 0.33),
            (EDGE_LEN * 0.58, EDGE_LEN * 0.33),
        ]
        self.world_verts = [(0, 0)] * 3
        self.repelling_verts = set()
        self.update_world_verts()

    def update_world_verts(self):
        c, s = math.cos(self.angle), math.sin(self.angle)
        for i, (lx, ly) in enumerate(self.local_verts):
            wx = self.pos[0] + (lx * c - ly * s)
            wy = self.pos[1] + (lx * s + ly * c)
            self.world_verts[i] = [wx, wy]

    def apply_force(self, force, point):
        self.vel[0] += force[0] / MASS
        self.vel[1] += force[1] / MASS
        lever_arm = (point[0] - self.pos[0], point[1] - self.pos[1])
        torque = lever_arm[0] * force[1] - lever_arm[1] * force[0]
        self.angular_vel += torque / INERTIA

    def step(self):
        self.pos[0] += self.vel[0]
        self.pos[1] += self.vel[1]
        self.angle += self.angular_vel

        # Apply normal, gentle damping
        self.vel[0] *= DAMPING
        self.vel[1] *= DAMPING
        self.angular_vel *= ANGULAR_DAMPING

    def draw(self):
        pygame.draw.polygon(screen, TRI_COLOR, self.world_verts, 2)
        for i, v in enumerate(self.world_verts):
            color = REPEL_COLOR if i in self.repelling_verts else VERT_COLOR
            pygame.draw.circle(screen, color, v, 6)
            pygame.draw.circle(screen, FIELD_COLOR, v, int(COHESION_RADIUS), 1)

# --------------------
# Binding Constraint
# --------------------
class Binding:
    def __init__(self, tri1, v1_idx, tri2, v2_idx):
        self.tri1, self.v1_idx = tri1, v1_idx
        self.tri2, self.v2_idx = tri2, v2_idx
        v1 = self.tri1.world_verts[self.v1_idx]
        v2 = self.tri2.world_verts[self.v2_idx]
        self.rest = dist(v1, v2)

    def apply(self):
        v1, v2 = self.tri1.world_verts[self.v1_idx], self.tri2.world_verts[self.v2_idx]
        dx, dy = v2[0] - v1[0], v2[1] - v1[1]
        d = math.hypot(dx, dy)
        if d > BREAK_DISTANCE: return False
        force_mag = (d - self.rest) * RIGIDITY
        nx, ny = normalize((dx, dy))
        force = (nx * force_mag, ny * force_mag)
        self.tri1.apply_force(force, v1)
        self.tri2.apply_force((-force[0], -force[1]), v2)
        return True

    def draw(self):
        v1, v2 = self.tri1.world_verts[self.v1_idx], self.tri2.world_verts[self.v2_idx]
        pygame.draw.line(screen, BOUND_COLOR, v1, v2, 2)

# --------------------
# Setup
# --------------------
triangles = [Triangle(250, 300), Triangle(650, 300)]
bindings = []
dragging = None

# --------------------
# Main Loop
# --------------------
while True:
    clock.tick(60)
    screen.fill(BG)

    # --- Event Handling ---
    for event in pygame.event.get():
        if event.type == pygame.QUIT: pygame.quit(); sys.exit()
        if event.type == pygame.MOUSEBUTTONDOWN:
            mx, my = pygame.mouse.get_pos()
            min_d, closest_v = float('inf'), None
            for t_idx, tri in enumerate(triangles):
                for v_idx, v in enumerate(tri.world_verts):
                    d = dist(v, (mx, my))
                    if d < min_d and d < 20:
                        min_d, closest_v = d, (t_idx, v_idx)
            if closest_v: dragging = (triangles[closest_v[0]], closest_v[1])
        if event.type == pygame.MOUSEBUTTONUP: dragging = None

    # --- Physics Simulation ---

    # 1. Clear per-frame state and update world vertices
    for tri in triangles:
        tri.repelling_verts.clear()
        tri.update_world_verts()

    # 2. Apply forces
    for i in range(len(triangles)):
        for j in range(i + 1, len(triangles)):
            triA, triB = triangles[i], triangles[j]
            for vA_idx, vA in enumerate(triA.world_verts):
                for vB_idx, vB in enumerate(triB.world_verts):
                    d = dist(vA, vB)
                    if d < REPULSION_RADIUS and d > 0:
                        overlap = REPULSION_RADIUS - d
                        nx, ny = normalize((vA[0] - vB[0], vA[1] - vB[1]))
                        force_mag = overlap * REPULSION_STRENGTH
                        force = (nx * force_mag, ny * force_mag)
                        triA.apply_force(force, vA)
                        triB.apply_force((-force[0], -force[1]), vB)
                        triA.repelling_verts.add(vA_idx)
                        triB.repelling_verts.add(vB_idx)
                    if d < COHESION_RADIUS:
                        exists = any((b.tri1 is triA and b.v1_idx is vA_idx and b.tri2 is triB and b.v2_idx is vB_idx) or
                                     (b.tri1 is triB and b.v1_idx is vB_idx and b.tri2 is triA and b.v2_idx is vA_idx)
                                     for b in bindings)
                        if not exists: bindings.append(Binding(triA, vA_idx, triB, vB_idx))

    bindings = [b for b in bindings if b.apply()]

    # Dragging force and critical damping
    if dragging:
        tri, v_idx = dragging
        v = tri.world_verts[v_idx]
        mx, my = pygame.mouse.get_pos()
        force = ((mx - v[0]) * DRAG_STIFFNESS, (my - v[1]) * DRAG_STIFFNESS)
        tri.apply_force(force, v)

        # <<< APPLY AGGRESSIVE DRAG DAMPING HERE >>>
        tri.vel[0] *= DRAG_DAMPING
        tri.vel[1] *= DRAG_DAMPING
        tri.angular_vel *= DRAG_ANGULAR_DAMPING

    # 3. Integrate motion (applies normal damping)
    for tri in triangles:
        tri.step()

    # --- Drawing ---
    for b in bindings: b.draw()
    for tri in triangles: tri.draw()
    label = font.render(f"Bindings: {len(bindings)}", True, (220, 220, 220))
    screen.blit(label, (10, 10))
    pygame.display.flip()







----------- v.08




# Tetcraft - A Networked 3D Physics Sandbox
#
# Command-Line Options:
# To run as a host:
#   python tetra.py
#   python tetra.py -listen 192.168.1.100:50000
# To run as a client and connect to a host:
#   python tetra.py -connect 127.0.0.1:65420

import pygame
import math
import sys
import random
import socket
import pickle
import numpy as np

# --- Initialize Pygame and Mixer ---
pygame.mixer.pre_init(44100, -16, 1, 512)
pygame.init()
WIDTH, HEIGHT = 1600, 900
screen = pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE)
clock = pygame.time.Clock()
font = pygame.font.SysFont("consolas", 16)
void_font = pygame.font.SysFont("consolas", 24)

# --- Sound Generation ---
def generate_sound(frequency=440, duration=0.1, decay=0.9):
    sample_rate = 44100; n_samples = int(sample_rate * duration); t = np.linspace(0, duration, n_samples, False)
    audio = np.sin(frequency * t * 2 * np.pi)
    decay_curve = np.exp(-np.linspace(0, 5, n_samples) * (1 / (decay + 1e-5))); audio *= decay_curve
    audio *= 32767 / np.max(np.abs(audio))
    return pygame.sndarray.make_sound(audio.astype(np.int16))

snap_sound = generate_sound(1200, 0.05, 0.9); pop_sound = generate_sound(200, 0.1, 0.8); thud_sound = generate_sound(100, 0.15, 0.7)
align_sound = generate_sound(400, 0.2, 0.95)

# --- Starfield Generation ---
def create_star_surface(width, height):
    star_surf = pygame.Surface((width, height))
    star_surf.fill(VOID_BG)
    for _ in range(int(width * height / 4000)):
        x = random.randint(0, width - 1); y = random.randint(0, height - 1)
        brightness = random.randint(50, 150); star_surf.set_at((x, y), (brightness, brightness, brightness))
    return star_surf

# --- Raycasting and Particle Classes ---
def ray_intersect_triangle(ro, rd, v0, v1, v2):
    e1, e2 = v1 - v0, v2 - v0
    h = rd.cross(e2)
    a = e1.dot(h)
    if -1e-5 < a < 1e-5: return None
    f = 1.0 / a
    s = ro - v0
    u = f * s.dot(h)
    if u < 0.0 or u > 1.0: return None
    q = s.cross(e1)
    v = f * rd.dot(q)
    if v < 0.0 or u + v > 1.0: return None
    t = f * e2.dot(q)
    return t if t > 1e-5 else None

class Particle:
    def __init__(self, pos, vel, color, lifespan=1.0):
        self.pos, self.vel, self.color, self.lifespan, self.initial_lifespan = pos, vel, color, lifespan, lifespan
    def update(self, time_multiplier):
        self.pos += self.vel * time_multiplier; self.vel *= 0.98
        self.lifespan -= 0.02 * time_multiplier
    def draw(self, camera):
        p_screen, depth = camera.project(self.pos)
        if p_screen and self.lifespan > 0:
            fade = self.lifespan / self.initial_lifespan; radius = int(3 * fade)
            if radius > 0:
                final_color = tuple(int(c * fade) for c in self.color)
                pygame.draw.circle(screen, final_color, p_screen, radius)

# --------------------
# 3D Math Library & Main Classes
# --------------------
class Vec3:
    def __init__(self, x=0, y=0, z=0): self.x, self.y, self.z = x, y, z
    def __add__(self, o): return Vec3(self.x + o.x, self.y + o.y, self.z + o.z)
    def __sub__(self, o): return Vec3(self.x - o.x, self.y - o.y, self.z - o.z)
    def __mul__(self, s): return Vec3(self.x * s, self.y * s, self.z * s)
    def __truediv__(self, s): return Vec3(self.x / s, self.y / s, self.z / s)
    def length_sq(self): return self.x**2 + self.y**2 + self.z**2
    def length(self): return math.sqrt(self.length_sq())
    def normalize(self): l = self.length(); return self if l == 0 else self / l
    def cross(self, o): return Vec3(self.y*o.z-self.z*o.y, self.z*o.x-self.x*o.z, self.x*o.y-self.y*o.x)
    def dot(self, o): return self.x*o.x + self.y*o.y + self.z*o.z

class Quaternion:
    def __init__(self, w=1, x=0, y=0, z=0): self.w, self.x, self.y, self.z = w, x, y, z
    def __mul__(self, o): w1,x1,y1,z1=self.w,self.x,self.y,self.z; w2,x2,y2,z2=o.w,o.x,o.y,o.z; return Quaternion(w1*w2-x1*x2-y1*y2-z1*z2, w1*x2+x1*w2+y1*z2-z1*y2, w1*y2-x1*z2+y1*w2+z1*x2, w1*z2+x1*y2-y1*x2+z1*w2)
    def conjugate(self): return Quaternion(self.w, -self.x, -self.y, -self.z)
    def rotate(self, v): q_vec=Quaternion(0,v.x,v.y,v.z); r=self*q_vec*self.conjugate(); return Vec3(r.x,r.y,r.z)
    def normalize(self): mag=math.sqrt(self.w**2+self.x**2+self.y**2+self.z**2); self.w/=mag;self.x/=mag;self.y/=mag;self.z/=mag; return self

class Camera:
    def __init__(self, target=None, distance=400, yaw=0, pitch=0):
        self.target=target if target is not None else Vec3(); self.distance,self.yaw,self.pitch=distance,yaw,pitch
        self.focal_length,self.pos=400,Vec3(); self.min_dist,self.max_dist=150,2000; self.view_matrix=[]
        self.right,self.up,self.forward=Vec3(),Vec3(),Vec3()
    def update(self, zoom_input, mouse_rel):
        keys=pygame.key.get_pressed(); orbit_speed_key=0.02
        if mouse_rel: self.yaw+=mouse_rel[0]*MOUSE_ORBIT_SENSITIVITY; self.pitch-=mouse_rel[1]*MOUSE_ORBIT_SENSITIVITY
        if keys[pygame.K_a]: self.yaw-=orbit_speed_key
        if keys[pygame.K_d]: self.yaw+=orbit_speed_key
        if keys[pygame.K_w]: self.pitch+=orbit_speed_key
        if keys[pygame.K_s]: self.pitch-=orbit_speed_key
        pan_speed=4.0; forward_dir_pan=Vec3(math.sin(self.yaw),0,-math.cos(self.yaw)).normalize()
        right_dir_pan=Vec3(0,1,0).cross(forward_dir_pan).normalize()
        if keys[pygame.K_q]: self.target+=right_dir_pan*pan_speed
        if keys[pygame.K_e]: self.target-=right_dir_pan*pan_speed
        zoom_speed=1.05
        if zoom_input>0 or keys[pygame.K_r]: self.distance/=zoom_speed
        if zoom_input<0 or keys[pygame.K_f]: self.distance*=zoom_speed
        self.distance=max(self.min_dist,min(self.max_dist,self.distance))
        offset_from_target=Vec3(self.distance*math.cos(self.pitch)*math.sin(self.yaw),self.distance*math.sin(self.pitch),self.distance*math.cos(self.pitch)*-math.cos(self.yaw))
        self.pos=self.target+offset_from_target;
        self.forward=(self.target-self.pos).normalize()
        world_up = Vec3(0, 1, 0) if math.cos(self.pitch) >= 0 else Vec3(0, -1, 0)
        self.right=world_up.cross(self.forward).normalize()
        if self.right.length()<0.1: self.right = Vec3(-math.cos(self.yaw), 0, -math.sin(self.yaw))
        self.up=self.forward.cross(self.right)
        self.view_matrix=[[self.right.x,self.up.x,self.forward.x,0],[self.right.y,self.up.y,self.forward.y,0],[self.right.z,self.up.z,self.forward.z,0],[-self.right.dot(self.pos),-self.up.dot(self.pos),-self.forward.dot(self.pos),1]]
    def project(self, p_3d):
        px=p_3d.x*self.view_matrix[0][0]+p_3d.y*self.view_matrix[1][0]+p_3d.z*self.view_matrix[2][0]+self.view_matrix[3][0];py=p_3d.x*self.view_matrix[0][1]+p_3d.y*self.view_matrix[1][1]+p_3d.z*self.view_matrix[2][1]+self.view_matrix[3][1];pz=p_3d.x*self.view_matrix[0][2]+p_3d.y*self.view_matrix[1][2]+p_3d.z*self.view_matrix[2][2]+self.view_matrix[3][2]
        if not math.isfinite(px) or not math.isfinite(py) or pz <= 0: return None, None
        scale=self.focal_length/pz; sx=WIDTH/2+px*scale; sy=HEIGHT/2-py*scale; return (int(sx),int(sy)),pz
    def unproject(self, screen_x, screen_y, depth):
        ndc_x=(screen_x-WIDTH/2)/(WIDTH/2); ndc_y=-(screen_y-HEIGHT/2)/(HEIGHT/2)
        view_x=ndc_x*depth*(WIDTH/2)/self.focal_length; view_y=ndc_y*depth*(HEIGHT/2)/self.focal_length
        return self.pos+self.right*view_x+self.up*view_y+self.forward*depth

class Vertex:
    def __init__(self): self.is_face_repulsor=False; self.is_repulsive=False

class Tetrahedron:
    def __init__(self, pos):
        self.pos,self.vel,self.orientation,self.angular_vel=pos,Vec3(),Quaternion(),Vec3()
        self.energy = 0.0; s=EDGE_LEN*0.8
        self.local_verts=[Vec3(1,1,1).normalize()*s,Vec3(1,-1,-1).normalize()*s,Vec3(-1,1,-1).normalize()*s,Vec3(-1,-1,1).normalize()*s]
        self.world_verts=[Vec3()]*4; self.vertex_properties=[Vertex() for _ in range(4)]; self.vertex_bind_counts=[0]*4
        self.faces=[(0,1,2),(0,3,1),(0,2,3),(1,3,2)]; self.face_colors=[(255,0,0),(255,255,255),(0,0,0),(0,255,255)]
        v0,v1,v2,v3 = self.local_verts[0], self.local_verts[1], self.local_verts[2], self.local_verts[3]
        self.local_white_normal = (v3 - v0).cross(v1 - v0).normalize()
        self.local_black_normal = (v2 - v0).cross(v3 - v0).normalize()
        self.update_world_verts()
    def update_world_verts(self): [self.world_verts.__setitem__(i, self.pos+self.orientation.rotate(lv)) for i,lv in enumerate(self.local_verts)]
    def apply_force(self, force, point, time_multiplier): self.vel+=(force/MASS)*time_multiplier; self.angular_vel+=((point-self.pos).cross(force)/INERTIA)*time_multiplier
    def apply_torque(self, torque, time_multiplier): self.angular_vel += (torque / INERTIA) * time_multiplier
    def step(self, time_multiplier):
        self.pos+=self.vel*time_multiplier
        if not (math.isfinite(self.pos.x) and math.isfinite(self.pos.y) and math.isfinite(self.pos.z)):
            print("Simulation instability detected! Resetting tetrahedron.")
            self.pos = world_origin + Vec3(random.uniform(-EDGE_LEN,EDGE_LEN),random.uniform(-EDGE_LEN,EDGE_LEN),random.uniform(-EDGE_LEN,EDGE_LEN))
            self.vel = Vec3(); self.angular_vel = Vec3()
            return
        angle=self.angular_vel.length()*time_multiplier
        if angle>0:
            axis=self.angular_vel.normalize(); w=math.cos(angle*0.5); s=math.sin(angle*0.5)
            self.orientation=(Quaternion(w,axis.x*s,axis.y*s,axis.z*s)*self.orientation).normalize()
        self.vel*=DAMPING; self.angular_vel*=ANGULAR_DAMPING
    def get_render_data(self):
        projected_verts={i:camera.project(v) for i,v in enumerate(self.world_verts)}; faces_data=[]
        for i,face_indices in enumerate(self.faces):
            v0,v1,v2=(self.world_verts[i] for i in face_indices); normal=(v1-v0).cross(v2-v0)
            if normal.dot(camera.pos-v0)>0:
                p0_tuple,z0=projected_verts.get(face_indices[0], (None, None));p1_tuple,z1=projected_verts.get(face_indices[1], (None, None));p2_tuple,z2=projected_verts.get(face_indices[2], (None, None))
                if p0_tuple and p1_tuple and p2_tuple: faces_data.append(((p0_tuple,p1_tuple,p2_tuple),normal.normalize(),self.face_colors[i],(z0+z1+z2)/3))
        return faces_data, projected_verts

class Binding:
    def __init__(self, t1, v1_idx, t2, v2_idx):
        self.t1, self.v1_idx, self.t2, self.v2_idx = t1, v1_idx, t2, v2_idx
        self.rest = 0.0
    def apply(self, time_multiplier, tetra_dragged=None):
        v1, v2 = self.t1.world_verts[self.v1_idx], self.t2.world_verts[self.v2_idx]
        delta, d = v2-v1, (v2-v1).length()
        if d > 0:
            force = delta.normalize() * (d-self.rest) * RIGIDITY
            self.t1.apply_force(force, v1, time_multiplier); self.t2.apply_force(force*-1, v2, time_multiplier)
        is_part_of_drag = (self.t1 is tetra_dragged or self.t2 is tetra_dragged)
        if not is_part_of_drag:
            ref_idx_t1 = (self.v1_idx + 1) % 4; ref_idx_t2 = (self.v2_idx + 1) % 4
            vec1 = (self.t1.world_verts[ref_idx_t1] - v1).normalize()
            vec2 = (self.t2.world_verts[ref_idx_t2] - v2).normalize()
            torque_axis = vec1.cross(vec2); misalignment = 1.0 - vec1.dot(vec2)
            if torque_axis.length_sq() > 0:
                torque_vec = torque_axis.normalize() * misalignment * BOND_STABILITY_STRENGTH
                self.t1.apply_torque(torque_vec, time_multiplier); self.t2.apply_torque(torque_vec * -1, time_multiplier)
        return True
    def draw(self): p1,_=camera.project(self.t1.world_verts[self.v1_idx]);p2,_=camera.project(self.t2.world_verts[self.v2_idx]);p1 and p2 and pygame.draw.line(screen,BOUND_COLOR,p1,p2,2)

# --------------------
# Simulation Constants & Global Setup
# --------------------
EDGE_LEN=50; FULL_VERTEX_REPULSION=0.1; CREATE_BIND_DIST=EDGE_LEN*0.1
RIGIDITY, DRAG_STIFFNESS=0.3, 0.15; MASS=1.0; INERTIA=20000.0; DAMPING, ANGULAR_DAMPING=0.98, 0.98
DRAG_DAMPING, DRAG_ANGULAR_DAMPING=0.8, 0.8; MOUSE_ORBIT_SENSITIVITY=0.005
COLLISION_DISTANCE=EDGE_LEN*0.9; COLLISION_REPULSION_STRENGTH=1.0; HOST='127.0.0.1'; PORT=65420
NEW_BIND_DAMPING = 0.5; SHORT_RANGE_ATTRACTION_RANGE = EDGE_LEN * 0.75; SHORT_RANGE_ATTRACTION_STRENGTH = 0.05
PERFORMANCE_THROTTLE_FPS = 45.0; BOND_STABILITY_STRENGTH = 50.0; BASE_ORIGIN_ORIENT_STRENGTH = 3.0
ORIGIN_SINGULARITY_RADIUS = EDGE_LEN * 2.0; ORIGIN_SPIN_TORQUE = 20.0
ENERGY_CHARGE_RADIUS = EDGE_LEN * 4; ENERGY_CHARGE_RATE = 0.0001; ENERGY_DECAY_RATE = 0.0002
VELOCITY_DECAY_FACTOR = 0.0001; HIGH_ENERGY_REPULSION_STRENGTH = 0.02; ZIPPER_ATTRACTION_STRENGTH = 0.1
SUB_STEPS = 8 # NEW: For high-speed stability
VOID_BG=(15,15,20); LIGHT_BG=(255,255,255); VERT_COLOR, BOUND_COLOR=(255,255,255),(255,150,150)
FROZEN_COLOR=(100,100,255); LIGHT_DIR=Vec3(0.5,-1,-0.5).normalize(); AMBIENT_LIGHT, DIFFUSE_LIGHT=0.4, 0.6
CALC_INDICATOR_POS=(WIDTH-20,10); CALC_INDICATOR_SIZE=(10,10)

# --- Game Functions ---
def draw_gizmo(origin):
    size = EDGE_LEN * 2
    o,x,y,z=origin,origin+Vec3(size,0,0),origin+Vec3(0,size,0),origin+Vec3(0,0,size)
    po,_=camera.project(o);px,_=camera.project(x);py,_=camera.project(y);pz,_=camera.project(z)
    if po and px: pygame.draw.line(screen,(255,0,0),po,px,3)
    if po and py: pygame.draw.line(screen,(255,255,255),po,py,3)
    if po and pz: pygame.draw.line(screen,(0,255,255),po,pz,3)

def generate_cluster_universe():
    print("Generating cluster of 8 tetrahedrons...")
    tets, binds = [], []
    GRID_X,GRID_Y,GRID_Z=2,2,2; SPACING=EDGE_LEN*1.8; JITTER=EDGE_LEN*0.5
    offset=Vec3((GRID_X-1)*SPACING/2,(GRID_Y-1)*SPACING/2,(GRID_Z-1)*SPACING/2)
    for x in range(GRID_X):
        for y in range(GRID_Y):
            for z in range(GRID_Z):
                pos = world_origin + Vec3(x*SPACING,y*SPACING,z*SPACING)-offset+Vec3(random.uniform(-JITTER,JITTER),random.uniform(-JITTER,JITTER),random.uniform(-JITTER,JITTER))
                tets.append(Tetrahedron(pos))
    return tets, binds

def add_tetrahedron():
    global show_time_message_until, show_light_message_until, show_darkness_message_until, current_bg, star_field_surface, void_entry_time
    if len(tetrahedrons) == 0: show_time_message_until = pygame.time.get_ticks() + 10000
    if len(tetrahedrons) == 1: show_light_message_until = pygame.time.get_ticks() + 10000; current_bg = LIGHT_BG
    if len(tetrahedrons) == 2: show_darkness_message_until = pygame.time.get_ticks() + 10000; star_field_surface = create_star_surface(WIDTH*2, HEIGHT); current_bg = star_field_surface; void_entry_time = 0
    pos = world_origin + Vec3(random.uniform(-EDGE_LEN,EDGE_LEN),random.uniform(-EDGE_LEN,EDGE_LEN),random.uniform(-EDGE_LEN,EDGE_LEN))
    new_tet = Tetrahedron(pos); new_tet.vel = Vec3(random.uniform(-5,5),random.uniform(-5,5),random.uniform(-5,5)); new_tet.angular_vel = Vec3(random.uniform(-0.1,0.1),random.uniform(-0.1,0.1),random.uniform(-0.1,0.1))
    tetrahedrons.append(new_tet); snap_sound.play()

def start_host_mode():
    global MODE, server_socket, client_socket, clients, tetrahedrons, bindings, particles, dragging, world_origin, void_entry_time, current_bg, PORT, HOST
    MODE = 'host';
    if client_socket: client_socket.close(); client_socket = None
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    max_attempts = 100
    temp_host, temp_port = (sys.argv[sys.argv.index('-listen')+1].split(':') if '-listen' in sys.argv else (HOST, PORT))
    temp_port = int(temp_port)
    for attempt in range(max_attempts):
        try:
            server_socket.bind((temp_host, temp_port))
            HOST, PORT = temp_host, temp_port
            caption = f"Tetcraft – Networked Sandbox (Host on {HOST}:{PORT})"
            if attempt > 0: print(f"Successfully bound to new port: {HOST}:{PORT}")
            else: print(f"Hosting on default port: {HOST}:{PORT}")
            pygame.display.set_caption(caption)
            break
        except OSError:
            if attempt == 0: print(f"Default port {temp_port} is in use. Searching...")
            temp_port = random.randint(49152, 65535)
    else:
        print(f"Could not find available port. Exiting."); pygame.quit(); sys.exit()
    server_socket.setblocking(False); server_socket.listen(5); clients = []
    tetrahedrons, bindings, particles, dragging = [], [], [], None; world_origin = Vec3()
    void_entry_time = pygame.time.get_ticks(); current_bg = VOID_BG
    try_load_universe()

def start_client_mode():
    global MODE, server_socket, client_socket, clients, tetrahedrons, bindings, current_bg, particles, HOST, PORT
    MODE = 'client'; pygame.display.set_caption(f"Tetcraft – Networked Sandbox (Client)")
    if server_socket: [c.close() for c in clients]; server_socket.close(); server_socket = None
    clients = []; old_tets, old_binds = tetrahedrons, bindings
    tetrahedrons, bindings, particles = [], [], []; current_bg = VOID_BG
    if '-connect' not in sys.argv: HOST, PORT = '127.0.0.1', 65420
    try:
        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM); client_socket.connect((HOST, PORT)); client_socket.setblocking(False)
        print(f"Switched to CLIENT mode, connected to {HOST}:{PORT}")
    except (ConnectionRefusedError, TimeoutError, socket.error):
        print("Connection failed. No host found. Switching back to host mode."); start_host_mode(); tetrahedrons, bindings = old_tets, old_binds

def save_universe():
    try:
        tetra_states = [(t.pos, t.orientation, [v.is_repulsive for v in t.vertex_properties]) for t in tetrahedrons]
        binding_states = [(tetrahedrons.index(b.t1), b.v1_idx, tetrahedrons.index(b.t2), b.v2_idx) for b in bindings]
        data = (tetra_states, binding_states, world_origin);
        with open('universe.sav', 'wb') as f: pickle.dump(data, f)
        print("Universe saved.")
    except Exception as e: print(f"Error saving universe: {e}")

def try_load_universe():
    global tetrahedrons, bindings, world_origin
    try:
        with open('universe.sav', 'rb') as f:
            tetra_states, binding_states, saved_origin = pickle.load(f)
            tetrahedrons = []
            for pos, orientation, repulsive_states in tetra_states:
                t = Tetrahedron(pos); t.orientation = orientation
                for i, active in enumerate(repulsive_states): t.vertex_properties[i].is_repulsive = active
                tetrahedrons.append(t)
            bindings = []
            for t1_idx, v1_idx, t2_idx, v2_idx in binding_states:
                if t1_idx < len(tetrahedrons) and t2_idx < len(tetrahedrons):
                    bindings.append(Binding(tetrahedrons[t1_idx], v1_idx, tetrahedrons[t2_idx], v2_idx))
            world_origin = saved_origin; print("Universe loaded from save file.")
    except (FileNotFoundError, EOFError): print("No save file found, starting new universe.")
    except Exception as e: print(f"Error loading universe: {e}")

# --- CLI Parsing & Initial Setup ---
INITIAL_MODE = 'host'
if '-connect' in sys.argv:
    INITIAL_MODE = 'client'
    try:
        connect_idx = sys.argv.index('-connect') + 1
        address = sys.argv[connect_idx]
        HOST, PORT = address.split(':')
        PORT = int(PORT)
        print(f"Attempting to connect to {HOST}:{PORT}")
    except (ValueError, IndexError):
        print(f"Invalid -connect format. Use HOST:PORT. Defaulting to 127.0.0.1:65420"); HOST, PORT = '127.0.0.1', 65420
elif '-listen' in sys.argv:
    try:
        listen_idx = sys.argv.index('-listen') + 1
        address = sys.argv[listen_idx]
        HOST, PORT = address.split(':')
        PORT = int(PORT)
        print(f"Custom host/port provided: {HOST}:{PORT}")
    except (ValueError, IndexError):
        print(f"Invalid -listen format. Use HOST:PORT. Defaulting to 127.0.0.1:65420"); HOST, PORT = '127.0.0.1', 65420

MODE, server_socket, client_socket, clients = '', None, None, []
tetrahedrons, bindings, particles, dragging = [], [], [], None; world_origin = Vec3()
current_bg, star_field_surface = VOID_BG, None
camera=Camera(target=world_origin, distance=800)
intro_start_time = pygame.time.get_ticks()

if INITIAL_MODE == 'host': start_host_mode()
else: start_client_mode()

orbiting_with_mouse=False; time_multiplier=1.0; restarting_universe=False; restart_timer=0; void_entry_time=pygame.time.get_ticks()
show_time_message_until, show_light_message_until, show_darkness_message_until = 0, 0, 0
last_click_time = 0
while True:
    if pygame.time.get_ticks() - intro_start_time < 10000:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            if event.type == pygame.VIDEORESIZE: WIDTH, HEIGHT = event.w, event.h; screen = pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE)
        screen.fill(VOID_BG)
        font_size = int(HEIGHT / 2)
        while True:
            title_font = pygame.font.SysFont("consolas", font_size, bold=True)
            if title_font.size("TETCRAFT")[0] < WIDTH * 0.9: break
            font_size -= 5
        subtitle_font = pygame.font.SysFont("consolas", int(font_size/3), bold=True)
        title_surf = title_font.render("TETCRAFT", True, (255,255,255)); title_rect = title_surf.get_rect(center=(WIDTH/2, HEIGHT/2 - title_surf.get_height()/2))
        subtitle_surf = subtitle_font.render("Your own universe!", True, (200,200,200)); subtitle_rect = subtitle_surf.get_rect(center=(WIDTH/2, HEIGHT/2 + subtitle_surf.get_height()))
        screen.blit(title_surf, title_rect); screen.blit(subtitle_surf, subtitle_rect)
        pygame.display.flip(); clock.tick(60); continue

    fps = clock.get_fps()
    if fps > 0 and fps < PERFORMANCE_THROTTLE_FPS and time_multiplier > 1.0: time_multiplier = max(1.0, time_multiplier * 0.95)

    clock.tick(60); zoom_input=0; mouse_rel=(0,0)
    current_time = pygame.time.get_ticks()
    for event in pygame.event.get():
        if event.type==pygame.QUIT: pygame.quit();sys.exit()
        if event.type==pygame.MOUSEWHEEL: zoom_input=event.y
        if event.type == pygame.VIDEORESIZE:
            WIDTH, HEIGHT = event.w, event.h; screen = pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE)
            CALC_INDICATOR_POS = (WIDTH - 20, 10)
            if current_bg is star_field_surface: star_field_surface = create_star_surface(WIDTH, HEIGHT); current_bg = star_field_surface
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_TAB:
                if MODE == 'host': start_client_mode()
                else: start_host_mode()
            if event.key == pygame.K_v and MODE == 'host': save_universe()
            if event.key == pygame.K_x and MODE == 'host' and tetrahedrons:
                world_origin = sum([t.pos for t in tetrahedrons], Vec3()) / len(tetrahedrons); camera.target = world_origin; print(f"World origin recentered.")
            if MODE == 'host':
                if event.key == pygame.K_SPACE: add_tetrahedron()
                if event.key == pygame.K_BACKQUOTE and tetrahedrons: restarting_universe = True; restart_timer = pygame.time.get_ticks()
        if MODE == 'host':
            if event.type==pygame.MOUSEBUTTONDOWN:
                if event.button == 1:
                    if not dragging: orbiting_with_mouse=True; pygame.mouse.set_visible(False); pygame.event.set_grab(True)
                elif event.button == 3:
                    last_click_time = current_time; mx,my=pygame.mouse.get_pos(); min_dist_sq=float('inf'); closest_v_info=None
                    for t_idx,tetra in enumerate(tetrahedrons):
                        for v_idx,v_world in enumerate(tetra.world_verts):
                            p_screen, depth = camera.project(v_world)
                            if p_screen and (p_screen[0]-mx)**2+(p_screen[1]-my)**2 < min_dist_sq:
                                min_dist_sq=(p_screen[0]-mx)**2+(p_screen[1]-my)**2; closest_v_info=(t_idx,v_idx,depth,v_world)
                    if closest_v_info and min_dist_sq<50**2:
                        t_idx,v_idx,depth,v_world=closest_v_info; dragging=(tetrahedrons[t_idx],v_idx,depth,pygame.mouse.get_pos(),v_world)
            if event.type==pygame.MOUSEBUTTONUP:
                if event.button == 1: orbiting_with_mouse=False; pygame.mouse.set_visible(True); pygame.event.set_grab(False)
                elif event.button == 3:
                    if dragging: dragging = None
                    elif current_time - last_click_time < 200:
                        mx,my=pygame.mouse.get_pos(); min_dist_sq=float('inf'); closest_v_info=None
                        for t_idx,tetra in enumerate(tetrahedrons):
                            for v_idx,v_world in enumerate(tetra.world_verts):
                                p_screen, _ = camera.project(v_world)
                                if p_screen and (p_screen[0]-mx)**2+(p_screen[1]-my)**2 < 50**2:
                                    dist_sq=(p_screen[0]-mx)**2+(p_screen[1]-my)**2
                                    if dist_sq < min_dist_sq: min_dist_sq=dist_sq; closest_v_info=(t_idx,v_idx)
                        if closest_v_info:
                            t_idx,v_idx=closest_v_info; clicked_tetra = tetrahedrons[t_idx]
                            if clicked_tetra.vertex_bind_counts[v_idx] > 0:
                                bonds = [b for b in bindings if not ((b.t1 is clicked_tetra and b.v1_idx == v_idx) or (b.t2 is clicked_tetra and b.v2_idx == v_idx))]
                                if len(bindings) > len(bonds): pop_sound.play()
                                bindings = bonds
                            else:
                                prop = clicked_tetra.vertex_properties[v_idx]; prop.is_repulsive = not prop.is_repulsive; print(f"Vertex Repulsion: {'ON' if prop.is_repulsive else 'OFF'}")

    keys = pygame.key.get_pressed()
    if keys[pygame.K_c]: time_multiplier = min(10.0, time_multiplier + 0.1)
    if keys[pygame.K_z]: time_multiplier = max(0.1, time_multiplier - 0.1)
    if orbiting_with_mouse: mouse_rel = pygame.mouse.get_rel()
    camera.update(zoom_input, mouse_rel)

    if MODE == 'host':
        is_hovering_vertex = False
        if not orbiting_with_mouse and not dragging:
            mx,my=pygame.mouse.get_pos()
            for tetra in tetrahedrons:
                for v_world in tetra.world_verts:
                    p_screen, _ = camera.project(v_world)
                    if p_screen and (p_screen[0]-mx)**2+(p_screen[1]-my)**2 < 50**2: is_hovering_vertex=True; break
                if is_hovering_vertex: break
        if is_hovering_vertex: pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_HAND)
        else: pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_ARROW)

    pygame.draw.rect(screen, (255,255,0), (CALC_INDICATOR_POS, CALC_INDICATOR_SIZE))
    pygame.display.update(pygame.Rect(CALC_INDICATOR_POS, CALC_INDICATOR_SIZE))

    if MODE == 'host':
        if restarting_universe:
            if pygame.time.get_ticks() - restart_timer > 100:
                if tetrahedrons:
                    t_to_remove = tetrahedrons.pop(random.randrange(len(tetrahedrons)))
                    bindings = [b for b in bindings if b.t1 is not t_to_remove and b.t2 is not t_to_remove]
                    for _ in range(30): particles.append(Particle(t_to_remove.pos, Vec3(random.uniform(-1,1), random.uniform(-1,1), random.uniform(-1,1)).normalize() * random.uniform(5, 15), random.choice(t_to_remove.face_colors), lifespan=random.uniform(0.5, 1.5)))
                    pop_sound.play(); restart_timer = pygame.time.get_ticks()
                else: restarting_universe = False; particles = []; tetrahedrons, bindings = generate_cluster_universe()
        else:
            sub_step_multiplier = time_multiplier / SUB_STEPS
            for _ in range(SUB_STEPS):
                try:
                    for t in tetrahedrons: t.vertex_bind_counts = [0]*4
                    for b in bindings: b.t1.vertex_bind_counts[b.v1_idx]+=1; b.t2.vertex_bind_counts[b.v2_idx]+=1

                    new_bindings = []
                    if dragging:
                        tetra_drag, v_idx_drag, _, _, _ = dragging; v_dragged = tetra_drag.world_verts[v_idx_drag]
                        num_bound_verts_drag = sum(1 for c in tetra_drag.vertex_bind_counts if c > 0)
                        for t_target in tetrahedrons:
                            if t_target is tetra_drag: continue
                            num_bound_verts_target = sum(1 for c in t_target.vertex_bind_counts if c > 0)
                            for v_idx_target, v_target in enumerate(t_target.world_verts):
                                can_bind_drag = num_bound_verts_drag < 3 or tetra_drag.vertex_bind_counts[v_idx_drag] > 0
                                can_bind_target = num_bound_verts_target < 3 or t_target.vertex_bind_counts[v_idx_target] > 0
                                if can_bind_drag and can_bind_target and (v_dragged - v_target).length_sq() < CREATE_BIND_DIST**2:
                                    is_already_bound = any(b for b in bindings if (b.t1,b.v1_idx,b.t2,b.v2_idx) in [(tetra_drag,v_idx_drag,t_target,v_idx_target),(t_target,v_idx_target,tetra_drag,v_idx_drag)])
                                    if not is_already_bound: new_bindings.append(Binding(tetra_drag, v_idx_drag, t_target, v_idx_target)); dragging = None; break
                            if not dragging: break

                    for t in tetrahedrons:
                        dist_from_origin = (t.pos - world_origin).length()
                        if not math.isfinite(dist_from_origin): continue
                        if dist_from_origin < ENERGY_CHARGE_RADIUS: t.energy = min(1.0, t.energy + ENERGY_CHARGE_RATE * sub_step_multiplier)
                        else:
                            radial_velocity = t.vel.dot((t.pos - world_origin).normalize()) if dist_from_origin > 0 else 0; outward_speed = max(0, radial_velocity)
                            dynamic_decay_rate = ENERGY_DECAY_RATE + (outward_speed * VELOCITY_DECAY_FACTOR)
                            t.energy = max(0.0, t.energy - dynamic_decay_rate * sub_step_multiplier)
                        if t.energy > 0.5: t.apply_force((t.pos - world_origin).normalize() * HIGH_ENERGY_REPULSION_STRENGTH * t.energy, t.pos, sub_step_multiplier)
                        else: t.apply_force((world_origin - t.pos).normalize() * 0.01 * (1.0 - t.energy), t.pos, sub_step_multiplier)

                    for t in tetrahedrons: t.update_world_verts()

                    visited = set()
                    for t_start in tetrahedrons:
                        if t_start in visited: continue
                        structure = set(); q = [t_start]; visited.add(t_start); structure.add(t_start); head = 0
                        while head < len(q):
                            current_t = q[head]; head += 1
                            for b in bindings:
                                neighbor = None
                                if b.t1 is current_t: neighbor = b.t2
                                elif b.t2 is current_t: neighbor = b.t1
                                if neighbor and neighbor not in visited: visited.add(neighbor); structure.add(neighbor); q.append(neighbor)
                        if not structure: continue
                        center_of_mass = sum([t.pos for t in structure], Vec3()) / len(structure); avg_energy = sum(t.energy for t in structure) / len(structure); dist_sq = (center_of_mass - world_origin).length_sq()
                        if dist_sq < ORIGIN_SINGULARITY_RADIUS**2 and avg_energy < 0.1:
                            for t in structure: t.apply_torque(Vec3(0.1, 1, 0.1).normalize() * ORIGIN_SPIN_TORQUE, sub_step_multiplier)
                        elif len(structure) == 1:
                            t = list(structure)[0]
                            target_dir_origin = (world_origin - t.pos).normalize()
                            if target_dir_origin.length_sq() > 0:
                                torque1 = t.orientation.rotate(t.local_black_normal).cross(target_dir_origin) * BASE_ORIGIN_ORIENT_STRENGTH
                                torque2 = t.orientation.rotate(t.local_white_normal).cross(Vec3(0,1,0)) * (BASE_ORIGIN_ORIENT_STRENGTH * 0.5)
                                t.apply_torque(torque1 + torque2, sub_step_multiplier)

                    for t in tetrahedrons:
                        for prop in t.vertex_properties: prop.is_face_repulsor=False
                        if sum(1 for c in t.vertex_bind_counts if c > 0) == 3:
                            for i, count in enumerate(t.vertex_bind_counts):
                                if count == 0: t.vertex_properties[i].is_face_repulsor = True

                    for i in range(len(tetrahedrons)):
                        for j in range(i + 1, len(tetrahedrons)):
                            tA, tB = tetrahedrons[i], tetrahedrons[j]; bonds_between = [b for b in bindings if (b.t1 is tA and b.t2 is tB) or (b.t1 is tB and b.t2 is tA)]
                            if not bonds_between:
                                delta_pos = tA.pos - tB.pos; dist_pos = delta_pos.length()
                                if 0 < dist_pos < COLLISION_DISTANCE: penetration = COLLISION_DISTANCE-dist_pos; repulsion_force = delta_pos.normalize()*penetration**2*COLLISION_REPULSION_STRENGTH; tA.apply_force(repulsion_force, tA.pos, sub_step_multiplier); tB.apply_force(repulsion_force*-1, tB.pos, sub_step_multiplier)
                            if 0 < len(bonds_between) < 4:
                                vA_bound_indices = {b.v1_idx for b in bonds_between if b.t1 is tA} | {b.v2_idx for b in bonds_between if b.t2 is tA}; vB_bound_indices = {b.v1_idx for b in bonds_between if b.t1 is tB} | {b.v2_idx for b in bonds_between if b.t2 is tB}; unbonded_pairs = []; [ unbonded_pairs.append((vA_idx, vB_idx)) for vA_idx in range(4) if vA_idx not in vA_bound_indices for vB_idx in range(4) if vB_idx not in vB_bound_indices ]
                                if unbonded_pairs:
                                    closest_pair = min(unbonded_pairs, key=lambda p: (tA.world_verts[p[0]] - tB.world_verts[p[1]]).length_sq())
                                    vA = tA.world_verts[closest_pair[0]]; vB = tB.world_verts[closest_pair[1]]; delta = vB - vA; d = delta.length()
                                    if d > 0: attraction_mod = (1.0 - tA.energy) * (1.0 - tB.energy); force = delta.normalize() * ZIPPER_ATTRACTION_STRENGTH * attraction_mod; tA.apply_force(force, vA, sub_step_multiplier); tB.apply_force(force*-1, vB, sub_step_multiplier)
                            for vA_idx, vA_props in enumerate(tA.vertex_properties):
                                if tA.vertex_bind_counts[vA_idx] > 0: continue
                                for vB_idx, vB_props in enumerate(tB.vertex_properties):
                                    if tB.vertex_bind_counts[vB_idx] > 0: continue
                                    vA,vB=tA.world_verts[vA_idx],tB.world_verts[vB_idx]; delta=vB-vA; d=delta.length()
                                    if 0 < d < SHORT_RANGE_ATTRACTION_RANGE:
                                        if vA_props.is_face_repulsor and vB_props.is_face_repulsor: force = delta.normalize() * -FULL_VERTEX_REPULSION; tA.apply_force(force,vA,sub_step_multiplier); tB.apply_force(force*-1,vB,sub_step_multiplier)
                                        elif not vA_props.is_repulsive and not vB_props.is_repulsive: attraction_mod = (1.0 - tA.energy) * (1.0 - tB.energy); force_magnitude = (1.0 - (d / SHORT_RANGE_ATTRACTION_RANGE)) * SHORT_RANGE_ATTRACTION_STRENGTH * attraction_mod; force = delta.normalize() * force_magnitude; tA.apply_force(force, vA, sub_step_multiplier); tB.apply_force(force * -1, vB, sub_step_multiplier)

                    if new_bindings:
                        snap_sound.play()
                        for b in new_bindings: b.t1.vel *= NEW_BIND_DAMPING; b.t1.angular_vel *= NEW_BIND_DAMPING; b.t2.vel *= NEW_BIND_DAMPING; b.t2.angular_vel *= NEW_BIND_DAMPING
                        bindings.extend(new_bindings)
                    tetra_being_dragged = dragging[0] if dragging else None
                    for b in bindings: b.apply(sub_step_multiplier, tetra_being_dragged)

                    frozen_tets = set()
                    if dragging:
                        mx,my = pygame.mouse.get_pos(); ray_origin = camera.pos; far_point = camera.unproject(mx, my, 5000); ray_dir = (far_point - ray_origin).normalize()
                        closest_hit_dist = float('inf'); hovered_tetra = None
                        for tetra in tetrahedrons:
                            if tetra is dragging[0]: continue
                            for face_indices in tetra.faces:
                                v0, v1, v2 = (tetra.world_verts[i] for i in face_indices)
                                if (v0-ray_origin).dot((v1-v0).cross(v2-v0)) < 0:
                                    dist = ray_intersect_triangle(ray_origin, ray_dir, v0, v1, v2)
                                    if dist and dist < closest_hit_dist: closest_hit_dist = dist; hovered_tetra = tetra
                        if hovered_tetra: frozen_tets.add(hovered_tetra)
                        tetra,v_idx,drag_depth,_,_ = dragging; v_3d=tetra.world_verts[v_idx]; best_target_info = None; min_screen_dist_sq = 50**2
                        for t_target in tetrahedrons:
                            if t_target is tetra: continue
                            num_bound_verts_drag = sum(1 for c in tetra.vertex_bind_counts if c > 0); num_bound_verts_target = sum(1 for c in t_target.vertex_bind_counts if c > 0)
                            for v_target_idx, v_target in enumerate(t_target.world_verts):
                                can_bind_drag = num_bound_verts_drag < 3 or tetra.vertex_bind_counts[v_idx] > 0
                                can_bind_target = num_bound_verts_target < 3 or t_target.vertex_bind_counts[v_target_idx] > 0
                                if not(can_bind_drag and can_bind_target): continue
                                p_screen, _ = camera.project(v_target)
                                if p_screen:
                                    dist_sq = (p_screen[0]-mx)**2 + (p_screen[1]-my)**2
                                    if dist_sq < min_screen_dist_sq: min_screen_dist_sq = dist_sq; best_target_info = v_target
                        target_pos_3d = best_target_info if best_target_info else camera.unproject(mx, my, drag_depth)
                        force_3d=(target_pos_3d-v_3d)*DRAG_STIFFNESS; tetra.apply_force(force_3d,v_3d,sub_step_multiplier)
                        tetra.vel*=DRAG_DAMPING; tetra.angular_vel*=DRAG_ANGULAR_DAMPING

                    for t in tetrahedrons:
                        if t in frozen_tets: t.vel = Vec3(); t.angular_vel = Vec3()
                        t.step(sub_step_multiplier)
                except Exception as e:
                    print(f"Caught physics instability in sub-step: {e}")
                    continue # Skip to the next sub-step

            for p in particles: p.update(time_multiplier)
            particles = [p for p in particles if p.lifespan > 0]
        try:
            conn,addr=server_socket.accept(); conn.setblocking(False); clients.append(conn); print(f"Client connected: {addr}")
        except (BlockingIOError, AttributeError): pass
        if MODE == 'host' and server_socket and len(clients) > 0 and (len(tetrahedrons) > 0 or len(particles)>0):
            tetra_states=[(t.pos,t.orientation) for t in tetrahedrons]; binding_states=[(tetrahedrons.index(b.t1),b.v1_idx,tetrahedrons.index(b.t2),b.v2_idx) for b in bindings if b.t1 in tetrahedrons and b.t2 in tetrahedrons]
            data=pickle.dumps((tetra_states,binding_states, world_origin)); clients_to_remove=[]
            for client in clients:
                try: client.sendall(len(data).to_bytes(4,'big')+data)
                except (ConnectionResetError,BrokenPipeError): clients_to_remove.append(client)
            for client in clients_to_remove: clients.remove(client); print("Client disconnected.")

    else: # Client Mode
        if client_socket:
            try:
                data_len_bytes=client_socket.recv(4)
                if data_len_bytes:
                    data_len=int.from_bytes(data_len_bytes,'big'); data=b''
                    while len(data)<data_len: data+=client_socket.recv(data_len-len(data))
                    tetra_states,binding_states, received_origin=pickle.loads(data); tetrahedrons=[]
                    world_origin = received_origin
                    for pos,orientation in tetra_states: t=Tetrahedron(pos); t.orientation=orientation; tetrahedrons.append(t)
                    bindings=[]
                    if tetrahedrons:
                        for t1_idx,v1_idx,t2_idx,v2_idx in binding_states:
                            if t1_idx<len(tetrahedrons) and t2_idx<len(tetrahedrons):
                                t1=tetrahedrons[t1_idx]; t2=tetrahedrons[t2_idx]; bindings.append(Binding(t1,v1_idx,t2,v2_idx))
                    for t in tetrahedrons: t.update_world_verts()
            except BlockingIOError: pass
            except (ConnectionResetError,BrokenPipeError, socket.error): print("Lost connection to host. Re-launch to connect or host."); pygame.quit(); sys.exit()

    screen.fill(VOID_BG if current_bg != LIGHT_BG else LIGHT_BG)
    if current_bg is star_field_surface: screen.blit(star_field_surface, (0,0))

    all_faces=[]
    for tetra in tetrahedrons:
        faces_data, projected_verts = tetra.get_render_data()
        all_faces.extend([(points, normal, base_color, z, tetra) for points, normal, base_color, z in faces_data])
    all_faces.sort(key=lambda x: x[3], reverse=True)
    draw_gizmo(world_origin)
    for points, normal, base_color, _, tetra in all_faces:
        brightness=max(0,normal.dot(LIGHT_DIR)); light_level=AMBIENT_LIGHT+DIFFUSE_LIGHT*brightness
        final_color = (0,0,0) if base_color==(0,0,0) else tuple(min(255,int(c*light_level)) for c in base_color)
        if tetra in frozen_tets: final_color = tuple(min(255, c1//2+c2//2) for c1,c2 in zip(final_color, FROZEN_COLOR))
        pygame.draw.polygon(screen, final_color, points)
    for b in bindings: b.draw()
    for p in particles: p.draw(camera)

    if not tetrahedrons and not restarting_universe and pygame.time.get_ticks() - void_entry_time < 20000:
        line1 = "Welcome to the Void!"; line2 = "Press [Space] to begin."
        text1 = void_font.render(line1, True, (255,255,255)); text2 = void_font.render(line2, True, (255,255,255))
        rect1 = text1.get_rect(center=(WIDTH/2, HEIGHT/2 - 20)); rect2 = text2.get_rect(center=(WIDTH/2, HEIGHT/2 + 20))
        screen.blit(text1, rect1); screen.blit(text2, rect2)

    text_color = (0,0,0) if current_bg == LIGHT_BG else (255,255,255)
    if show_time_message_until > pygame.time.get_ticks(): text = void_font.render("LET THERE BE TIME!", True, text_color); screen.blit(text, text.get_rect(center=(WIDTH/2, HEIGHT/2)))
    if show_light_message_until > pygame.time.get_ticks(): text = void_font.render("to grow old and wise", True, text_color); screen.blit(text, text.get_rect(center=(WIDTH/2, HEIGHT/2)))
    if show_darkness_message_until > pygame.time.get_ticks(): text = void_font.render("Now let there be darkness so light can be seen!", True, (255,255,255)); screen.blit(text, text.get_rect(center=(WIDTH/2, HEIGHT/2)))

    controls_text = "Q/E-Pan|Z/C-Time|TAB-Mode|X-Center|~-Restart|Spc-Add|LMB-Orbit|RMB-Drag/Break/Repulse|V-Save"
    info_text = f"Mode:{MODE.upper()}|Bodies:{len(tetrahedrons)}|Binds:{len(bindings)}|FPS:{clock.get_fps():.1f}|Time:{time_multiplier:.1f}x"
    label1 = font.render(info_text, True, (255,255,255)); screen.blit(label1, (10, 10))
    label2 = font.render(controls_text, True, (255,255,255)); screen.blit(label2, (10, 30))
    pygame.display.flip()





------------ v0.9



# Tetcraft - A Networked 3D Physics Sandbox
#
# Command-Line Options:
# To run as a host:
#   python tetra.py
#   python tetra.py -listen 192.168.1.100:50000
# To run as a client and connect to a host:
#   python tetra.py -connect 127.0.0.1:65420

import pygame
import math
import sys
import random
import socket
import pickle
import numpy as np

# --- Initialize Pygame and Mixer ---
pygame.mixer.pre_init(44100, -16, 1, 512)
pygame.init()
WIDTH, HEIGHT = 1600, 900
screen = pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE)
clock = pygame.time.Clock()
font = pygame.font.SysFont("consolas", 16)
void_font = pygame.font.SysFont("consolas", 24)

# --- Sound Generation ---
def generate_sound(frequency=440, duration=0.1, decay=0.9):
    sample_rate = 44100; n_samples = int(sample_rate * duration); t = np.linspace(0, duration, n_samples, False)
    audio = np.sin(frequency * t * 2 * np.pi)
    decay_curve = np.exp(-np.linspace(0, 5, n_samples) * (1 / (decay + 1e-5))); audio *= decay_curve
    audio *= 32767 / np.max(np.abs(audio))
    return pygame.sndarray.make_sound(audio.astype(np.int16))

snap_sound = generate_sound(1200, 0.05, 0.9); pop_sound = generate_sound(200, 0.1, 0.8); thud_sound = generate_sound(100, 0.15, 0.7)
align_sound = generate_sound(400, 0.2, 0.95)

# --- Starfield Generation ---
def create_star_surface(width, height):
    star_surf = pygame.Surface((width, height))
    star_surf.fill(VOID_BG)
    for _ in range(int(width * height / 4000)):
        x = random.randint(0, width - 1); y = random.randint(0, height - 1)
        brightness = random.randint(50, 150); star_surf.set_at((x, y), (brightness, brightness, brightness))
    return star_surf

# --- Raycasting and Particle Classes ---
def ray_intersect_triangle(ro, rd, v0, v1, v2):
    e1, e2 = v1 - v0, v2 - v0
    h = rd.cross(e2)
    a = e1.dot(h)
    if -1e-5 < a < 1e-5: return None
    f = 1.0 / a
    s = ro - v0
    u = f * s.dot(h)
    if u < 0.0 or u > 1.0: return None
    q = s.cross(e1)
    v = f * rd.dot(q)
    if v < 0.0 or u + v > 1.0: return None
    t = f * e2.dot(q)
    return t if t > 1e-5 else None

class Particle:
    def __init__(self, pos, vel, color, lifespan=1.0):
        self.pos, self.vel, self.color, self.lifespan, self.initial_lifespan = pos, vel, color, lifespan, lifespan
    def update(self, time_multiplier):
        self.pos += self.vel * time_multiplier; self.vel *= 0.98
        self.lifespan -= 0.02 * time_multiplier
    def draw(self, camera):
        p_screen, depth = camera.project(self.pos)
        if p_screen and self.lifespan > 0:
            fade = self.lifespan / self.initial_lifespan; radius = int(3 * fade)
            if radius > 0:
                final_color = tuple(int(c * fade) for c in self.color)
                pygame.draw.circle(screen, final_color, p_screen, radius)

# --------------------
# 3D Math Library & Main Classes
# --------------------
class Vec3:
    def __init__(self, x=0, y=0, z=0): self.x, self.y, self.z = x, y, z
    def __add__(self, o): return Vec3(self.x + o.x, self.y + o.y, self.z + o.z)
    def __sub__(self, o): return Vec3(self.x - o.x, self.y - o.y, self.z - o.z)
    def __mul__(self, s): return Vec3(self.x * s, self.y * s, self.z * s)
    def __truediv__(self, s): return Vec3(self.x / s, self.y / s, self.z / s)
    def length_sq(self): return self.x**2 + self.y**2 + self.z**2
    def length(self): return math.sqrt(self.length_sq())
    def normalize(self): l = self.length(); return self if l == 0 else self / l
    def cross(self, o): return Vec3(self.y*o.z-self.z*o.y, self.z*o.x-self.x*o.z, self.x*o.y-self.y*o.x)
    def dot(self, o): return self.x*o.x + self.y*o.y + self.z*o.z

class Quaternion:
    def __init__(self, w=1, x=0, y=0, z=0): self.w, self.x, self.y, self.z = w, x, y, z
    def __mul__(self, o): w1,x1,y1,z1=self.w,self.x,self.y,self.z; w2,x2,y2,z2=o.w,o.x,o.y,o.z; return Quaternion(w1*w2-x1*x2-y1*y2-z1*z2, w1*x2+x1*w2+y1*z2-z1*y2, w1*y2-x1*z2+y1*w2+z1*x2, w1*z2+x1*y2-y1*x2+z1*w2)
    def conjugate(self): return Quaternion(self.w, -self.x, -self.y, -self.z)
    def rotate(self, v): q_vec=Quaternion(0,v.x,v.y,v.z); r=self*q_vec*self.conjugate(); return Vec3(r.x,r.y,r.z)
    def normalize(self): mag=math.sqrt(self.w**2+self.x**2+self.y**2+self.z**2); self.w/=mag;self.x/=mag;self.y/=mag;self.z/=mag; return self

class Camera:
    def __init__(self, target=None, distance=400, yaw=0, pitch=0):
        self.target=target if target is not None else Vec3(); self.distance,self.yaw,self.pitch=distance,yaw,pitch
        self.focal_length,self.pos=400,Vec3(); self.min_dist,self.max_dist=150,2000; self.view_matrix=[]
        self.right,self.up,self.forward=Vec3(),Vec3(),Vec3()
    def update(self, zoom_input, mouse_rel):
        keys=pygame.key.get_pressed(); orbit_speed_key=0.02
        if mouse_rel: self.yaw+=mouse_rel[0]*MOUSE_ORBIT_SENSITIVITY; self.pitch-=mouse_rel[1]*MOUSE_ORBIT_SENSITIVITY
        if keys[pygame.K_a]: self.yaw-=orbit_speed_key
        if keys[pygame.K_d]: self.yaw+=orbit_speed_key
        if keys[pygame.K_w]: self.pitch+=orbit_speed_key
        if keys[pygame.K_s]: self.pitch-=orbit_speed_key
        pan_speed=4.0; forward_dir_pan=Vec3(math.sin(self.yaw),0,-math.cos(self.yaw)).normalize()
        right_dir_pan=Vec3(0,1,0).cross(forward_dir_pan).normalize()
        if keys[pygame.K_q]: self.target+=right_dir_pan*pan_speed
        if keys[pygame.K_e]: self.target-=right_dir_pan*pan_speed
        zoom_speed=1.05
        if zoom_input>0 or keys[pygame.K_r]: self.distance/=zoom_speed
        if zoom_input<0 or keys[pygame.K_f]: self.distance*=zoom_speed
        self.distance=max(self.min_dist,min(self.max_dist,self.distance))
        offset_from_target=Vec3(self.distance*math.cos(self.pitch)*math.sin(self.yaw),self.distance*math.sin(self.pitch),self.distance*math.cos(self.pitch)*-math.cos(self.yaw))
        self.pos=self.target+offset_from_target;
        self.forward=(self.target-self.pos).normalize()
        world_up = Vec3(0, 1, 0) if math.cos(self.pitch) >= 0 else Vec3(0, -1, 0)
        self.right=world_up.cross(self.forward).normalize()
        if self.right.length()<0.1: self.right = Vec3(-math.cos(self.yaw), 0, -math.sin(self.yaw))
        self.up=self.forward.cross(self.right)
        self.view_matrix=[[self.right.x,self.up.x,self.forward.x,0],[self.right.y,self.up.y,self.forward.y,0],[self.right.z,self.up.z,self.forward.z,0],[-self.right.dot(self.pos),-self.up.dot(self.pos),-self.forward.dot(self.pos),1]]
    def project(self, p_3d):
        px=p_3d.x*self.view_matrix[0][0]+p_3d.y*self.view_matrix[1][0]+p_3d.z*self.view_matrix[2][0]+self.view_matrix[3][0];py=p_3d.x*self.view_matrix[0][1]+p_3d.y*self.view_matrix[1][1]+p_3d.z*self.view_matrix[2][1]+self.view_matrix[3][1];pz=p_3d.x*self.view_matrix[0][2]+p_3d.y*self.view_matrix[1][2]+p_3d.z*self.view_matrix[2][2]+self.view_matrix[3][2]
        if not math.isfinite(px) or not math.isfinite(py) or pz <= 0: return None, None
        scale=self.focal_length/pz; sx=WIDTH/2+px*scale; sy=HEIGHT/2-py*scale; return (int(sx),int(sy)),pz
    def unproject(self, screen_x, screen_y, depth):
        ndc_x=(screen_x-WIDTH/2)/(WIDTH/2); ndc_y=-(screen_y-HEIGHT/2)/(HEIGHT/2)
        view_x=ndc_x*depth*(WIDTH/2)/self.focal_length; view_y=ndc_y*depth*(HEIGHT/2)/self.focal_length
        return self.pos+self.right*view_x+self.up*view_y+self.forward*depth

class Vertex:
    def __init__(self): self.is_face_repulsor=False; self.is_repulsive=False

class Tetrahedron:
    def __init__(self, pos):
        self.pos,self.vel,self.orientation,self.angular_vel=pos,Vec3(),Quaternion(),Vec3()
        self.energy = 0.0; s=EDGE_LEN*0.8
        self.local_verts=[Vec3(1,1,1).normalize()*s,Vec3(1,-1,-1).normalize()*s,Vec3(-1,1,-1).normalize()*s,Vec3(-1,-1,1).normalize()*s]
        self.world_verts=[Vec3()]*4; self.vertex_properties=[Vertex() for _ in range(4)]; self.vertex_bind_counts=[0]*4
        self.faces=[(0,1,2),(0,3,1),(0,2,3),(1,3,2)]; self.face_colors=[(255,0,0),(255,255,255),(0,0,0),(0,255,255)]
        v0,v1,v2,v3 = self.local_verts[0], self.local_verts[1], self.local_verts[2], self.local_verts[3]
        self.local_white_normal = (v3 - v0).cross(v1 - v0).normalize()
        self.local_black_normal = (v2 - v0).cross(v3 - v0).normalize()
        self.update_world_verts()
    def update_world_verts(self): [self.world_verts.__setitem__(i, self.pos+self.orientation.rotate(lv)) for i,lv in enumerate(self.local_verts)]
    def apply_force(self, force, point, time_multiplier): self.vel+=(force/MASS)*time_multiplier; self.angular_vel+=((point-self.pos).cross(force)/INERTIA)*time_multiplier
    def apply_torque(self, torque, time_multiplier): self.angular_vel += (torque / INERTIA) * time_multiplier
    def step(self, time_multiplier):
        self.pos+=self.vel*time_multiplier
        if not (math.isfinite(self.pos.x) and math.isfinite(self.pos.y) and math.isfinite(self.pos.z)):
            print("Simulation instability detected! Resetting tetrahedron.")
            self.pos = world_origin + Vec3(random.uniform(-EDGE_LEN,EDGE_LEN),random.uniform(-EDGE_LEN,EDGE_LEN),random.uniform(-EDGE_LEN,EDGE_LEN))
            self.vel = Vec3(); self.angular_vel = Vec3()
            return
        angle=self.angular_vel.length()*time_multiplier
        if angle>0:
            axis=self.angular_vel.normalize(); w=math.cos(angle*0.5); s=math.sin(angle*0.5)
            self.orientation=(Quaternion(w,axis.x*s,axis.y*s,axis.z*s)*self.orientation).normalize()
        self.vel*=DAMPING; self.angular_vel*=ANGULAR_DAMPING
    def get_render_data(self):
        projected_verts={i:camera.project(v) for i,v in enumerate(self.world_verts)}; faces_data=[]
        for i,face_indices in enumerate(self.faces):
            v0,v1,v2=(self.world_verts[i] for i in face_indices); normal=(v1-v0).cross(v2-v0)
            if normal.dot(camera.pos-v0)>0:
                p0_tuple,z0=projected_verts.get(face_indices[0], (None, None));p1_tuple,z1=projected_verts.get(face_indices[1], (None, None));p2_tuple,z2=projected_verts.get(face_indices[2], (None, None))
                if p0_tuple and p1_tuple and p2_tuple: faces_data.append(((p0_tuple,p1_tuple,p2_tuple),normal.normalize(),self.face_colors[i],(z0+z1+z2)/3))
        return faces_data, projected_verts

class Binding:
    def __init__(self, t1, v1_idx, t2, v2_idx):
        self.t1, self.v1_idx, self.t2, self.v2_idx = t1, v1_idx, t2, v2_idx
        self.rest = 0.0
    def apply(self, time_multiplier, tetra_dragged=None):
        v1, v2 = self.t1.world_verts[self.v1_idx], self.t2.world_verts[self.v2_idx]
        delta, d = v2-v1, (v2-v1).length()
        if d > 0:
            force = delta.normalize() * (d-self.rest) * RIGIDITY
            self.t1.apply_force(force, v1, time_multiplier); self.t2.apply_force(force*-1, v2, time_multiplier)
        is_part_of_drag = (self.t1 is tetra_dragged or self.t2 is tetra_dragged)
        if not is_part_of_drag:
            ref_idx_t1 = (self.v1_idx + 1) % 4; ref_idx_t2 = (self.v2_idx + 1) % 4
            vec1 = (self.t1.world_verts[ref_idx_t1] - v1).normalize()
            vec2 = (self.t2.world_verts[ref_idx_t2] - v2).normalize()
            torque_axis = vec1.cross(vec2); misalignment = 1.0 - vec1.dot(vec2)
            if torque_axis.length_sq() > 0:
                torque_vec = torque_axis.normalize() * misalignment * BOND_STABILITY_STRENGTH
                self.t1.apply_torque(torque_vec, time_multiplier); self.t2.apply_torque(torque_vec * -1, time_multiplier)
        return True
    def draw(self): p1,_=camera.project(self.t1.world_verts[self.v1_idx]);p2,_=camera.project(self.t2.world_verts[self.v2_idx]);p1 and p2 and pygame.draw.line(screen,BOUND_COLOR,p1,p2,2)

# --------------------
# Simulation Constants & Global Setup
# --------------------
EDGE_LEN=50; FULL_VERTEX_REPULSION=0.1; CREATE_BIND_DIST=EDGE_LEN*0.1
RIGIDITY = 0.18; DRAG_STIFFNESS = 0.18; COLLISION_REPULSION_STRENGTH = 0.6
SHORT_RANGE_ATTRACTION_STRENGTH = 0.03; ZIPPER_ATTRACTION_STRENGTH = 0.06
HIGH_ENERGY_REPULSION_STRENGTH = 0.012; BASE_ORIGIN_ORIENT_STRENGTH = 1.8
BOND_STABILITY_STRENGTH = 30.0; MASS=1.0; INERTIA=20000.0; DAMPING, ANGULAR_DAMPING=0.98, 0.98
DRAG_DAMPING, DRAG_ANGULAR_DAMPING=0.8, 0.8; MOUSE_ORBIT_SENSITIVITY=0.005
COLLISION_DISTANCE=EDGE_LEN*0.9; HOST='127.0.0.1'; PORT=65420
NEW_BIND_DAMPING = 0.5; SHORT_RANGE_ATTRACTION_RANGE = EDGE_LEN * 0.75
PERFORMANCE_THROTTLE_FPS = 45.0
ORIGIN_SINGULARITY_RADIUS = EDGE_LEN * 2.0; ORIGIN_SPIN_TORQUE = 20.0; ORBITAL_DECAY_STRENGTH = 0.05
ENERGY_CHARGE_RADIUS = EDGE_LEN * 4; ENERGY_CHARGE_RATE = 0.0001; ENERGY_DECAY_RATE = 0.0002
VELOCITY_DECAY_FACTOR = 0.0001; SUB_STEPS = 8
VOID_BG=(15,15,20); LIGHT_BG=(255,255,255); VERT_COLOR, BOUND_COLOR=(255,255,255),(255,150,150)
FROZEN_COLOR=(100,100,255); LIGHT_DIR=Vec3(0.5,-1,-0.5).normalize(); AMBIENT_LIGHT, DIFFUSE_LIGHT=0.4, 0.6
CALC_INDICATOR_POS=(WIDTH-20,10); CALC_INDICATOR_SIZE=(10,10)

# --- Game Functions ---
def draw_gizmo(origin):
    size = EDGE_LEN * 2
    o,x,y,z=origin,origin+Vec3(size,0,0),origin+Vec3(0,size,0),origin+Vec3(0,0,size)
    po,_=camera.project(o);px,_=camera.project(x);py,_=camera.project(y);pz,_=camera.project(z)
    if po and px: pygame.draw.line(screen,(255,0,0),po,px,3)
    if po and py: pygame.draw.line(screen,(255,255,255),po,py,3)
    if po and pz: pygame.draw.line(screen,(0,255,255),po,pz,3)

def generate_cluster_universe():
    print("Generating cluster of 8 tetrahedrons...")
    tets, binds = [], []
    GRID_X,GRID_Y,GRID_Z=2,2,2; SPACING=EDGE_LEN*1.8; JITTER=EDGE_LEN*0.5
    offset=Vec3((GRID_X-1)*SPACING/2,(GRID_Y-1)*SPACING/2,(GRID_Z-1)*SPACING/2)
    for x in range(GRID_X):
        for y in range(GRID_Y):
            for z in range(GRID_Z):
                pos = world_origin + Vec3(x*SPACING,y*SPACING,z*SPACING)-offset+Vec3(random.uniform(-JITTER,JITTER),random.uniform(-JITTER,JITTER),random.uniform(-JITTER,JITTER))
                tets.append(Tetrahedron(pos))
    return tets, binds

def add_tetrahedron():
    global show_time_message_until, show_light_message_until, show_darkness_message_until, current_bg, star_field_surface, void_entry_time
    if len(tetrahedrons) == 0: show_time_message_until = pygame.time.get_ticks() + 10000
    if len(tetrahedrons) == 1: show_light_message_until = pygame.time.get_ticks() + 10000; current_bg = LIGHT_BG
    if len(tetrahedrons) == 2: show_darkness_message_until = pygame.time.get_ticks() + 10000; star_field_surface = create_star_surface(WIDTH*2, HEIGHT); current_bg = star_field_surface; void_entry_time = 0
    pos = world_origin + Vec3(random.uniform(-EDGE_LEN,EDGE_LEN),random.uniform(-EDGE_LEN,EDGE_LEN),random.uniform(-EDGE_LEN,EDGE_LEN))
    new_tet = Tetrahedron(pos); new_tet.vel = Vec3(random.uniform(-5,5),random.uniform(-5,5),random.uniform(-5,5)); new_tet.angular_vel = Vec3(random.uniform(-0.1,0.1),random.uniform(-0.1,0.1),random.uniform(-0.1,0.1))
    tetrahedrons.append(new_tet); snap_sound.play()

def start_host_mode():
    global MODE, server_socket, client_socket, clients, tetrahedrons, bindings, particles, dragging, world_origin, void_entry_time, current_bg, PORT, HOST
    MODE = 'host';
    if client_socket: client_socket.close(); client_socket = None
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    max_attempts = 100
    temp_host, temp_port = (HOST, PORT)
    if '-listen' in sys.argv:
        try:
            temp_host, temp_port_str = sys.argv[sys.argv.index('-listen')+1].split(':')
            temp_port = int(temp_port_str)
        except (ValueError, IndexError): pass

    for attempt in range(max_attempts):
        try:
            server_socket.bind((temp_host, temp_port))
            HOST, PORT = temp_host, temp_port
            caption = f"Tetcraft – Networked Sandbox (Host on {HOST}:{PORT})"
            if attempt > 0: print(f"Successfully bound to new port: {HOST}:{PORT}")
            else: print(f"Hosting on: {HOST}:{PORT}")
            pygame.display.set_caption(caption)
            break
        except OSError:
            if attempt == 0: print(f"Default port {temp_port} is in use. Searching for an available port...")
            temp_port = random.randint(49152, 65535)
    else:
        print(f"Could not find available port. Exiting."); pygame.quit(); sys.exit()
    server_socket.setblocking(False); server_socket.listen(5); clients = []
    tetrahedrons, bindings, particles, dragging = [], [], [], None; world_origin = Vec3()
    void_entry_time = pygame.time.get_ticks(); current_bg = VOID_BG
    try_load_universe()

def start_client_mode():
    global MODE, server_socket, client_socket, clients, tetrahedrons, bindings, current_bg, particles, HOST, PORT
    MODE = 'client'; pygame.display.set_caption(f"Tetcraft – Networked Sandbox (Client)")
    if server_socket: [c.close() for c in clients]; server_socket.close(); server_socket = None
    clients = []; old_tets, old_binds = tetrahedrons, bindings
    tetrahedrons, bindings, particles = [], [], []; current_bg = VOID_BG
    if '-connect' not in sys.argv: HOST, PORT = '127.0.0.1', 65420
    try:
        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM); client_socket.connect((HOST, PORT)); client_socket.setblocking(False)
        print(f"Switched to CLIENT mode, connected to {HOST}:{PORT}")
    except (ConnectionRefusedError, TimeoutError, socket.error):
        print("Connection failed. No host found. Switching back to host mode."); start_host_mode(); tetrahedrons, bindings = old_tets, old_binds

def save_universe():
    try:
        tetra_states = [(t.pos, t.orientation, [v.is_repulsive for v in t.vertex_properties]) for t in tetrahedrons]
        binding_states = [(tetrahedrons.index(b.t1), b.v1_idx, tetrahedrons.index(b.t2), b.v2_idx) for b in bindings]
        data = (tetra_states, binding_states, world_origin);
        with open('universe.sav', 'wb') as f: pickle.dump(data, f)
        print("Universe saved.")
    except Exception as e: print(f"Error saving universe: {e}")

def try_load_universe():
    global tetrahedrons, bindings, world_origin
    try:
        with open('universe.sav', 'rb') as f:
            tetra_states, binding_states, saved_origin = pickle.load(f)
            tetrahedrons = []
            for pos, orientation, repulsive_states in tetra_states:
                t = Tetrahedron(pos); t.orientation = orientation
                for i, active in enumerate(repulsive_states): t.vertex_properties[i].is_repulsive = active
                tetrahedrons.append(t)
            bindings = []
            for t1_idx, v1_idx, t2_idx, v2_idx in binding_states:
                if t1_idx < len(tetrahedrons) and t2_idx < len(tetrahedrons):
                    bindings.append(Binding(tetrahedrons[t1_idx], v1_idx, tetrahedrons[t2_idx], v2_idx))
            world_origin = saved_origin; print("Universe loaded from save file.")
    except (FileNotFoundError, EOFError): print("No save file found, starting new universe.")
    except Exception as e: print(f"Error loading universe: {e}")

# --- CLI Parsing & Initial Setup ---
INITIAL_MODE = 'host'
if '-connect' in sys.argv:
    INITIAL_MODE = 'client'
    try:
        connect_idx = sys.argv.index('-connect') + 1
        address = sys.argv[connect_idx]
        HOST, PORT = address.split(':')
        PORT = int(PORT)
        print(f"Attempting to connect to {HOST}:{PORT}")
    except (ValueError, IndexError):
        print(f"Invalid -connect format. Use HOST:PORT. Defaulting to 127.0.0.1:65420"); HOST, PORT = '127.0.0.1', 65420
elif '-listen' in sys.argv:
    try:
        listen_idx = sys.argv.index('-listen') + 1
        address = sys.argv[listen_idx]
        HOST, PORT = address.split(':')
        PORT = int(PORT)
        print(f"Custom host/port provided: {HOST}:{PORT}")
    except (ValueError, IndexError):
        print(f"Invalid -listen format. Use HOST:PORT. Defaulting to 127.0.0.1:65420"); HOST, PORT = '127.0.0.1', 65420

MODE, server_socket, client_socket, clients = '', None, None, []
tetrahedrons, bindings, particles, dragging = [], [], [], None; world_origin = Vec3()
current_bg, star_field_surface = VOID_BG, None
camera=Camera(target=world_origin, distance=800)
intro_start_time = pygame.time.get_ticks()

if INITIAL_MODE == 'host': start_host_mode()
else: start_client_mode()

orbiting_with_mouse=False; time_multiplier=1.0; restarting_universe=False; restart_timer=0; void_entry_time=pygame.time.get_ticks()
show_time_message_until, show_light_message_until, show_darkness_message_until = 0, 0, 0
last_click_time = 0
while True:
    if pygame.time.get_ticks() - intro_start_time < 10000:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            if event.type == pygame.VIDEORESIZE: WIDTH, HEIGHT = event.w, event.h; screen = pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE)
        screen.fill(VOID_BG)
        font_size = int(HEIGHT / 2)
        while True:
            title_font = pygame.font.SysFont("consolas", font_size, bold=True)
            if title_font.size("TETCRAFT")[0] < WIDTH * 0.9: break
            font_size -= 5
        subtitle_font = pygame.font.SysFont("consolas", int(font_size/3), bold=True)
        title_surf = title_font.render("TETCRAFT", True, (255,255,255)); title_rect = title_surf.get_rect(center=(WIDTH/2, HEIGHT/2 - title_surf.get_height()/2))
        subtitle_surf = subtitle_font.render("Your own universe!", True, (200,200,200)); subtitle_rect = subtitle_surf.get_rect(center=(WIDTH/2, HEIGHT/2 + subtitle_surf.get_height()))
        screen.blit(title_surf, title_rect); screen.blit(subtitle_surf, subtitle_rect)
        pygame.display.flip(); clock.tick(60); continue

    fps = clock.get_fps()
    if fps > 0 and fps < PERFORMANCE_THROTTLE_FPS and time_multiplier > 1.0: time_multiplier = max(1.0, time_multiplier * 0.95)

    clock.tick(60); zoom_input=0; mouse_rel=(0,0)
    current_time = pygame.time.get_ticks()
    for event in pygame.event.get():
        if event.type==pygame.QUIT: pygame.quit();sys.exit()
        if event.type==pygame.MOUSEWHEEL: zoom_input=event.y
        if event.type == pygame.VIDEORESIZE:
            WIDTH, HEIGHT = event.w, event.h; screen = pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE)
            CALC_INDICATOR_POS = (WIDTH - 20, 10)
            if current_bg is star_field_surface: star_field_surface = create_star_surface(WIDTH, HEIGHT); current_bg = star_field_surface
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_TAB:
                if MODE == 'host': start_client_mode()
                else: start_host_mode()
            if event.key == pygame.K_v and MODE == 'host': save_universe()
            if event.key == pygame.K_x and MODE == 'host' and tetrahedrons:
                world_origin = sum([t.pos for t in tetrahedrons], Vec3()) / len(tetrahedrons); camera.target = world_origin
            if MODE == 'host':
                if event.key == pygame.K_SPACE: add_tetrahedron()
                if event.key == pygame.K_BACKQUOTE and tetrahedrons: restarting_universe = True; restart_timer = pygame.time.get_ticks()
        if MODE == 'host':
            if event.type==pygame.MOUSEBUTTONDOWN:
                if event.button == 1:
                    if not dragging: orbiting_with_mouse=True; pygame.mouse.set_visible(False); pygame.event.set_grab(True)
                elif event.button == 3:
                    last_click_time = current_time; mx,my=pygame.mouse.get_pos(); min_dist_sq=float('inf'); closest_v_info=None
                    for t_idx,tetra in enumerate(tetrahedrons):
                        for v_idx,v_world in enumerate(tetra.world_verts):
                            p_screen, depth = camera.project(v_world)
                            if p_screen and (p_screen[0]-mx)**2+(p_screen[1]-my)**2 < min_dist_sq:
                                min_dist_sq=(p_screen[0]-mx)**2+(p_screen[1]-my)**2; closest_v_info=(t_idx,v_idx,depth,v_world)
                    if closest_v_info and min_dist_sq<50**2:
                        t_idx,v_idx,depth,v_world=closest_v_info; dragging=(tetrahedrons[t_idx],v_idx,depth,pygame.mouse.get_pos(),v_world)
            if event.type==pygame.MOUSEBUTTONUP:
                if event.button == 1: orbiting_with_mouse=False; pygame.mouse.set_visible(True); pygame.event.set_grab(False)
                elif event.button == 3:
                    if dragging: dragging = None
                    elif current_time - last_click_time < 200:
                        mx,my=pygame.mouse.get_pos(); min_dist_sq=float('inf'); closest_v_info=None
                        for t_idx,tetra in enumerate(tetrahedrons):
                            for v_idx,v_world in enumerate(tetra.world_verts):
                                p_screen, _ = camera.project(v_world)
                                if p_screen and (p_screen[0]-mx)**2+(p_screen[1]-my)**2 < 50**2:
                                    dist_sq=(p_screen[0]-mx)**2+(p_screen[1]-my)**2
                                    if dist_sq < min_dist_sq: min_dist_sq=dist_sq; closest_v_info=(t_idx,v_idx)
                        if closest_v_info:
                            t_idx,v_idx=closest_v_info; clicked_tetra = tetrahedrons[t_idx]
                            if clicked_tetra.vertex_bind_counts[v_idx] > 0:
                                bonds = [b for b in bindings if not ((b.t1 is clicked_tetra and b.v1_idx == v_idx) or (b.t2 is clicked_tetra and b.v2_idx == v_idx))]
                                if len(bindings) > len(bonds): pop_sound.play()
                                bindings = bonds
                            else:
                                prop = clicked_tetra.vertex_properties[v_idx]; prop.is_repulsive = not prop.is_repulsive; snap_sound.play(); print(f"Vertex Repulsion: {'ON' if prop.is_repulsive else 'OFF'}")

    keys = pygame.key.get_pressed()
    if keys[pygame.K_c]: time_multiplier = min(10.0, time_multiplier + 0.05)
    if keys[pygame.K_z]: time_multiplier = max(0.0, time_multiplier - 0.05)
    if orbiting_with_mouse: mouse_rel = pygame.mouse.get_rel()
    camera.update(zoom_input, mouse_rel)

    if MODE == 'host':
        is_hovering_vertex = False
        if not orbiting_with_mouse and not dragging:
            mx,my=pygame.mouse.get_pos()
            for tetra in tetrahedrons:
                for v_world in tetra.world_verts:
                    p_screen, _ = camera.project(v_world)
                    if p_screen and (p_screen[0]-mx)**2+(p_screen[1]-my)**2 < 50**2: is_hovering_vertex=True; break
                if is_hovering_vertex: break
        if is_hovering_vertex: pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_HAND)
        else: pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_ARROW)

    pygame.draw.rect(screen, (255,255,0), (CALC_INDICATOR_POS, CALC_INDICATOR_SIZE))
    pygame.display.update(pygame.Rect(CALC_INDICATOR_POS, CALC_INDICATOR_SIZE))

    if MODE == 'host':
        if restarting_universe:
            if pygame.time.get_ticks() - restart_timer > 100:
                if tetrahedrons:
                    t_to_remove = tetrahedrons.pop(random.randrange(len(tetrahedrons)))
                    bindings = [b for b in bindings if b.t1 is not t_to_remove and b.t2 is not t_to_remove]
                    for _ in range(30): particles.append(Particle(t_to_remove.pos, Vec3(random.uniform(-1,1), random.uniform(-1,1), random.uniform(-1,1)).normalize() * random.uniform(5, 15), random.choice(t_to_remove.face_colors), lifespan=random.uniform(0.5, 1.5)))
                    pop_sound.play(); restart_timer = pygame.time.get_ticks()
                else: restarting_universe = False; particles = []; tetrahedrons, bindings = generate_cluster_universe()
        else:
            if tetrahedrons: world_origin = sum([t.pos for t in tetrahedrons], Vec3()) / len(tetrahedrons)
            cam_to_origin_dir = (world_origin - camera.pos).normalize()
            if camera.forward.dot(cam_to_origin_dir) < math.cos(math.radians(45)): # 45 degree FOV leash
                camera.target += (world_origin - camera.target) * 0.05

            num_sub_steps = max(1, math.ceil(time_multiplier * SUB_STEPS))
            sub_step_multiplier = time_multiplier / num_sub_steps
            for _ in range(num_sub_steps):
                try:
                    for t in tetrahedrons: t.vertex_bind_counts = [0]*4
                    for b in bindings: b.t1.vertex_bind_counts[b.v1_idx]+=1; b.t2.vertex_bind_counts[b.v2_idx]+=1

                    new_bindings = []
                    if dragging:
                        tetra_drag, v_idx_drag, _, _, _ = dragging; v_dragged = tetra_drag.world_verts[v_idx_drag]
                        num_bound_verts_drag = sum(1 for c in tetra_drag.vertex_bind_counts if c > 0)
                        for t_target in tetrahedrons:
                            if t_target is tetra_drag: continue
                            num_bound_verts_target = sum(1 for c in t_target.vertex_bind_counts if c > 0)
                            for v_idx_target, v_target in enumerate(t_target.world_verts):
                                can_bind_drag = num_bound_verts_drag < 3 or tetra_drag.vertex_bind_counts[v_idx_drag] > 0
                                can_bind_target = num_bound_verts_target < 3 or t_target.vertex_bind_counts[v_idx_target] > 0
                                if can_bind_drag and can_bind_target and (v_dragged - v_target).length_sq() < CREATE_BIND_DIST**2:
                                    is_already_bound = any(b for b in bindings if (b.t1,b.v1_idx,b.t2,b.v2_idx) in [(tetra_drag,v_idx_drag,t_target,v_idx_target),(t_target,v_idx_target,tetra_drag,v_idx_drag)])
                                    if not is_already_bound: new_bindings.append(Binding(tetra_drag, v_idx_drag, t_target, v_idx_target)); dragging = None; break
                            if not dragging: break

                    visited = set(); structures = []
                    for t_start in tetrahedrons:
                        if t_start in visited: continue
                        structure = set(); q = [t_start]; visited.add(t_start); structure.add(t_start); head = 0
                        while head < len(q):
                            current_t = q[head]; head += 1
                            for b in bindings:
                                neighbor = None
                                if b.t1 is current_t: neighbor = b.t2
                                elif b.t2 is current_t: neighbor = b.t1
                                if neighbor and neighbor not in visited: visited.add(neighbor); structure.add(neighbor); q.append(neighbor)
                        if structure: structures.append(list(structure))

                    for i in range(len(structures)):
                        for j in range(i + 1, len(structures)):
                            s1, s2 = structures[i], structures[j]
                            cm1 = sum([t.pos for t in s1], Vec3()) / len(s1)
                            cm2 = sum([t.pos for t in s2], Vec3()) / len(s2)
                            r1 = max([(t.pos - cm1).length() for t in s1], default=0) + EDGE_LEN * 0.5
                            r2 = max([(t.pos - cm2).length() for t in s2], default=0) + EDGE_LEN * 0.5
                            delta = cm2 - cm1; dist_sq = delta.length_sq()
                            if dist_sq > 0 and dist_sq < (r1+r2)**2:
                                dist = math.sqrt(dist_sq); penetration = (r1+r2) - dist
                                force_dir = delta / dist; force = force_dir * penetration**2 * COLLISION_REPULSION_STRENGTH
                                for t in s1: t.apply_force(force * -1, t.pos, sub_step_multiplier)
                                for t in s2: t.apply_force(force, t.pos, sub_step_multiplier)

                    for structure in structures:
                        center_of_mass = sum([t.pos for t in structure], Vec3()) / len(structure); avg_energy = sum(t.energy for t in structure) / len(structure); dist_sq = (center_of_mass - world_origin).length_sq()
                        dist = math.sqrt(dist_sq)

                        if dist < ENERGY_CHARGE_RADIUS and avg_energy < 0.1:
                           for t in structure: t.energy = min(1.0, t.energy + ENERGY_CHARGE_RATE * sub_step_multiplier)
                        else:
                           for t in structure:
                                radial_velocity = t.vel.dot((t.pos - world_origin).normalize()) if dist > 0 else 0; outward_speed = max(0, radial_velocity)
                                dynamic_decay_rate = ENERGY_DECAY_RATE + (outward_speed * VELOCITY_DECAY_FACTOR)
                                t.energy = max(0.0, t.energy - dynamic_decay_rate * sub_step_multiplier)

                        if avg_energy > 0.5:
                            repulsion_force = (center_of_mass - world_origin).normalize() * HIGH_ENERGY_REPULSION_STRENGTH * avg_energy
                            for t in structure: t.apply_force(repulsion_force, t.pos, sub_step_multiplier)
                        else:
                            pull_force = (world_origin - center_of_mass).normalize() * 0.01 * (1.0 - avg_energy)
                            for t in structure: t.apply_force(pull_force, t.pos, sub_step_multiplier)

                        if dist_sq < ORIGIN_SINGULARITY_RADIUS**2 and avg_energy < 0.1:
                            for t in structure:
                                radial_vec = t.pos - world_origin
                                tangential_vel = t.vel - radial_vec * (t.vel.dot(radial_vec) / max(1e-5, radial_vec.length_sq()))
                                decay_force = tangential_vel * -ORBITAL_DECAY_STRENGTH
                                t.apply_force(decay_force, t.pos, sub_step_multiplier)
                                t.apply_torque(Vec3(0.1, 1, 0.1).normalize() * ORIGIN_SPIN_TORQUE, sub_step_multiplier)
                        elif len(structure) == 1:
                            t = structure[0]
                            target_dir_origin = (world_origin - t.pos).normalize()
                            if target_dir_origin.length_sq() > 0:
                                torque1 = t.orientation.rotate(t.local_black_normal).cross(target_dir_origin) * BASE_ORIGIN_ORIENT_STRENGTH
                                torque2 = t.orientation.rotate(t.local_white_normal).cross(Vec3(0,1,0)) * (BASE_ORIGIN_ORIENT_STRENGTH * 0.5)
                                t.apply_torque(torque1 + torque2, sub_step_multiplier)

                    for t in tetrahedrons: t.update_world_verts()
                    for t in tetrahedrons:
                        for prop in t.vertex_properties: prop.is_face_repulsor=False
                        if sum(1 for c in t.vertex_bind_counts if c > 0) == 3:
                            for i, count in enumerate(t.vertex_bind_counts):
                                if count == 0: t.vertex_properties[i].is_face_repulsor = True

                    if new_bindings:
                        snap_sound.play()
                        for b in new_bindings: b.t1.vel *= NEW_BIND_DAMPING; b.t1.angular_vel *= NEW_BIND_DAMPING; b.t2.vel *= NEW_BIND_DAMPING; b.t2.angular_vel *= NEW_BIND_DAMPING
                        bindings.extend(new_bindings)
                    tetra_being_dragged = dragging[0] if dragging else None
                    for b in bindings: b.apply(sub_step_multiplier, tetra_being_dragged)

                    frozen_tets = set()
                    if dragging:
                        mx,my = pygame.mouse.get_pos(); ray_origin = camera.pos; far_point = camera.unproject(mx, my, 5000); ray_dir = (far_point - ray_origin).normalize()
                        closest_hit_dist = float('inf'); hovered_tetra = None
                        for tetra in tetrahedrons:
                            if tetra is dragging[0]: continue
                            for face_indices in tetra.faces:
                                v0, v1, v2 = (tetra.world_verts[i] for i in face_indices)
                                if (v0-ray_origin).dot((v1-v0).cross(v2-v0)) < 0:
                                    dist = ray_intersect_triangle(ray_origin, ray_dir, v0, v1, v2)
                                    if dist and dist < closest_hit_dist: closest_hit_dist = dist; hovered_tetra = tetra
                        if hovered_tetra: frozen_tets.add(hovered_tetra)
                        tetra,v_idx,drag_depth,_,_ = dragging; v_3d=tetra.world_verts[v_idx]; best_target_info = None; min_screen_dist_sq = 50**2
                        for t_target in tetrahedrons:
                            if t_target is tetra: continue
                            num_bound_verts_drag = sum(1 for c in tetra.vertex_bind_counts if c > 0); num_bound_verts_target = sum(1 for c in t_target.vertex_bind_counts if c > 0)
                            for v_target_idx, v_target in enumerate(t_target.world_verts):
                                can_bind_drag = num_bound_verts_drag < 3 or tetra.vertex_bind_counts[v_idx] > 0
                                can_bind_target = num_bound_verts_target < 3 or t_target.vertex_bind_counts[v_target_idx] > 0
                                if not(can_bind_drag and can_bind_target): continue
                                p_screen, _ = camera.project(v_target)
                                if p_screen:
                                    dist_sq = (p_screen[0]-mx)**2 + (p_screen[1]-my)**2
                                    if dist_sq < min_screen_dist_sq: min_screen_dist_sq = dist_sq; best_target_info = v_target
                        target_pos_3d = best_target_info if best_target_info else camera.unproject(mx, my, drag_depth)
                        force_3d=(target_pos_3d-v_3d)*DRAG_STIFFNESS; tetra.apply_force(force_3d,v_3d,sub_step_multiplier)
                        tetra.vel*=DRAG_DAMPING; tetra.angular_vel*=DRAG_ANGULAR_DAMPING

                    for t in tetrahedrons:
                        if t in frozen_tets: t.vel = Vec3(); t.angular_vel = Vec3()
                        t.step(sub_step_multiplier)
                except Exception as e:
                    print(f"Caught physics instability in sub-step: {e}"); continue

            for p in particles: p.update(time_multiplier)
            particles = [p for p in particles if p.lifespan > 0]
        try:
            conn,addr=server_socket.accept(); conn.setblocking(False); clients.append(conn); print(f"Client connected: {addr}")
        except (BlockingIOError, AttributeError): pass
        if MODE == 'host' and server_socket and len(clients) > 0 and (len(tetrahedrons) > 0 or len(particles)>0):
            tetra_states=[(t.pos,t.orientation) for t in tetrahedrons]; binding_states=[(tetrahedrons.index(b.t1),b.v1_idx,tetrahedrons.index(b.t2),b.v2_idx) for b in bindings if b.t1 in tetrahedrons and b.t2 in tetrahedrons]
            data=pickle.dumps((tetra_states,binding_states, world_origin)); clients_to_remove=[]
            for client in clients:
                try: client.sendall(len(data).to_bytes(4,'big')+data)
                except (ConnectionResetError,BrokenPipeError): clients_to_remove.append(client)
            for client in clients_to_remove: clients.remove(client); print("Client disconnected.")

    else: # Client Mode
        if client_socket:
            try:
                data_len_bytes=client_socket.recv(4)
                if data_len_bytes:
                    data_len=int.from_bytes(data_len_bytes,'big'); data=b''
                    while len(data)<data_len: data+=client_socket.recv(data_len-len(data))
                    tetra_states,binding_states, received_origin=pickle.loads(data); tetrahedrons=[]
                    world_origin = received_origin; camera.target = world_origin
                    for pos,orientation in tetra_states: t=Tetrahedron(pos); t.orientation=orientation; tetrahedrons.append(t)
                    bindings=[]
                    if tetrahedrons:
                        for t1_idx,v1_idx,t2_idx,v2_idx in binding_states:
                            if t1_idx<len(tetrahedrons) and t2_idx<len(tetrahedrons):
                                t1=tetrahedrons[t1_idx]; t2=tetrahedrons[t2_idx]; bindings.append(Binding(t1,v1_idx,t2,v2_idx))
                    for t in tetrahedrons: t.update_world_verts()
            except BlockingIOError: pass
            except (ConnectionResetError,BrokenPipeError, socket.error): print("Lost connection to host. Re-launch to connect or host."); pygame.quit(); sys.exit()

    screen.fill(VOID_BG if current_bg != LIGHT_BG else LIGHT_BG)
    if current_bg is star_field_surface: screen.blit(star_field_surface, (0,0))

    all_faces=[]
    for tetra in tetrahedrons:
        faces_data, projected_verts = tetra.get_render_data()
        all_faces.extend([(points, normal, base_color, z, tetra) for points, normal, base_color, z in faces_data])
    all_faces.sort(key=lambda x: x[3], reverse=True)
    draw_gizmo(world_origin)
    for points, normal, base_color, _, tetra in all_faces:
        brightness=max(0,normal.dot(LIGHT_DIR)); light_level=AMBIENT_LIGHT+DIFFUSE_LIGHT*brightness
        final_color = (0,0,0) if base_color==(0,0,0) else tuple(min(255,int(c*light_level)) for c in base_color)
        if tetra in frozen_tets: final_color = tuple(min(255, c1//2+c2//2) for c1,c2 in zip(final_color, FROZEN_COLOR))
        pygame.draw.polygon(screen, final_color, points)
    for b in bindings: b.draw()
    for p in particles: p.draw(camera)

    if not tetrahedrons and not restarting_universe and pygame.time.get_ticks() - void_entry_time < 20000:
        line1 = "Welcome to the Void!"; line2 = "Press [Space] to begin."
        text1 = void_font.render(line1, True, (255,255,255)); text2 = void_font.render(line2, True, (255,255,255))
        rect1 = text1.get_rect(center=(WIDTH/2, HEIGHT/2 - 20)); rect2 = text2.get_rect(center=(WIDTH/2, HEIGHT/2 + 20))
        screen.blit(text1, rect1); screen.blit(text2, rect2)

    text_color = (0,0,0) if current_bg == LIGHT_BG else (255,255,255)
    if show_time_message_until > pygame.time.get_ticks(): text = void_font.render("LET THERE BE TIME!", True, text_color); screen.blit(text, text.get_rect(center=(WIDTH/2, HEIGHT/2)))
    if show_light_message_until > pygame.time.get_ticks(): text = void_font.render("to grow old and wise", True, text_color); screen.blit(text, text.get_rect(center=(WIDTH/2, HEIGHT/2)))
    if show_darkness_message_until > pygame.time.get_ticks(): text = void_font.render("Now let there be darkness so light can be seen!", True, (255,255,255)); screen.blit(text, text.get_rect(center=(WIDTH/2, HEIGHT/2)))

    controls_text = "Q/E-Pan|Z/C-Time|TAB-Mode|~-Restart|Spc-Add|LMB-Orbit|RMB-Drag/Break/Repulse|V-Save"
    info_text = f"Mode:{MODE.upper()}|Bodies:{len(tetrahedrons)}|Binds:{len(bindings)}|FPS:{clock.get_fps():.1f}|Time:{time_multiplier:.1f}x"
    label1 = font.render(info_text, True, (255,255,255)); screen.blit(label1, (10, 10))
    label2 = font.render(controls_text, True, (255,255,255));
    screen.blit(label2, (10, HEIGHT - label2.get_height() - 10))
    pygame.display.flip()






--------- Whitepaper v3:



Tetcraft Whitepaper v3.0

Field-Emergent Constraint Mechanics for a Dynamic Universe

Abstract

This document defines a revised physics and interaction model for Tetcraft. It replaces a system of explicit, stateful joints and numerous patched-on forces with a minimalist set of foundational laws. All tetrahedron behavior—attraction, repulsion, bonding, and complex mechanical motion (hinges, fusion)—emerges naturally from the interplay of these core principles. The model is designed for determinism, stability at high simulation speeds, and intuitive, emergent gameplay where engineering challenges are solved through understanding the universe's fundamental rules, not by selecting tools from a menu.

1. The Foundational Laws

The universe is governed by three primary laws that dictate all motion and interaction: The Law of Universal Balance, The Law of Cohesion, and The Law of Structure.

1.1 The Law of Universal Balance (Energy & Motion)

This law unifies gravity, heat, and repulsion into a single principle governing a tetrahedron's interaction with the Origin.

A. The Force Equation:

The primary force exerted on any tetrahedron by the universe is:

F_origin = (E_tet - E_eq(r)) * k_repulsion * r̂

E_tet: The tetrahedron's current internal energy (0.0 to 1.0).

E_eq(r): The "ambient temperature" of space at a distance r from the Origin, defined by e^(-λ * r), where λ is a heat decay constant. This value is 1.0 at the Origin and decays towards 0.0 at a distance of roughly 10 edge lengths.

k_repulsion: A constant scaling the strength of this force.

r̂: The unit vector pointing from the Origin to the tetrahedron.

B. Emergent Behaviors:

Reverse Gravity: A "cold" tet (E_tet ≈ 0) far from the Origin has a large negative (E_tet - E_eq) value, resulting in a strong attractive force pulling it back.

Origin's Push: A "hot" tet (E_tet ≈ 1) near the Origin has a positive (E_tet - E_eq) value, creating a gentle repulsive force pushing it away from the center.

C. Energy Dynamics:

Charging: A tetrahedron's energy E_tet only increases if it is within the ENERGY_CHARGE_RADIUS and E_tet is very low (e.g., < 0.1), representing the need to be "drained" before it can absorb the Origin's power.

Bleeding: Energy flows out of a tetrahedron when it is far from the Origin, with the rate of decay increasing proportionally to its velocity moving away from the Origin.

Equalization: Energy flows across established bonds from hotter tetrahedra to colder ones until they reach equilibrium.

Orbital Decay: When a low-energy object orbits inside the singularity, a tangential drag force is applied, causing its orbit to decay and spiral inwards.

1.2 The Law of Cohesion (Attraction & Bonding)

This law governs the "desire" for tetrahedra to connect. It is a single, efficient force calculation modified by three factors.

A. Procedure:

For any two tetrahedra, A and B, first identify the single closest pair of unbound vertices between them. All attraction calculations are performed only on this one pair, drastically improving performance.

B. The Force Equation:

F_attraction = C_dist(r) * C_energy(E_A, E_B) * C_bonds(n)

C_dist(r) (Distance Factor): A powerful, short-range force that activates when the two closest vertices are within a specific radius, creating a strong "snap" effect.

C_energy(E_A, E_B) (Energy Factor): The attraction is strongest when both tetrahedra are "cold" (low energy), defined as (1 - E_A) * (1 - E_B). Hot objects have minimal desire to connect.

C_bonds(n) (Bond Saturation Factor): The force is scaled by n, the number of bonds already existing between A and B:

n = 0: The desire is maximal to form the first connection.

n = 1 or 2: The desire is high to form a stable tripod/face (the "zipper" effect).

n = 3: The factor becomes negative and very large. This creates a powerful repulsive force applied to the two remaining free vertices, forcing the tetrahedra to snap into a fused, hexahedral shape. This repulsion can be overcome by the player's direct dragging force.

1.3 The Law of Structure (Internal Physics & Overlap)

This law governs how bonded structures stay together and how all objects interact physically.

A. Bond Physics:

Linear Force: A simple spring force (F = -k * x) holds bonded vertices together at their resting distance.

Rotational Force (Weld): A powerful torque is applied to resist any rotational misalignment between bonded tetrahedra, keeping structures rigid unless being actively manipulated by the player.

B. "Soft Field" Repulsion:

This replaces traditional hard-body collision.

For any two tetrahedra A and B, calculate a PenetrationScore by counting how many vertices of A are inside the geometric volume of B, and vice-versa.

If PenetrationScore > 0, apply a single, gentle repulsion force between the centers of A and B.

The force magnitude is: F_repulsion = k_soft * PenetrationScore * (E_A * E_B).

Interaction Rule: If the player is dragging A or hovering over B with the intent to connect, its energy E_A or E_B is treated as 0.0 for this calculation, making it "cold" and allowing it to slip past other "hot" objects without resistance.

Conclusion

This three-law system provides a complete and robust foundation for the Tetcraft universe. It eliminates redundant and conflicting "patched" mechanics in favor of a unified model where all complex behaviors—from the lifecycle of resources to the engineering of complex machinery—emerge naturally from a few simple, elegant, and computationally efficient rules.





----------------- v1.0






import pygame
import numpy as np
import math
import random
import sys
import os
import json
from collections import deque
from contextlib import redirect_stdout

# ============================
# CONFIG
# ============================
WIDTH, HEIGHT = 1200, 800
FPS = 60

EDGE_LEN = 40
SNAP_DIST = 15

# --- VERLET PHYSICS CONSTANTS ---
STICKY_PULL_SPEED = 60.0
DAMPING = 0.995
MOUSE_PULL_STRENGTH = 0.0005
BODY_PULL_STRENGTH = 0.0008
COLLISION_RADIUS = EDGE_LEN * 0.75

# --- BEHAVIOR CONSTANTS (SLOWER) ---
K_ORIGIN_PULL = 0.005
K_SPIN = 1.0
MAX_SPIN_FORCE = K_SPIN * 15
SPIN_ENERGY_COST = 0.08
K_ALIGN = 4.0
K_BATTERY_FORCE = 0.0015
K_CONTAINMENT = 0.01

# --- CAMERA CONTROL CONSTANTS ---
ORBIT_SPEED = 1.5
PAN_SPEED = 200.0
ZOOM_SPEED = 1.5

BATTERY_CHARGE_RADIUS = 50
BATTERY_DRAIN_RADIUS = 420
BATTERY_CHARGE_RATE = 0.03
BATTERY_DRAIN_RATE = 0.05

MAX_DIST_FROM_ORIGIN = 100 * EDGE_LEN
MIN_ZOOM_DIST = 50
MAX_ZOOM_DIST = 10000 * EDGE_LEN
AXIS_LEN = 40
SAVE_FILENAME = "tetcraft_save.json"

# ============================
# CAMERA
# ============================
class Camera:
    def __init__(self):
        self.yaw, self.pitch, self.dist, self.pan = 0.0, 0.35, 650, np.zeros(3)
    def get_transformed_z(self, v):
        v = v - self.pan; cy, sy = math.cos(self.yaw), math.sin(self.yaw); cp, sp = math.cos(self.pitch), math.sin(self.pitch)
        x, y, z = v; zz = sy*x + cy*z; zz2 = sp*y + cp*zz
        return zz2
    def project(self, v):
        global WIDTH, HEIGHT
        v = v - self.pan; cy, sy = math.cos(self.yaw), math.sin(self.yaw); cp, sp = math.cos(self.pitch), math.sin(self.pitch)
        x, y, z = v; x, z = cy*x - sy*z, sy*x + cy*z; y, z = cp*y - sp*z, sp*y + cp*z
        scale = self.dist / (self.dist + z + 1e-6)
        return (WIDTH//2 + int(x * scale), HEIGHT//2 - int(y * scale))
    def unproject(self, screen_pos, depth_z):
        global WIDTH, HEIGHT; mx, my = screen_pos
        scale = self.dist / (self.dist + depth_z + 1e-6)
        if abs(scale) < 1e-6: return self.pan
        x_cam = (mx - WIDTH // 2) / scale; y_cam = -(my - HEIGHT // 2) / scale
        cy, sy = math.cos(self.yaw), math.sin(self.yaw); cp, sp = math.cos(self.pitch), math.sin(self.pitch)
        y_rot, z_rot = cp * y_cam + sp * depth_z, -sp * y_cam + cp * depth_z
        x_world, z_world = cy * x_cam + sy * z_rot, -sy * x_cam + cy * z_rot
        return np.array([x_world, y_rot, z_world]) + self.pan
    def zoom(self, factor): self.dist = np.clip(self.dist * factor, MIN_ZOOM_DIST, MAX_ZOOM_DIST)

# ============================
# UTIL & SOUND
# ============================
def norm(v):
    n = np.linalg.norm(v); return v / n if n > 1e-6 else np.zeros_like(v)
def dist_point_to_ray(p, a, b):
    ap, ab = p - a, b - a; t = np.dot(ap, ab) / (np.dot(ab, ab) + 1e-6)
    return np.linalg.norm(p - (a + ab * max(0, t)))
def generate_boing_sound():
    mixer_settings = pygame.mixer.get_init()
    if mixer_settings is None: return None
    sample_rate, _, channels = mixer_settings; duration = 0.2; num_samples = int(duration * sample_rate)
    t = np.linspace(0, duration, num_samples, False); freq = np.linspace(660.0, 220.0, num_samples); wave = np.sin(2 * np.pi * freq * t) * np.exp(-t * 10)
    sound_array = (wave * 32767).astype(np.int16)
    if channels == 2: sound_array = np.column_stack((sound_array, sound_array))
    return pygame.sndarray.make_sound(sound_array)

# ============================
# PHYSICS CLASSES (USING VERLET INTEGRATION)
# ============================
class VertexJoint:
    def __init__(self, A, ia, B, ib): self.A, self.ia, self.B, self.ib = A, ia, B, ib
    def resolve(self):
        p1, p2 = self.A.verts()[self.ia], self.B.verts()[self.ib]; delta = p2 - p1; dist = np.linalg.norm(delta)
        if dist > 1e-6:
            diff = dist / dist * 0.5; self.A.local[self.ia] += delta * diff; self.B.local[self.ib] -= delta * diff

class Tetrahedron:
    def __init__(self, pos):
        self.pos = np.array(pos, float); self.pos_prev = self.pos.copy()
        self.battery, self.colors = random.uniform(0.3, 0.6), None
        r, a = EDGE_LEN*math.sqrt(3/8), EDGE_LEN/math.sqrt(3)
        self.rest = np.array([[0,0,r], [EDGE_LEN/2,-a/2,-r/3], [-EDGE_LEN/2,-a/2,-r/3], [0,a,-r/3]])
        self.local = self.rest.copy(); self.local_prev = self.local.copy()
        self.edges = [(i, j) for i in range(4) for j in range(i+1, 4)]; self.faces = [(1, 2, 3), (0, 1, 2), (0, 2, 3), (0, 1, 3)]
    def verts(self): return self.local + self.pos
    def update_physics(self, dt, acceleration):
        pos_temp = self.pos.copy(); self.pos += (self.pos - self.pos_prev) * DAMPING + acceleration * dt * dt; self.pos_prev = pos_temp
        local_temp = self.local.copy(); self.local += (self.local - self.local_prev) * DAMPING; self.local_prev = local_temp
    def apply_internal_forces(self):
        self.local -= np.mean(self.local, axis=0)
        for _ in range(3):
            for i, j in self.edges:
                p1, p2 = self.local[i], self.local[j]; delta = p2 - p1; dist = np.linalg.norm(delta)
                if dist > 1e-6: diff = (dist - EDGE_LEN) / dist * 0.5; self.local[i] += delta * diff; self.local[j] -= delta * diff

class World:
    def __init__(self, sound):
        self.tets, self.joints, self.sticky_pairs = [], [], []; self.center_of_mass, self.sound = np.zeros(3), sound
    def spawn(self, give_special_colors=False):
        new_tet = Tetrahedron(np.random.uniform(-80, 80, 3))
        if give_special_colors:
            cols = [(255,255,255), (0,0,0), (255,0,0), (0,255,255)]; random.shuffle(cols); new_tet.colors = cols
        self.tets.append(new_tet)
    def explode(self):
        self.joints.clear(); self.sticky_pairs.clear()
        for t in self.tets:
            t.pos_prev = t.pos - np.random.uniform(-10, 10, 3)
            t.local_prev = t.local - np.random.uniform(-5, 5, (4,3))
    def try_snap(self, A, ia, B, ib):
        for j in self.joints:
            if (j.A, j.ia, j.B, j.ib) in [(A,ia,B,ib), (B,ib,A,ia)]: return
        self.joints.append(VertexJoint(A, ia, B, ib))
        if self.sound: self.sound.play()
    def calculate_dynamic_center(self):
        if not self.tets: return np.zeros(3)
        if not self.joints: return sum(t.pos for t in self.tets) / len(self.tets)
        adj = {t: [] for t in self.tets};
        for j in self.joints: adj[j.A].append(j.B); adj[j.B].append(j.A)
        visited = set(); components = []
        for tet in self.tets:
            if tet not in visited:
                component = []; q = deque([tet]); visited.add(tet)
                while q:
                    curr = q.popleft(); component.append(curr)
                    for neighbor in adj[curr]:
                        if neighbor not in visited: visited.add(neighbor); q.append(neighbor)
                components.append(component)
        if not components: return np.zeros(3)
        max_size = max(len(c) for c in components)
        largest_components = [comp for comp in components if len(comp) == max_size]

        total_pos = np.zeros(3)
        total_count = 0
        for comp in largest_components:
            for tet in comp:
                total_pos += tet.pos
                total_count += 1

        return total_pos / total_count if total_count > 0 else np.zeros(3)

    def update(self, scaled_dt, unscaled_dt, time_scale):
        self.center_of_mass = self.calculate_dynamic_center()
        accelerations = {t: np.zeros(3) for t in self.tets}
        for t in self.tets:
            acc = -t.pos * K_ORIGIN_PULL; r_com = t.pos - self.center_of_mass; d_com = np.linalg.norm(r_com)
            if d_com < BATTERY_CHARGE_RADIUS:
                t.battery += BATTERY_CHARGE_RATE * scaled_dt
                spin_magnitude = min(MAX_SPIN_FORCE, t.battery * K_SPIN / (time_scale + 1e-6))
                spin_force_dir = np.cross(r_com, np.array([0.0, 1.0, 0.1]))
                acc += norm(spin_force_dir) * spin_magnitude; t.battery -= SPIN_ENERGY_COST * scaled_dt
            else: t.battery -= (d_com / BATTERY_DRAIN_RADIUS) * BATTERY_DRAIN_RATE * scaled_dt
            t.battery = np.clip(t.battery, 0, 1); acc += norm(r_com) * (t.battery - 0.5) * K_BATTERY_FORCE * d_com
            if np.linalg.norm(t.pos) > MAX_DIST_FROM_ORIGIN: acc += -norm(t.pos) * (np.linalg.norm(t.pos) - MAX_DIST_FROM_ORIGIN) * K_CONTAINMENT
            accelerations[t] = acc
        for t in self.tets: t.update_physics(scaled_dt, accelerations[t])

        for _ in range(2):
            for i, t1 in enumerate(self.tets):
                for t2 in self.tets[i+1:]:
                    delta = t2.pos - t1.pos; dist_sq = np.dot(delta, delta)
                    min_dist = COLLISION_RADIUS * 2
                    if dist_sq < min_dist * min_dist and dist_sq > 1e-6:
                        dist = math.sqrt(dist_sq); overlap = (min_dist - dist) * 0.5
                        correction = delta / dist * overlap; t1.pos -= correction; t2.pos += correction

        for pair in self.sticky_pairs[:]:
            t1, i1, t2, i2 = pair; p1, p2 = t1.verts()[i1], t2.verts()[i2]; delta = p2 - p1; dist = np.linalg.norm(delta)
            if dist < SNAP_DIST: self.try_snap(t1, i1, t2, i2); self.sticky_pairs.remove(pair)
            elif dist > 1e-6:
                correction_amount = STICKY_PULL_SPEED * unscaled_dt
                correction = delta / dist * min(correction_amount, dist) * 0.5
                t1.local[i1] += correction; t2.local[i2] -= correction
        for t in self.tets: t.apply_internal_forces()
        for j in self.joints: j.resolve()

# ============================
# UI & MAIN
# ============================
def show_intro(screen):
    start = pygame.time.get_ticks()
    while pygame.time.get_ticks() - start < 2000:
        for e in pygame.event.get():
            if e.type == pygame.QUIT: pygame.quit(); sys.exit()
        screen.fill((10,10,20)); font_lg = pygame.font.SysFont('Arial Black', min(WIDTH, HEIGHT)//8); font_sm = pygame.font.SysFont('Arial', min(WIDTH, HEIGHT)//25)
        title = font_lg.render("TET~CRAFT", True, (255, 50, 50)); sub = font_sm.render("A universe of your own!", True, (255, 255, 255))
        screen.blit(title, title.get_rect(center=(WIDTH//2, HEIGHT//2-50))); screen.blit(sub, sub.get_rect(center=(WIDTH//2, HEIGHT//2+50))); pygame.display.flip()
def show_void_screen(screen, world):
    font_lg = pygame.font.SysFont('Georgia', 40); font_sm = pygame.font.SysFont('Arial', 24)
    line1 = font_lg.render("Welcome to the void of understanding...", True, (200,200,200)); line2 = font_sm.render("(Press SPACE to begin)", True, (150,150,150))
    waiting = True
    while waiting:
        for e in pygame.event.get():
            if e.type == pygame.QUIT: pygame.quit(); sys.exit()
            if e.type == pygame.KEYDOWN and e.key == pygame.K_SPACE: world.spawn(give_special_colors=False); waiting = False
        screen.fill((10,10,20)); screen.blit(line1, line1.get_rect(center=(WIDTH//2, HEIGHT//2-30))); screen.blit(line2, line2.get_rect(center=(WIDTH//2, HEIGHT//2+30))); pygame.display.flip()
        clock.tick(15)

def main():
    global WIDTH, HEIGHT, clock
    os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "1"
    pygame.init()
    pygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=512)
    screen = pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE); pygame.display.set_caption("TET~CRAFT")
    clock = pygame.time.Clock(); font_l, font_s = pygame.font.SysFont('Georgia', 32), pygame.font.SysFont(None, 18)
    world, cam = World(generate_boing_sound()), Camera()

    flags, msgs, stars = {'t1': False, 't2': False, 'j1': False, 't3': False}, [], None
    dragging, rotating, last_mouse = None, False, (0,0)
    time_scale = 1.0; governor_active = False; reset_timer = None
    locked_sticky_target, sticky_unlock_timer = None, None
    frame_calc_times = deque(maxlen=30)


    def add_timed_message(text, y_offset=0, duration=4):
        msgs.append([text, y_offset, pygame.time.get_ticks() + duration * 1000])
    def reset_simulation(show_message=True):
        nonlocal flags, time_scale, stars
        world.tets.clear(); world.joints.clear(); world.sticky_pairs.clear()
        flags = {'t1': False, 't2': False, 'j1': False, 't3': False}; cam.__init__()
        time_scale = 1.0; stars = None
        if show_message: add_timed_message("Simulation Reset", duration=2)

    show_intro(screen)
    show_void_screen(screen, world)

    running = True
    while running:
        unscaled_dt = min(0.1, clock.tick(FPS) / 1000.0)
        scaled_dt = unscaled_dt * time_scale

        fps = clock.get_fps()
        if fps > 0 and fps < 45 and time_scale > 1.0: time_scale = max(1.0, time_scale * 0.99)
        governor_active = fps < 55

        hovered_vertex = None
        if not rotating:
            mx, my = pygame.mouse.get_pos(); hover_radius_sq = 8*8; min_dist_sq = float('inf')
            for t in world.tets:
                for i, v in enumerate(t.verts()):
                    px, py = cam.project(v); dist_sq = (mx - px)**2 + (my - py)**2
                    if dist_sq < hover_radius_sq and dist_sq < min_dist_sq: hovered_vertex = (t, i); min_dist_sq = dist_sq

        for e in pygame.event.get():
            if e.type == pygame.QUIT: running = False
            if e.type == pygame.VIDEORESIZE: WIDTH, HEIGHT = e.w, e.h; screen = pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE)
            if e.type == pygame.KEYDOWN:
                if e.key == pygame.K_BACKQUOTE:
                    if not reset_timer:
                        world.explode(); add_timed_message("RESETTING...", duration=2)
                        reset_timer = pygame.time.get_ticks() + 2000
                if e.key == pygame.K_SPACE:
                    if len(world.tets) < 2 or flags['j1']: world.spawn(give_special_colors=flags['j1'])
                if e.key == pygame.K_x: cam.pan = np.zeros(3)
            if e.type == pygame.MOUSEBUTTONDOWN:
                if e.button == 1 and hovered_vertex:
                    t, i = hovered_vertex; drag_depth = cam.get_transformed_z(t.verts()[i]); dragging = (t, i, drag_depth)
                    locked_sticky_target, sticky_unlock_timer = None, None
                if e.button == 3: rotating, last_mouse = True, e.pos
            if e.type == pygame.MOUSEBUTTONUP:
                if e.button == 1 and dragging and locked_sticky_target:
                    t_drag, i_drag, _ = dragging; t_snap, j_snap = locked_sticky_target; vertex_id = (t_drag, i_drag)
                    if not (t_drag == t_snap and i_drag == j_snap):
                        for pair in world.sticky_pairs[:]:
                            if (pair[0], pair[1]) == vertex_id or (pair[2], pair[3]) == vertex_id:
                                world.sticky_pairs.remove(pair)
                        world.sticky_pairs.append((t_drag, i_drag, t_snap, j_snap))
                if e.button == 1: dragging, locked_sticky_target, sticky_unlock_timer = None, None, None
                if e.button == 3: rotating = False
            if e.type == pygame.MOUSEWHEEL: cam.zoom(0.9 if e.y > 0 else 1.1)

        keys = pygame.key.get_pressed()
        pitch_delta = 0;
        if keys[pygame.K_w]: pitch_delta += ORBIT_SPEED * unscaled_dt;
        if keys[pygame.K_s]: pitch_delta -= ORBIT_SPEED * unscaled_dt
        if pitch_delta != 0:
            new_pitch = cam.pitch + pitch_delta
            if new_pitch > math.pi/2: cam.yaw += math.pi; cam.pitch = math.pi - new_pitch
            elif new_pitch < -math.pi/2: cam.yaw += math.pi; cam.pitch = -math.pi - new_pitch
            else: cam.pitch = new_pitch
        if keys[pygame.K_a]: cam.yaw -= ORBIT_SPEED * unscaled_dt;
        if keys[pygame.K_d]: cam.yaw += ORBIT_SPEED * unscaled_dt
        if keys[pygame.K_r]: cam.zoom(1.0 - ZOOM_SPEED * unscaled_dt);
        if keys[pygame.K_f]: cam.zoom(1.0 + ZOOM_SPEED * unscaled_dt)
        if keys[pygame.K_q] or keys[pygame.K_e]:
            pan_dir = 1 if keys[pygame.K_q] else -1; cam_right = np.array([math.cos(cam.yaw), 0, -math.sin(cam.yaw)])
            cam.pan += cam_right * pan_dir * PAN_SPEED * unscaled_dt
        if keys[pygame.K_c] and not governor_active: time_scale = min(10.0, time_scale + 2.0 * unscaled_dt)
        if keys[pygame.K_z]: time_scale = max(0.1, time_scale - 2.0 * unscaled_dt)

        if rotating:
            mx,my=pygame.mouse.get_pos(); dx,dy=mx-last_mouse[0],my-last_mouse[1]
            cam.yaw += dx*0.005; cam.pitch = np.clip(cam.pitch - dy*0.005, -math.pi/2, math.pi/2); last_mouse=(mx,my)
            hover_radius_sq = 8*8; min_dist_sq = float('inf'); hovered_vertex = None
            for t in world.tets:
                for i, v in enumerate(t.verts()):
                    px, py = cam.project(v); dist_sq = (mx - px)**2 + (my - py)**2
                    if dist_sq < hover_radius_sq and dist_sq < min_dist_sq: hovered_vertex = (t, i); min_dist_sq = dist_sq


        if dragging:
            t_drag, i_drag, drag_depth = dragging; mouse_pos_3d = cam.unproject(pygame.mouse.get_pos(), drag_depth)
            delta = mouse_pos_3d - t_drag.verts()[i_drag]; t_drag.local[i_drag] += delta * MOUSE_PULL_STRENGTH
            t_drag.pos += delta * BODY_PULL_STRENGTH

            screen_pos_dragged = np.array(cam.project(t_drag.verts()[i_drag])); mouse_pos_2d = np.array(pygame.mouse.get_pos())
            current_hover_target = None; best_dist = 50
            for t_target in world.tets:
                if not pygame.mouse.get_pressed()[0]: break
                for j_target, v_target in enumerate(t_target.verts()):
                    if t_target == t_drag and j_target == i_drag: continue
                    dist = dist_point_to_ray(np.array(cam.project(v_target)), screen_pos_dragged, mouse_pos_2d)
                    if dist < best_dist: best_dist, current_hover_target = dist, (t_target, j_target)

            if current_hover_target:
                if locked_sticky_target != current_hover_target:
                    sticky_unlock_timer = pygame.time.get_ticks() + 5000
                locked_sticky_target = current_hover_target

            if sticky_unlock_timer and pygame.time.get_ticks() > sticky_unlock_timer:
                if not current_hover_target:
                    locked_sticky_target = None
                    sticky_unlock_timer = None

        if rotating and hovered_vertex:
            paused_tet = hovered_vertex[0]
            paused_tet.pos_prev = paused_tet.pos
            paused_tet.local_prev = paused_tet.local

        start_calc_time = pygame.time.get_ticks()
        world.update(scaled_dt, unscaled_dt, time_scale)
        end_calc_time = pygame.time.get_ticks()
        frame_calc_times.append(end_calc_time - start_calc_time)

        if hovered_vertex: t, i = hovered_vertex; t.local[i] = t.local_prev[i]
        if reset_timer and pygame.time.get_ticks() > reset_timer: reset_simulation(); reset_timer = None

        # --- EVENT MESSAGES ---
        if len(world.tets) == 1 and not flags['t1']:
            flags['t1'] = True; add_timed_message("LET THERE BE TIME...")

        if len(world.tets) == 2 and not flags['t2']:
            flags['t2'] = True
            add_timed_message("LET THERE BE SEPARATION!", -20)
            add_timed_message("And let it chase time ever into the future.", 20)

        if len(world.tets) >= 2 and len(world.joints) >= 1 and not flags['j1']:
            flags['j1'] = True
            add_timed_message("LET THERE BE LIGHT", -20)
            add_timed_message("To grow old and wise!", 20)
            for t in world.tets:
                if t.colors is None:
                    cols = [(255,255,255), (0,0,0), (255,0,0), (0,255,255)]; random.shuffle(cols); t.colors = cols

        if len(world.tets) >= 3 and flags['j1'] and not flags['t3']:
            flags['t3'] = True; add_timed_message("...and, LET THERE BE DARKNESS!", -20); add_timed_message("So light can be seen!", 20)
            if not stars: stars = [((random.randint(0, WIDTH), random.randint(0, HEIGHT)), random.randint(50, 150)) for _ in range(500)]

        cam.pan = world.center_of_mass
        light_phase = flags['j1'] and not flags['t3']

        # --- RENDERING ---
        screen.fill((255,255,255) if light_phase else (10,10,20))
        if stars and not light_phase:
            for pos, bright in stars: screen.set_at(pos, (bright, bright, bright))

        axis_colors = [(255, 0, 0), (255, 255, 255), (0, 255, 255)]
        for i, color in enumerate(axis_colors):
            pos_vec, neg_vec = np.zeros(3), np.zeros(3); pos_vec[i], neg_vec[i] = AXIS_LEN, -AXIS_LEN
            pygame.draw.line(screen, color, cam.project(neg_vec), cam.project(pos_vec), 2)

        orange = (255, 140, 0)
        gray = (100, 100, 100)

        if dragging and locked_sticky_target:
            t_drag, i_drag, _ = dragging; t_snap, j_snap = locked_sticky_target
            start_pos = cam.project(t_drag.verts()[i_drag]); end_pos = cam.project(t_snap.verts()[j_snap])
            pygame.draw.line(screen, orange, start_pos, end_pos, 2)

        for t1, i1, t2, i2 in world.sticky_pairs:
            p1, p2 = cam.project(t1.verts()[i1]), cam.project(t2.verts()[i2]); pygame.draw.line(screen, orange, p1, p2, 1)

        for j in world.joints:
            p1 = cam.project(j.A.verts()[j.ia]); p2 = cam.project(j.B.verts()[j.ib])
            pygame.draw.line(screen, gray, p1, p2, 1)

        for t in sorted(world.tets, key=lambda t: cam.get_transformed_z(t.pos), reverse=True):
            world_verts, screen_pts = t.verts(), [cam.project(v) for v in t.verts()]
            sorted_faces = sorted(t.faces, key=lambda face: sum(cam.get_transformed_z(world_verts[i]) for i in face), reverse=True)

            if t.colors:
                for face_indices in sorted_faces:
                    face_pts = [screen_pts[i] for i in face_indices]; original_face_index = t.faces.index(face_indices)
                    pygame.draw.polygon(screen, t.colors[original_face_index], face_pts)
                    pygame.draw.aalines(screen, (0,0,0), True, face_pts)
            else:
                bright_color = np.array((200, int(200*t.battery), 255-int(200*t.battery)))
                ambient_color = bright_color * 0.35
                for face_indices in sorted_faces:
                    pygame.draw.polygon(screen, np.clip(ambient_color, 0, 255), [screen_pts[i] for i in face_indices])
                for i, j in t.edges: pygame.draw.line(screen, bright_color, screen_pts[i], screen_pts[j], 1)

            vert_col = (0,0,0) if light_phase else (255,255,255)
            for p in screen_pts: pygame.draw.circle(screen, vert_col, p, 4)
        if hovered_vertex:
            t, i = hovered_vertex; p = cam.project(t.verts()[i]); pygame.draw.circle(screen, (255,255,0), p, 8, 2)

        now = pygame.time.get_ticks(); msgs = [m for m in msgs if now < m[2]]; text_color = (0,0,0) if light_phase else (200,200,200)
        for text_string, y_offset, end_time in msgs:
            surf = font_l.render(text_string, True, text_color); surf.set_alpha(max(0, min(255, (end_time - now) / 1000 * 255)))
            screen.blit(surf, surf.get_rect(center=(WIDTH//2, HEIGHT//2 + y_offset)))

        target_frame_time_ms = 1000.0 / FPS
        if frame_calc_times:
            avg_calc_time = sum(frame_calc_times) / len(frame_calc_times)
            usage_ratio = np.clip(avg_calc_time / target_frame_time_ms, 0, 1)

            bar_rect = pygame.Rect(10, HEIGHT - 50, 20, 40)
            pygame.draw.rect(screen, (0,0,0), bar_rect)

            yellow_height = int(bar_rect.height * usage_ratio)
            yellow_rect = pygame.Rect(bar_rect.x, bar_rect.bottom - yellow_height, bar_rect.width, yellow_height)
            pygame.draw.rect(screen, (255,255,0), yellow_rect)

        time_text = f"Z/C Time ({time_scale:.1f}x)";
        if governor_active and time_scale > 1: time_text += " (GOV)"
        leg_text = f"WASDQE/RMB View | RF/Wheel Zoom | ~ Reset | X Center | {time_text}"
        leg = font_s.render(leg_text, True, (0, 255, 255))
        # ### FIXED ### Typo removed from this line.
        screen.blit(leg, (WIDTH//2 - leg.get_width()//2, HEIGHT-25))
        pygame.display.flip()

    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()









---------- v1.1




import pygame
import numpy as np
import math
import random
import sys
import os
import json
from collections import deque
import socket
import threading
import select
import time

# ============================
# CONFIG
# ============================
WIDTH, HEIGHT = 1200, 800
FPS = 60

EDGE_LEN = 2.0
SNAP_DIST = 0.75
STICKY_PULL_SPEED = 3.0
AXIS_LEN = 20

DEFAULT_PORT = 65420
PORT_RANGE = range(DEFAULT_PORT, DEFAULT_PORT + 10)
DISCOVERY_PORT = 65419

# --- VERLET PHYSICS CONSTANTS ---
DAMPING = 0.995
MOUSE_PULL_STRENGTH = 0.0005
BODY_PULL_STRENGTH = 0.0008
COLLISION_RADIUS = EDGE_LEN * 0.75

# --- BEHAVIOR CONSTANTS ---
K_ORIGIN_PULL = 0.00005
K_SPIN = 1.0
MAX_SPIN_FORCE = K_SPIN * 15
SPIN_ENERGY_COST = 0.08
K_ALIGN = 4.0
K_BATTERY_FORCE = 0.00015
K_CONTAINMENT = 0.001

# --- CAMERA CONTROL CONSTANTS ---
ORBIT_SPEED = 1.5
PAN_SPEED = 200.0
ZOOM_SPEED = 1.05
FOCAL_LENGTH = 650.0
DEFAULT_CAM_DIST = 70.0
MIN_ZOOM_DIST = DEFAULT_CAM_DIST / 100.0  # 100x zoom
MAX_ZOOM_DIST = DEFAULT_CAM_DIST / 0.01  # 0.01x zoom

BATTERY_CHARGE_RADIUS = 50
BATTERY_DRAIN_RADIUS = 420
BATTERY_CHARGE_RATE = 0.03
BATTERY_DRAIN_RATE = 0.005

MAX_DIST_FROM_ORIGIN = 1500
SAVE_FILENAME = "tetcraft_save.json"

class NumpyEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, np.ndarray): return obj.tolist()
        if isinstance(obj, np.integer): return int(obj)
        if isinstance(obj, np.floating): return float(obj)
        return json.JSONEncoder.default(self, obj)

# ============================
# CAMERA & CORE CLASSES
# ============================
class Camera:
    def __init__(self):
        self.yaw, self.pitch, self.dist, self.pan = 0.0, 0.35, DEFAULT_CAM_DIST, np.zeros(3)
    def get_transformed_z(self, v):
        v = v - self.pan; cy, sy = math.cos(self.yaw), math.sin(self.yaw); cp, sp = math.cos(self.pitch), math.sin(self.pitch)
        x, y, z = v; zz = sy*x + cy*z; zz2 = sp*y + cp*zz
        return zz2
    def project(self, v):
        global WIDTH, HEIGHT
        v = v - self.pan; cy, sy = math.cos(self.yaw), math.sin(self.yaw); cp, sp = math.cos(self.pitch), math.sin(self.pitch)
        x, y, z = v; x, z = cy*x - sy*z, sy*x + cy*z; y, z = cp*y - sp*z, sp*y + cp*z
        depth = self.dist + z
        if depth <= 0.1: return (-1000, -1000)
        scale = FOCAL_LENGTH / depth
        return (WIDTH//2 + int(x * scale), HEIGHT//2 - int(y * scale))
    def unproject(self, screen_pos, depth_z):
        global WIDTH, HEIGHT; mx, my = screen_pos
        scale = FOCAL_LENGTH / (self.dist + depth_z + 1e-9)
        if abs(scale) < 1e-9: return self.pan
        x_cam = (mx - WIDTH // 2) / scale; y_cam = -(my - HEIGHT // 2) / scale
        cy, sy = math.cos(self.yaw), math.sin(self.yaw); cp, sp = math.cos(self.pitch), math.sin(self.pitch)
        y_rot, z_rot = cp * y_cam + sp * depth_z, -sp * y_cam + cp * depth_z
        x_world, z_world = cy * x_cam + sy * z_rot, -sy * x_cam + cy * z_rot
        return np.array([x_world, y_rot, z_world]) + self.pan
    def zoom(self, factor): self.dist = np.clip(self.dist * factor, MIN_ZOOM_DIST, MAX_ZOOM_DIST)
    def get_state(self): return {'yaw': self.yaw, 'pitch': self.pitch, 'dist': self.dist, 'pan': self.pan}
    def set_state(self, state): self.yaw, self.pitch, self.dist, self.pan = state['yaw'], state['pitch'], state['dist'], np.array(state['pan'])

def norm(v):
    n = np.linalg.norm(v); return v / n if n > 1e-9 else np.zeros_like(v)
def dist_point_to_line_segment(p, a, b):
    p, a, b = np.array(p), np.array(a), np.array(b)
    ap, ab = p - a, b - a
    t = np.dot(ap, ab) / (np.dot(ab, ab) + 1e-9)
    t = max(0, min(1, t))
    closest = a + t * ab
    return np.linalg.norm(p - closest)

def generate_boing_sound():
    mixer_settings = pygame.mixer.get_init()
    if mixer_settings is None: return None
    sample_rate, _, channels = mixer_settings; duration = 0.2; num_samples = int(duration * sample_rate)
    t = np.linspace(0, duration, num_samples, False); freq = np.linspace(660.0, 220.0, num_samples); wave = np.sin(2 * np.pi * freq * t) * np.exp(-t * 10)
    sound_array = (wave * 32767).astype(np.int16)
    if channels == 2: sound_array = np.column_stack((sound_array, sound_array))
    return pygame.sndarray.make_sound(sound_array)

class VertexJoint:
    def __init__(self, A, ia, B, ib): self.A, self.ia, self.B, self.ib = A, ia, B, ib
    def resolve(self):
        p1, p2 = self.A.verts()[self.ia], self.B.verts()[self.ib]; delta = p2 - p1; dist = np.linalg.norm(delta)
        if dist > 1e-6:
            diff = dist / dist * 0.5; self.A.local[self.ia] += delta * diff; self.B.local[self.ib] -= delta * diff

class Tetrahedron:
    def __init__(self, pos):
        self.pos = np.array(pos, float); self.pos_prev = self.pos.copy()
        self.battery, self.colors = random.uniform(0.3, 0.6), None
        self.label = ""
        r, a = EDGE_LEN*math.sqrt(3/8), EDGE_LEN/math.sqrt(3)
        self.rest = np.array([[0,0,r], [EDGE_LEN/2,-a/2,-r/3], [-EDGE_LEN/2,-a/2,-r/3], [0,a,-r/3]])
        self.local = self.rest.copy(); self.local_prev = self.local.copy()
        self.edges = [(i, j) for i in range(4) for j in range(i+1, 4)]; self.faces = [(1, 2, 3), (0, 1, 2), (0, 2, 3), (0, 1, 3)]
        self.id = id(self)
    def verts(self): return self.local + self.pos
    def update_physics(self, dt, acceleration):
        pos_temp = self.pos.copy(); self.pos += (self.pos - self.pos_prev) * DAMPING + acceleration * dt * dt; self.pos_prev = pos_temp
        local_temp = self.local.copy(); self.local += (self.local - self.local_prev) * DAMPING; self.local_prev = local_temp
    def apply_internal_forces(self):
        self.local -= np.mean(self.local, axis=0)
        for _ in range(3):
            for i, j in self.edges:
                p1, p2 = self.local[i], self.local[j]; delta = p2 - p1; dist = np.linalg.norm(delta)
                if dist > 1e-6: diff = (dist - EDGE_LEN) / dist * 0.5; self.local[i] += delta * diff; self.local[j] -= delta * diff

class World:
    def __init__(self, sound):
        self.tets, self.joints, self.sticky_pairs = [], [], []; self.center_of_mass, self.sound = np.zeros(3), sound
    def spawn(self, give_special_colors=False):
        new_tet = Tetrahedron(np.random.uniform(-8, 8, 3) + self.center_of_mass)
        if give_special_colors:
            cols = [(255,255,255), (0,0,0), (255,0,0), (0,255,255)]; random.shuffle(cols); new_tet.colors = cols
        self.tets.append(new_tet)
    def explode(self):
        self.joints.clear(); self.sticky_pairs.clear()
        for t in self.tets:
            t.pos_prev = t.pos - np.random.uniform(-1, 1, 3)
            t.local_prev = t.local - np.random.uniform(-0.5, 0.5, (4,3))
    def try_snap(self, A, ia, B, ib):
        for j in self.joints:
            if (j.A.id, j.ia, j.B.id, j.ib) in [(A.id,ia,B.id,ib), (B.id,ib,A.id,ia)]: return
        self.joints.append(VertexJoint(A, ia, B, ib))
        if self.sound: self.sound.play()
    def calculate_dynamic_center(self):
        if not self.tets: return np.zeros(3)
        if not self.joints: return sum(t.pos for t in self.tets) / len(self.tets)
        tet_map = {t.id: t for t in self.tets}; adj = {t.id: [] for t in self.tets}
        for j in self.joints:
            if j.A.id in adj and j.B.id in adj:
                adj[j.A.id].append(j.B.id); adj[j.B.id].append(j.A.id)
        visited = set(); components = []
        for tet_id in tet_map:
            if tet_id not in visited:
                component = []; q = deque([tet_id]); visited.add(tet_id)
                while q:
                    curr_id = q.popleft(); component.append(tet_map[curr_id])
                    for neighbor_id in adj.get(curr_id, []):
                        if neighbor_id not in visited: visited.add(neighbor_id); q.append(neighbor_id)
                components.append(component)
        if not components: return np.zeros(3)
        max_size = max(len(c) for c in components if c) if any(components) else 0
        if max_size == 0: return sum(t.pos for t in self.tets) / len(self.tets)
        largest_components = [comp for comp in components if len(comp) == max_size]
        total_pos = np.zeros(3); total_count = 0
        for comp in largest_components:
            for tet in comp: total_pos += tet.pos; total_count += 1
        return total_pos / total_count if total_count > 0 else np.zeros(3)
    def update(self, scaled_dt, unscaled_dt, time_scale):
        self.center_of_mass = self.calculate_dynamic_center()
        accelerations = {t: np.zeros(3) for t in self.tets}
        for t in self.tets:
            acc = -t.pos * K_ORIGIN_PULL; r_com = t.pos - self.center_of_mass; d_com = np.linalg.norm(r_com)
            dist_from_origin = np.linalg.norm(t.pos)

            if d_com < BATTERY_CHARGE_RADIUS:
                t.battery += BATTERY_CHARGE_RATE * scaled_dt
            else:
                drain_multiplier = 1.0 + (dist_from_origin / BATTERY_DRAIN_RADIUS)
                t.battery -= BATTERY_DRAIN_RATE * drain_multiplier * scaled_dt

            spin_magnitude = min(MAX_SPIN_FORCE, t.battery * K_SPIN / (time_scale + 1e-6))
            spin_force_dir = np.cross(r_com, np.array([0.0, 1.0, 0.1]))
            acc += norm(spin_force_dir) * spin_magnitude; t.battery -= SPIN_ENERGY_COST * scaled_dt

            t.battery = np.clip(t.battery, 0, 1); acc += norm(r_com) * (t.battery - 0.5) * K_BATTERY_FORCE * d_com

            if dist_from_origin > MAX_DIST_FROM_ORIGIN:
                spring_force = (dist_from_origin - MAX_DIST_FROM_ORIGIN) * K_CONTAINMENT * (t.battery + 0.1)
                acc += -norm(t.pos) * spring_force

            accelerations[t] = acc
        for t in self.tets: t.update_physics(scaled_dt, accelerations[t])
        for _ in range(2):
            for i, t1 in enumerate(self.tets):
                for t2 in self.tets[i+1:]:
                    delta = t2.pos - t1.pos; dist_sq = np.dot(delta, delta)
                    min_dist = COLLISION_RADIUS * 2
                    if dist_sq < min_dist * min_dist and dist_sq > 1e-6:
                        dist = math.sqrt(dist_sq); overlap = (min_dist - dist) * 0.5
                        correction = delta / dist * overlap; t1.pos -= correction; t2.pos += correction
        for pair in self.sticky_pairs[:]:
            t1, i1, t2, i2 = pair; p1, p2 = t1.verts()[i1], t2.verts()[i2]; delta = p2 - p1; dist = np.linalg.norm(delta)
            if dist < SNAP_DIST: self.try_snap(t1, i1, t2, i2); self.sticky_pairs.remove(pair)
            elif dist > 1e-6:
                correction_amount = STICKY_PULL_SPEED * unscaled_dt
                correction = delta / dist * min(correction_amount, dist) * 0.5
                t1.local[i1] += correction; t2.local[i2] -= correction
        for t in self.tets: t.apply_internal_forces()
        for j in self.joints: j.resolve()
    def get_state(self):
        tet_states = [{'id': t.id, 'pos': t.pos, 'pos_prev': t.pos_prev, 'local': t.local, 'local_prev': t.local_prev, 'battery': t.battery, 'colors': t.colors, 'label': t.label} for t in self.tets]
        joint_states = [{'A_id': j.A.id, 'ia': j.ia, 'B_id': j.B.id, 'ib': j.ib} for j in self.joints]
        return {'tets': tet_states, 'joints': joint_states}
    def set_state(self, state):
        self.tets.clear(); self.joints.clear(); self.sticky_pairs.clear(); tet_map = {}
        for ts in state['tets']:
            t = Tetrahedron(ts['pos']); t.id = ts['id']; t.pos_prev = np.array(ts['pos_prev']);
            t.local = np.array(ts['local']); t.local_prev = np.array(ts['local_prev'])
            t.battery = ts['battery']; t.colors = ts['colors']
            t.label = ts.get('label', "")
            self.tets.append(t); tet_map[t.id] = t
        for js in state['joints']:
            if js['A_id'] in tet_map and js['B_id'] in tet_map:
                self.joints.append(VertexJoint(tet_map[js['A_id']], js['ia'], tet_map[js['B_id']], js['ib']))

net_avatars = {}; net_messages = deque(maxlen=5)
game_mode = 'single_player'; host_instance, guest_instance = None, None

# ============================
# UI & NETWORKING
# ============================
def show_intro(screen):
    start = pygame.time.get_ticks()
    while pygame.time.get_ticks() - start < 2000:
        for e in pygame.event.get():
            if e.type == pygame.QUIT: pygame.quit(); sys.exit()
        screen.fill((10,10,20)); font_lg = pygame.font.SysFont('Arial Black', min(WIDTH, HEIGHT)//8); font_sm = pygame.font.SysFont('Arial', min(WIDTH, HEIGHT)//25)
        title = font_lg.render("TET~CRAFT", True, (255, 50, 50)); sub = font_sm.render("A universe of your own!", True, (255, 255, 255))
        screen.blit(title, title.get_rect(center=(WIDTH//2, HEIGHT//2-50))); screen.blit(sub, sub.get_rect(center=(WIDTH//2, HEIGHT//2+50))); pygame.display.flip()

def show_void_screen(screen, world):
    font_lg = pygame.font.SysFont('Georgia', 40); font_sm = pygame.font.SysFont('Arial', 24)
    line1 = font_lg.render("Welcome to the void of understanding...", True, (200,200,200)); line2 = font_sm.render("(Press SPACE to begin)", True, (150,150,150))
    waiting = True
    while waiting:
        for e in pygame.event.get():
            if e.type == pygame.QUIT: pygame.quit(); sys.exit()
            if e.type == pygame.KEYDOWN and e.key == pygame.K_SPACE: world.spawn(give_special_colors=False); waiting = False
        screen.fill((10,10,20)); screen.blit(line1, line1.get_rect(center=(WIDTH//2, HEIGHT//2-30))); screen.blit(line2, line2.get_rect(center=(WIDTH//2, HEIGHT//2+30))); pygame.display.flip()
        clock.tick(15)

def draw_avatar(screen, cam, pos, color):
    r, a = EDGE_LEN*math.sqrt(3/8), EDGE_LEN/math.sqrt(3)
    base_verts = np.array([[0,0,r], [EDGE_LEN/2,-a/2,-r/3], [-EDGE_LEN/2,-a/2,-r/3], [0,a,-r/3]])
    verts1 = base_verts + pos; verts2 = np.array([v * [1,-1,1] for v in base_verts]) + pos
    all_verts = np.vstack([verts1, np.array([verts2[0], verts2[2], verts2[1], verts2[3]])])
    screen_pts = [cam.project(v) for v in all_verts]
    faces = [(0,1,3), (0,2,1), (0,3,2), (1,2,3), (4,5,7), (4,6,5), (4,7,6), (5,6,7)]
    sorted_faces = sorted(faces, key=lambda face: sum(cam.get_transformed_z(all_verts[i]) for i in face), reverse=True)
    for face_indices in sorted_faces:
        face_pts = [screen_pts[i] for i in face_indices]
        try: pygame.draw.polygon(screen, color, face_pts); pygame.draw.aalines(screen, (20,20,20), True, face_pts)
        except: pass

def get_user_input(screen, prompt, initial_text=""):
    input_text = initial_text; font = pygame.font.SysFont(None, 32); active = True
    while active:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN: active = False
                elif event.key == pygame.K_BACKSPACE: input_text = input_text[:-1]
                else: input_text += event.unicode
        screen.fill((10,10,20))
        prompt_surf = font.render(prompt, True, (255,255,255)); input_surf = font.render(input_text, True, (255,255,0))
        screen.blit(prompt_surf, (WIDTH//2 - prompt_surf.get_width()//2, HEIGHT//2 - 50))
        screen.blit(input_surf, (WIDTH//2 - input_surf.get_width()//2, HEIGHT//2))
        pygame.display.flip(); clock.tick(30)
    return input_text

def send_msg(sock, msg_dict):
    try:
        msg_json = json.dumps(msg_dict, cls=NumpyEncoder).encode('utf-8'); msg_len = len(msg_json).to_bytes(4, 'big')
        sock.sendall(msg_len + msg_json)
    except (ConnectionResetError, BrokenPipeError, OSError): pass

def recv_msg(sock):
    try:
        len_bytes = sock.recv(4)
        if not len_bytes: return None
        msg_len = int.from_bytes(len_bytes, 'big'); data = b''
        while len(data) < msg_len:
            packet = sock.recv(msg_len - len(data))
            if not packet: return None
            data += packet
        return json.loads(data.decode('utf-8'))
    except (ConnectionResetError, json.JSONDecodeError, ValueError, OSError): return None

class Host:
    def __init__(self, world, add_msg_fn, port=None):
        self.world = world; self.add_msg = add_msg_fn; self.clients = {}; self.lock = threading.Lock()
        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM); self.port = 0
        ports_to_try = [port] if port else PORT_RANGE
        for p in ports_to_try:
            try: self.server.bind(('', p)); self.port = p; break
            except OSError: continue
        if self.port == 0: self.server.bind(('', 0)); self.port = self.server.getsockname()[1]
        self.running = True
        threading.Thread(target=self.discovery_thread, daemon=True).start()
        threading.Thread(target=self.start, daemon=True).start()
    def discovery_thread(self):
        udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); udp_sock.bind(('', DISCOVERY_PORT))
        while self.running:
            try:
                data, addr = udp_sock.recvfrom(1024)
                if data == b"DISCOVER_TETCRAFT_HOST":
                    response = f"TETCRAFT_HOST_HERE:{self.port}".encode('utf-8')
                    udp_sock.sendto(response, addr)
            except OSError: break
    def start(self):
        self.server.listen(); hostname = socket.gethostbyname(socket.gethostname())
        print(f"### HOSTING on {hostname}:{self.port} ###")
        while self.running:
            try:
                client_sock, addr = self.server.accept(); client_id = f"guest_{addr[0]}:{addr[1]}"
                print(f"Accepted connection from {addr}")
                with self.lock:
                    self.clients[client_sock] = {'id': client_id, 'addr': addr}
                    net_avatars[client_id] = {'pos': [0,0,0], 'color': [random.randint(50,200) for _ in range(3)]}
                threading.Thread(target=self.handle_client, args=(client_sock, client_id), daemon=True).start()
            except OSError: break
    def handle_client(self, sock, client_id):
        while self.running:
            msg = recv_msg(sock)
            if msg is None: break
            if msg['type'] == 'cam_update':
                with self.lock:
                    if client_id in net_avatars: net_avatars[client_id]['pos'] = np.array(msg['data']['pan'])
            elif msg['type'] == 'chat': self.add_msg(f"<{client_id.split(':')[0]}>: {msg['data']}")
            elif msg['type'] == 'set_label':
                with self.lock:
                    for t in self.world.tets:
                        if t.id == msg['id']: t.label = msg['label']; break
        print(f"Client {client_id} disconnected.")
        with self.lock: self.clients.pop(sock, None); net_avatars.pop(client_id, None)
        sock.close()
    def broadcast_state(self):
        state = self.world.get_state(); full_state = {'type': 'world_state', 'data': {'world': state, 'avatars': net_avatars}}
        with self.lock:
            for sock in list(self.clients.keys()): send_msg(sock, full_state)
    def stop(self):
        self.running = False
        with self.lock:
            for sock in self.clients: sock.close()
        self.server.close()

class Guest:
    def __init__(self, host_ip, port, world, cam, add_msg_fn):
        self.world = world; self.cam = cam; self.add_msg = add_msg_fn
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM); self.sock.connect((host_ip, port))
        self.host_id = f"host_{host_ip}:{port}"; self.running = True; self.latest_world_state = None
        threading.Thread(target=self.listen, daemon=True).start()
    def listen(self):
        global net_avatars
        while self.running:
            msg = recv_msg(self.sock)
            if msg is None: self.add_msg("Disconnected from host."); self.running = False; break
            if msg['type'] == 'world_state':
                self.latest_world_state = msg['data']['world']
                host_avatar = {'pos': msg['data']['world'].get('center_of_mass', [0,0,0]), 'color': (50, 50, 255)}
                net_avatars = {self.host_id: host_avatar}
            elif msg['type'] == 'chat': self.add_msg(f"<HOST>: {msg['data']}")
    def send_cam_update(self): send_msg(self.sock, {'type': 'cam_update', 'data': self.cam.get_state()})
    def send_chat(self, text): send_msg(self.sock, {'type': 'chat', 'data': text})
    def send_label(self, tet_id, label): send_msg(self.sock, {'type': 'set_label', 'id': tet_id, 'label': label})
    def stop(self): self.running = False; self.sock.close()

def main():
    print("TET~CRAFT Initializing...")
    print("CLI Options:")
    print("  -connect <ip>:<port>   (Connect directly to a server)")
    print("  -listen <port>         (Launch directly as a host on a port)")

    cli_connect_addr, cli_listen_port = None, None
    if len(sys.argv) > 1:
        if sys.argv[1] == '-connect' and len(sys.argv) > 2: cli_connect_addr = sys.argv[2]
        if sys.argv[1] == '-listen' and len(sys.argv) > 2: cli_listen_port = int(sys.argv[2])
        elif sys.argv[1] == '-listen': cli_listen_port = DEFAULT_PORT

    global WIDTH, HEIGHT, clock, game_mode, host_instance, guest_instance, net_avatars, net_messages
    os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "1"
    pygame.init(); pygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=512)
    screen = pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE); pygame.display.set_caption("TET~CRAFT")
    clock = pygame.time.Clock(); font_l = pygame.font.SysFont('Georgia', 32); font_s = pygame.font.SysFont(None, 24)
    world, cam = World(generate_boing_sound()), Camera()
    flags = {'t1': False, 't2': False, 'j1': False, 't3': False}; msgs, stars = [], None
    dragging, rotating, last_mouse = None, False, (0,0); time_scale = 1.0; governor_active = False; reset_timer = None
    locked_sticky_target, sticky_unlock_timer = None, None; frame_count = 0
    rmb_down_timer = None; rmb_start_pos = None

    def add_timed_message(text, y_offset=0, duration=4): msgs.append([text, y_offset, pygame.time.get_ticks() + duration * 1000])
    def add_network_message(text): net_messages.append([text, time.time() + 8])
    def reset_simulation(show_message=True):
        nonlocal flags, time_scale, stars, world, cam, dragging, rotating, locked_sticky_target, sticky_unlock_timer
        global game_mode, host_instance, guest_instance, net_avatars, net_messages
        world.tets.clear(); world.joints.clear(); world.sticky_pairs.clear()
        flags = {'t1': False, 't2': False, 'j1': False, 't3': False}; cam.__init__()
        time_scale = 1.0; stars = None; game_mode = 'single_player'
        dragging, rotating, locked_sticky_target, sticky_unlock_timer = None, False, None, None
        net_avatars.clear(); net_messages.clear()
        if host_instance: host_instance.stop(); host_instance = None
        if guest_instance: guest_instance.stop(); guest_instance = None
        if show_message: add_timed_message("Simulation Reset", duration=2)
    def save_world_to_file():
        if not world.tets: return
        with open(SAVE_FILENAME, 'w') as f: json.dump(world.get_state(), f, cls=NumpyEncoder, indent=2)
        add_timed_message(f"Saved universe to {SAVE_FILENAME}", duration=3)

    def connect_as_guest(host_ip, port):
        global guest_instance, game_mode
        try:
            save_world_to_file();
            guest_instance = Guest(host_ip, int(port), world, cam, add_network_message)
            game_mode = 'guest'; add_timed_message(f"Connected to {host_ip}:{port}", duration=3)
            world.tets.clear(); world.joints.clear(); world.sticky_pairs.clear()
            return True
        except Exception as e:
            add_timed_message(f"Failed to connect: {e}", duration=4)
            return False

    def discover_and_join():
        global guest_instance, game_mode
        if game_mode != 'single_player': return
        host_addr = None

        add_timed_message("Scanning localhost for hosts...", duration=1); pygame.display.flip()
        for port in PORT_RANGE:
            try:
                with socket.create_connection(('127.0.0.1', port), timeout=0.05) as s:
                    host_addr = ('127.0.0.1', port); break
            except (socket.timeout, ConnectionRefusedError): continue

        if not host_addr:
            add_timed_message("Discovering hosts on LAN...", duration=2); pygame.display.flip()
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1); sock.settimeout(2.0)
                try:
                    local_ip = socket.gethostbyname(socket.gethostname())
                    broadcast_ip = '.'.join(local_ip.split('.')[:-1]) + '.255'
                    sock.sendto(b"DISCOVER_TETCRAFT_HOST", (broadcast_ip, DISCOVERY_PORT))
                    data, addr = sock.recvfrom(1024)
                    if data.startswith(b"TETCRAFT_HOST_HERE:"):
                        port = int(data.split(b':')[1]); host_addr = (addr[0], port)
                except socket.timeout: pass

        if host_addr:
            connect_as_guest(host_addr[0], host_addr[1])
        else:
            add_timed_message("No host found, please enter manually.", duration=2)
            pygame.time.wait(1000)
            user_input = get_user_input(screen, "Enter Host IP:Port (e.g. 192.168.1.5:65420):")
            if user_input:
                ip, port = user_input, DEFAULT_PORT
                if ':' in user_input: ip, port = user_input.split(':')
                connect_as_guest(ip, port)

    def initiate_host_mode(port=None):
        global host_instance, game_mode
        if game_mode != 'single_player': return
        host_instance = Host(world, add_network_message, port); game_mode = 'host'
        add_timed_message("Hosting Mode Activated", duration=3)

    show_intro(screen)
    loaded_from_save = False
    if os.path.exists(SAVE_FILENAME) and not (cli_connect_addr or cli_listen_port):
        try:
            with open(SAVE_FILENAME, 'r') as f:
                state = json.load(f)
                world.set_state(state)
            print(f"Loaded universe from {SAVE_FILENAME}")
            add_timed_message("Loaded saved universe")
            loaded_from_save = True
        except Exception as e:
            print(f"Error loading save file: {e}. Starting new universe.")

    if cli_connect_addr:
        ip, port = cli_connect_addr, DEFAULT_PORT
        if ':' in cli_connect_addr: ip, port = cli_connect_addr.split(':')
        connect_as_guest(ip, port)
    elif cli_listen_port:
        initiate_host_mode(cli_listen_port)
    elif not loaded_from_save:
        print("No save file found. Starting a new universe.")
        show_void_screen(screen, world)

    running = True
    while running:
        unscaled_dt = min(0.1, clock.tick(FPS) / 1000.0); scaled_dt = unscaled_dt * time_scale
        frame_count += 1; fps = clock.get_fps()
        if fps > 0 and fps < 45 and time_scale > 1.0: time_scale = max(1.0, time_scale * 0.99)
        governor_active = fps < 55; is_interactive = game_mode in ['single_player', 'host']

        hovered_vertex = None
        if is_interactive and not rotating:
            mx, my = pygame.mouse.get_pos(); hover_radius_sq = (EDGE_LEN*2)**2; min_dist_sq = float('inf')
            for t in world.tets:
                for i, v in enumerate(t.verts()):
                    px, py = cam.project(v); dist_sq = (mx - px)**2 + (my - py)**2
                    if dist_sq < hover_radius_sq and dist_sq < min_dist_sq: hovered_vertex = (t, i); min_dist_sq = dist_sq

        for e in pygame.event.get():
            if e.type == pygame.QUIT: running = False
            if e.type == pygame.VIDEORESIZE: WIDTH, HEIGHT = e.w, e.h; screen = pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE)
            if e.type == pygame.KEYDOWN:
                if e.key == pygame.K_v and is_interactive: save_world_to_file()
                if e.key == pygame.K_BACKQUOTE:
                    if not reset_timer:
                        if is_interactive: world.explode()
                        add_timed_message("RESETTING...", duration=2); reset_timer = pygame.time.get_ticks() + 2000
                if is_interactive and e.key == pygame.K_SPACE:
                    if len(world.tets) < 2 or flags['j1']: world.spawn(give_special_colors=flags['j1'])
                if e.key == pygame.K_x: cam.__init__()
                if e.key == pygame.K_h: initiate_host_mode()
                if e.key == pygame.K_TAB: discover_and_join()
            if e.type == pygame.MOUSEBUTTONDOWN:
                if is_interactive and e.button == 1 and hovered_vertex:
                    t, i = hovered_vertex; drag_depth = cam.get_transformed_z(t.verts()[i]); dragging = (t, i, drag_depth)
                    locked_sticky_target, sticky_unlock_timer = None, None
                if e.button == 3:
                    rotating, last_mouse = True, e.pos; rmb_down_timer = pygame.time.get_ticks(); rmb_start_pos = e.pos
                if e.button == 1:
                    mx, my = e.pos; clicked_avatar_id = None
                    for avatar_id, avatar_data in net_avatars.items():
                        px, py = cam.project(avatar_data['pos'])
                        if (mx - px)**2 + (my - py)**2 < 20**2: clicked_avatar_id = avatar_id; break
                    if clicked_avatar_id:
                        chat_msg = get_user_input(screen, f"Message to {clicked_avatar_id.split('_')[0]}:")
                        if chat_msg:
                            if game_mode == 'guest' and guest_instance: guest_instance.send_chat(chat_msg)
                            elif game_mode == 'host' and host_instance:
                                target_sock = None
                                with host_instance.lock:
                                    for sock, client_data in host_instance.clients.items():
                                        if client_data['id'] == clicked_avatar_id: target_sock = sock; break
                                if target_sock: send_msg(target_sock, {'type': 'chat', 'data': chat_msg})
                    else:
                        if is_interactive:
                            clicked_joint = None; min_dist = 5
                            for joint in world.joints:
                                p1 = cam.project(joint.A.verts()[joint.ia])
                                p2 = cam.project(joint.B.verts()[joint.ib])
                                dist = dist_point_to_line_segment((mx, my), p1, p2)
                                if dist < min_dist: min_dist, clicked_joint = dist, joint
                            if clicked_joint:
                                world.joints.remove(clicked_joint)
            if e.type == pygame.MOUSEBUTTONUP:
                if is_interactive and e.button == 1 and dragging and locked_sticky_target:
                    t_drag, i_drag, _ = dragging; t_snap, j_snap = locked_sticky_target
                    if not (t_drag == t_snap and i_drag == j_snap):
                        vertex_id = (t_drag.id, i_drag)
                        world.sticky_pairs = [p for p in world.sticky_pairs if (p[0].id, p[1]) != vertex_id]
                        world.sticky_pairs.append((t_drag, i_drag, t_snap, j_snap))
                if e.button == 1: dragging, locked_sticky_target, sticky_unlock_timer = None, None, None
                if e.button == 3:
                    if rmb_down_timer is not None:
                        is_drag = np.linalg.norm(np.array(e.pos) - np.array(rmb_start_pos)) > 5
                        if pygame.time.get_ticks() - rmb_down_timer < 300 and not is_drag:
                            mx, my = e.pos; best_dist = float('inf'); target_tet = None
                            for t in world.tets:
                                sx, sy = cam.project(t.pos); dist_sq = (mx - sx)**2 + (my - sy)**2
                                if dist_sq < best_dist: best_dist, target_tet = dist_sq, t
                            if target_tet and best_dist < (EDGE_LEN * 20 / (cam.dist/DEFAULT_CAM_DIST))**2:
                                new_label = get_user_input(screen, "Enter label:", target_tet.label)
                                if game_mode == 'guest' and guest_instance:
                                    guest_instance.send_label(target_tet.id, new_label)
                                else: target_tet.label = new_label
                    rotating = False; rmb_down_timer = None; rmb_start_pos = None
            if e.type == pygame.MOUSEWHEEL: cam.zoom(ZOOM_SPEED if e.y < 0 else 1/ZOOM_SPEED)

        keys = pygame.key.get_pressed()
        pitch_delta = 0
        if keys[pygame.K_w]: pitch_delta += ORBIT_SPEED * unscaled_dt
        if keys[pygame.K_s]: pitch_delta -= ORBIT_SPEED * unscaled_dt
        if pitch_delta != 0:
            cam.pitch += pitch_delta
            cam.pitch %= (2 * math.pi)
        if keys[pygame.K_a]: cam.yaw -= ORBIT_SPEED * unscaled_dt
        if keys[pygame.K_d]: cam.yaw += ORBIT_SPEED * unscaled_dt
        if keys[pygame.K_r]: cam.zoom(1/ZOOM_SPEED)
        if keys[pygame.K_f]: cam.zoom(ZOOM_SPEED)
        if keys[pygame.K_q] or keys[pygame.K_e]:
            pan_dir = 1 if keys[pygame.K_q] else -1; cam_right = np.array([math.cos(cam.yaw), 0, -math.sin(cam.yaw)])
            cam.pan += cam_right * pan_dir * PAN_SPEED * unscaled_dt
        if is_interactive and keys[pygame.K_c] and not governor_active: time_scale = min(10.0, time_scale + 2.0 * unscaled_dt)
        if is_interactive and keys[pygame.K_z]: time_scale = max(0.1, time_scale - 2.0 * unscaled_dt)

        if rotating:
            mx,my=pygame.mouse.get_pos(); dx,dy=mx-last_mouse[0],my-last_mouse[1]
            cam.yaw += dx*0.005; cam.pitch = np.clip(cam.pitch - dy*0.005, -math.pi/2, math.pi/2); last_mouse=(mx,my)
            if is_interactive:
                hover_radius_sq = (EDGE_LEN*2)**2; min_dist_sq = float('inf'); hovered_vertex = None
                for t in world.tets:
                    for i, v in enumerate(t.verts()):
                        px, py = cam.project(v); dist_sq = (mx - px)**2 + (my - py)**2
                        if dist_sq < hover_radius_sq and dist_sq < min_dist_sq: hovered_vertex = (t, i); min_dist_sq = dist_sq

        if is_interactive and dragging:
            t_drag, i_drag, drag_depth = dragging; mouse_pos_3d = cam.unproject(pygame.mouse.get_pos(), drag_depth)
            delta = mouse_pos_3d - t_drag.verts()[i_drag]; t_drag.local[i_drag] += delta * MOUSE_PULL_STRENGTH
            t_drag.pos += delta * BODY_PULL_STRENGTH
            screen_pos_dragged = np.array(cam.project(t_drag.verts()[i_drag])); mouse_pos_2d = np.array(pygame.mouse.get_pos())
            current_hover_target = None; best_dist = 50
            for t_target in world.tets:
                if not pygame.mouse.get_pressed()[0]: break
                for j_target, v_target in enumerate(t_target.verts()):
                    if t_target == t_drag and j_target == i_drag: continue
                    dist = dist_point_to_line_segment(np.array(cam.project(v_target)), screen_pos_dragged, mouse_pos_2d)
                    if dist < best_dist: best_dist, current_hover_target = dist, (t_target, j_target)
            if current_hover_target:
                if locked_sticky_target != current_hover_target: sticky_unlock_timer = pygame.time.get_ticks() + 5000
                locked_sticky_target = current_hover_target
            if sticky_unlock_timer and pygame.time.get_ticks() > sticky_unlock_timer:
                if not current_hover_target: locked_sticky_target, sticky_unlock_timer = None, None

        if is_interactive and rotating and hovered_vertex:
            paused_tet = hovered_vertex[0]; paused_tet.pos_prev = paused_tet.pos; paused_tet.local_prev = paused_tet.local

        calc_indicator_rect = pygame.Rect(10, HEIGHT - 30, 20, 20)
        if is_interactive:
            pygame.draw.rect(screen, (255,255,0), calc_indicator_rect); pygame.display.flip()
            world.update(scaled_dt, unscaled_dt, time_scale)
            if game_mode == 'host' and host_instance and frame_count % 2 == 0:
                state_with_center = world.get_state(); state_with_center['center_of_mass'] = world.center_of_mass
                host_instance.broadcast_state()
        elif game_mode == 'guest':
            if guest_instance and guest_instance.latest_world_state:
                world.set_state(guest_instance.latest_world_state)
                if frame_count % 5 == 0: guest_instance.send_cam_update()

        if game_mode == 'guest':
             cam.pan = world.center_of_mass

        if is_interactive and hovered_vertex: t, i = hovered_vertex; t.local[i] = t.local_prev[i]
        if reset_timer and pygame.time.get_ticks() > reset_timer: reset_simulation(); reset_timer = None

        if is_interactive:
            if len(world.tets) >= 1 and not flags['t1']: flags['t1'] = True
            if len(world.tets) >= 2 and not flags['t2']: flags['t2'] = True; add_timed_message("LET THERE BE SEPARATION!", -20); add_timed_message("And let it chase time ever into the future.", 20)
            if len(world.tets) >= 2 and len(world.joints) >= 1 and not flags['j1']:
                flags['j1'] = True; add_timed_message("LET THERE BE LIGHT", -20); add_timed_message("To grow old and wise!", 20)
                for t in world.tets:
                    if t.colors is None: cols = [(255,255,255), (0,0,0), (255,0,0), (0,255,255)]; random.shuffle(cols); t.colors = cols
            if len(world.tets) >= 3 and flags['j1'] and not flags['t3']:
                flags['t3'] = True; add_timed_message("...and, LET THERE BE DARKNESS!", -20); add_timed_message("So light can be seen!", 20)
                if not stars: stars = [((random.randint(0, WIDTH), random.randint(0, HEIGHT)), random.randint(50, 150)) for _ in range(500)]

        light_phase = flags['j1'] and not flags['t3']
        screen.fill((255,255,255) if light_phase else (10,10,20))
        if stars and not light_phase:
            for pos, bright in stars: screen.set_at(pos, (bright, bright, bright))
        axis_colors = [(255, 0, 0), (255, 255, 255), (0, 255, 255)]

        center = world.center_of_mass
        for i, color in enumerate(axis_colors):
            pos_vec, neg_vec = np.zeros(3), np.zeros(3); pos_vec[i], neg_vec[i] = AXIS_LEN, -AXIS_LEN
            pygame.draw.line(screen, color, cam.project(neg_vec + center), cam.project(pos_vec + center), 2)

        for avatar_id, avatar_data in list(net_avatars.items()):
            if 'pos' in avatar_data and 'color' in avatar_data:
                draw_avatar(screen, cam, avatar_data['pos'], avatar_data['color'])
        orange = (255, 140, 0); gray = (100, 100, 100)
        if is_interactive and dragging and locked_sticky_target:
            t_drag, i_drag, _ = dragging; t_snap, j_snap = locked_sticky_target
            start_pos = cam.project(t_drag.verts()[i_drag]); end_pos = cam.project(t_snap.verts()[j_snap])
            pygame.draw.line(screen, orange, start_pos, end_pos, 2)
        for t1, i1, t2, i2 in world.sticky_pairs:
            p1, p2 = cam.project(t1.verts()[i1]), cam.project(t2.verts()[i2]); pygame.draw.line(screen, orange, p1, p2, 1)
        for j in world.joints:
            p1 = cam.project(j.A.verts()[j.ia]); p2 = cam.project(j.B.verts()[j.ib])
            pygame.draw.line(screen, gray, p1, p2, 1)
        for t in sorted(world.tets, key=lambda t: cam.get_transformed_z(t.pos), reverse=True):
            world_verts, screen_pts = t.verts(), [cam.project(v) for v in t.verts()]
            sorted_faces = sorted(t.faces, key=lambda face: sum(cam.get_transformed_z(world_verts[i]) for i in face), reverse=True)
            if t.colors:
                for face_indices in sorted_faces:
                    face_pts = [screen_pts[i] for i in face_indices]; original_face_index = t.faces.index(face_indices)
                    pygame.draw.polygon(screen, t.colors[original_face_index], face_pts); pygame.draw.aalines(screen, (0,0,0), True, face_pts)
            else:
                bright_color = np.array((200, int(200*t.battery), 255-int(200*t.battery))); ambient_color = bright_color * 0.35
                for face_indices in sorted_faces: pygame.draw.polygon(screen, np.clip(ambient_color, 0, 255), [screen_pts[i] for i in face_indices])
                for i, j in t.edges: pygame.draw.line(screen, bright_color, screen_pts[i], screen_pts[j], 1)
            vert_col = (0,0,0) if light_phase else (255,255,255)
            for p in screen_pts: pygame.draw.circle(screen, vert_col, p, 1)
            if t.label:
                label_surf = font_s.render(t.label, True, (255,255,0))
                label_pos = cam.project(t.pos + np.array([0, EDGE_LEN * 4, 0]))
                screen.blit(label_surf, label_surf.get_rect(center=label_pos))
        if is_interactive and hovered_vertex:
            t, i = hovered_vertex; p = cam.project(t.verts()[i]); pygame.draw.circle(screen, (255,255,0), p, 4, 1)

        now_ticks = pygame.time.get_ticks(); now_time = time.time(); msgs = [m for m in msgs if now_ticks < m[2]]
        text_color = (0,0,0) if light_phase else (200,200,200)
        for text_string, y_offset, end_time in msgs:
            surf = font_l.render(text_string, True, text_color); surf.set_alpha(max(0, min(255, (end_time - now_ticks) / 1000 * 255)))
            screen.blit(surf, surf.get_rect(center=(WIDTH//2, HEIGHT//2 + y_offset)))
        for i, (text, end_time) in enumerate(list(net_messages)):
            if now_time > end_time: net_messages.popleft()
            else:
                surf = font_s.render(text, True, (255, 200, 100)); surf.set_alpha(max(0, min(255, (end_time - now_time) * 100)))
                screen.blit(surf, (10, 40 + i * 25))

        fps_text = f"FPS: {int(fps)}"; fps_surf = font_s.render(fps_text, True, (255, 255, 0)); screen.blit(fps_surf, (10, 10))

        zoom_factor = DEFAULT_CAM_DIST / cam.dist
        zoom_text = f"{zoom_factor:.4f}x" if zoom_factor < 0.1 else f"{zoom_factor:.2f}x"
        if zoom_factor > 10: zoom_text = f"{zoom_factor:.1f}x"
        if zoom_factor > 100: zoom_text = f"{int(zoom_factor)}x"
        mode_text = f"Mode: {game_mode.replace('_', ' ').title()} | Tets: {len(world.tets)} | Joints: {len(world.joints)} | Desires: {len(world.sticky_pairs)} | Zoom: {zoom_text} | Z/C Time ({time_scale:.1f}x)"
        if governor_active and time_scale > 1 and is_interactive: mode_text += " (GOV)"
        top_leg = font_s.render(mode_text, True, (0,255,255))
        top_leg_rect = top_leg.get_rect(center=(WIDTH // 2, 10 + top_leg.get_height() // 2))
        screen.blit(top_leg, top_leg_rect)

        leg_text = "WASD/RMB View | QE Pan | R/F/Wheel Zoom | 'V' Save | H Host | TAB Join | ~ Reset | X Center"
        bot_leg = font_s.render(leg_text, True, (0, 255, 255)); screen.blit(bot_leg, (WIDTH//2 - bot_leg.get_width()//2, HEIGHT-25))

        pygame.display.flip()

    if host_instance: host_instance.stop()
    if guest_instance: guest_instance.stop()
    pygame.quit(); sys.exit()

if __name__ == "__main__":
    main()




---------------- v2.0




Now I'd like to replace the static star-field background (beginning with spawning the 3rd tet) with a 4sphere.  Left and Right join through up and down into a circle. while forward joins them through "future" (blackness) while backwards joins them through "past", now-X, which blueshifts to a pure white limit at 10x speed, or redshifts to blackness at 0.1x.

When looking directly forward I think there would be a circle of blackness straight ahead, surrounding origin where the sides join - this circle should also change size, depending on the speed of time, at 10x it should fill view while at .1x it should be a tiny little dot. When looking directly backwards approaching 7.5x a red version of the current universe should map visibly rotating as the universe maps now (faster higher than 7.5x, slower when time x is lower than).  approaching .5x should simply be 3 blue tets spinning (faster when less than .5x, slower when more than .5x).  There should be as many mirror images of "past" along the sides as number of tets-3, each blue or red-shifted by their number of tets (more tets more red).

Simplify the math to smoothen these changes, removing one tet at each degree or smoothing, but join them all into one spinning clump that changes in number of tets and speed in troughs and pointy peaks (peaking where a tet is added or removed, traughing with spin speed minimizing to 0, then reversing).


import pygame
import numpy as np
import math
import random
import sys
import os
import json
from collections import deque
import socket
import threading
import select
import time

# ============================
# CONFIG
# ============================
WIDTH, HEIGHT = 1200, 800
FPS = 60

EDGE_LEN = 2.0
SNAP_DIST = 0.75
STICKY_PULL_SPEED = 3.0
AXIS_LEN = 20

DEFAULT_PORT = 65420
PORT_RANGE = range(DEFAULT_PORT, DEFAULT_PORT + 10)
DISCOVERY_PORT = 65419

# --- VERLET PHYSICS CONSTANTS ---
DAMPING = 0.995
MOUSE_PULL_STRENGTH = 0.0005
BODY_PULL_STRENGTH = 0.0008
COLLISION_RADIUS = EDGE_LEN * 0.75

# --- BEHAVIOR CONSTANTS ---
K_ORIGIN_PULL = 0.00005
K_SPIN = 1.0
MAX_SPIN_FORCE = K_SPIN * 15
SPIN_ENERGY_COST = 0.08
K_ALIGN = 4.0
K_BATTERY_FORCE = 0.00015
K_CONTAINMENT = 0.001

# --- CAMERA CONTROL CONSTANTS ---
ORBIT_SPEED = 1.5
PAN_SPEED = 200.0
ZOOM_SPEED = 1.05
FOCAL_LENGTH = 650.0
DEFAULT_CAM_DIST = 70.0
MIN_ZOOM_DIST = DEFAULT_CAM_DIST / 100.0
MAX_ZOOM_DIST = DEFAULT_CAM_DIST / 0.01

BATTERY_CHARGE_RADIUS = 50
BATTERY_DRAIN_RADIUS = 420
BATTERY_CHARGE_RATE = 0.03
BATTERY_DRAIN_RATE = 0.005

MAX_DIST_FROM_ORIGIN = 1500
SAVE_FILENAME = "tetcraft_save.json"

class NumpyEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, np.ndarray): return obj.tolist()
        if isinstance(obj, np.integer): return int(obj)
        if isinstance(obj, np.floating): return float(obj)
        return json.JSONEncoder.default(self, obj)

# ============================
# CAMERA & CORE CLASSES
# ============================
class Camera:
    def __init__(self):
        self.yaw, self.pitch, self.dist, self.pan = 0.0, 0.35, DEFAULT_CAM_DIST, np.zeros(3)
    def get_transformed_z(self, v):
        v = v - self.pan; cy, sy = math.cos(self.yaw), math.sin(self.yaw); cp, sp = math.cos(self.pitch), math.sin(self.pitch)
        x, y, z = v; zz = sy*x + cy*z; zz2 = sp*y + cp*zz
        return zz2
    def project(self, v):
        global WIDTH, HEIGHT
        v = v - self.pan; cy, sy = math.cos(self.yaw), math.sin(self.yaw); cp, sp = math.cos(self.pitch), math.sin(self.pitch)
        x, y, z = v; x, z = cy*x - sy*z, sy*x + cy*z; y, z = cp*y - sp*z, sp*y + cp*z
        depth = self.dist + z
        if depth <= 0.1: return (-1000, -1000)
        scale = FOCAL_LENGTH / depth
        return (WIDTH//2 + int(x * scale), HEIGHT//2 - int(y * scale))
    def unproject(self, screen_pos, depth_z):
        global WIDTH, HEIGHT; mx, my = screen_pos
        scale = FOCAL_LENGTH / (self.dist + depth_z + 1e-9)
        if abs(scale) < 1e-9: return self.pan
        x_cam = (mx - WIDTH // 2) / scale; y_cam = -(my - HEIGHT // 2) / scale
        cy, sy = math.cos(self.yaw), math.sin(self.yaw); cp, sp = math.cos(self.pitch), math.sin(self.pitch)
        y_rot, z_rot = cp * y_cam + sp * depth_z, -sp * y_cam + cp * depth_z
        x_world, z_world = cy * x_cam + sy * z_rot, -sy * x_cam + cy * z_rot
        return np.array([x_world, y_rot, z_world]) + self.pan
    def zoom(self, factor): self.dist = np.clip(self.dist * factor, MIN_ZOOM_DIST, MAX_ZOOM_DIST)
    def get_state(self): return {'yaw': self.yaw, 'pitch': self.pitch, 'dist': self.dist, 'pan': self.pan}
    def set_state(self, state): self.yaw, self.pitch, self.dist, self.pan = state['yaw'], state['pitch'], state['dist'], np.array(state['pan'])

def norm(v):
    n = np.linalg.norm(v); return v / n if n > 1e-9 else np.zeros_like(v)
def dist_point_to_line_segment(p, a, b):
    p, a, b = np.array(p), np.array(a), np.array(b)
    ap, ab = p - a, b - a
    t = np.dot(ap, ab) / (np.dot(ab, ab) + 1e-9)
    t = max(0, min(1, t))
    closest = a + t * ab
    return np.linalg.norm(p - closest)

def generate_boing_sound():
    mixer_settings = pygame.mixer.get_init()
    if mixer_settings is None: return None
    sample_rate, _, channels = mixer_settings; duration = 0.2; num_samples = int(duration * sample_rate)
    t = np.linspace(0, duration, num_samples, False); freq = np.linspace(660.0, 220.0, num_samples); wave = np.sin(2 * np.pi * freq * t) * np.exp(-t * 10)
    sound_array = (wave * 32767).astype(np.int16)
    if channels == 2: sound_array = np.column_stack((sound_array, sound_array))
    return pygame.sndarray.make_sound(sound_array)

class VertexJoint:
    def __init__(self, A, ia, B, ib): self.A, self.ia, self.B, self.ib = A, ia, B, ib
    def resolve(self):
        p1, p2 = self.A.verts()[self.ia], self.B.verts()[self.ib]; delta = p2 - p1; dist = np.linalg.norm(delta)
        if dist > 1e-6:
            diff = dist / dist * 0.5; self.A.local[self.ia] += delta * diff; self.B.local[self.ib] -= delta * diff

class Tetrahedron:
    def __init__(self, pos):
        self.pos = np.array(pos, float); self.pos_prev = self.pos.copy()
        self.battery, self.colors = random.uniform(0.3, 0.6), None
        self.label = ""
        r, a = EDGE_LEN*math.sqrt(3/8), EDGE_LEN/math.sqrt(3)
        self.rest = np.array([[0,0,r], [EDGE_LEN/2,-a/2,-r/3], [-EDGE_LEN/2,-a/2,-r/3], [0,a,-r/3]])
        self.local = self.rest.copy(); self.local_prev = self.local.copy()
        self.edges = [(i, j) for i in range(4) for j in range(i+1, 4)]; self.faces = [(1, 2, 3), (0, 1, 2), (0, 2, 3), (0, 1, 3)]
        self.id = id(self)
    def verts(self): return self.local + self.pos
    def update_physics(self, dt, acceleration):
        pos_temp = self.pos.copy(); self.pos += (self.pos - self.pos_prev) * DAMPING + acceleration * dt * dt; self.pos_prev = pos_temp
        local_temp = self.local.copy(); self.local += (self.local - self.local_prev) * DAMPING; self.local_prev = local_temp
    def apply_internal_forces(self):
        self.local -= np.mean(self.local, axis=0)
        for _ in range(3):
            for i, j in self.edges:
                p1, p2 = self.local[i], self.local[j]; delta = p2 - p1; dist = np.linalg.norm(delta)
                if dist > 1e-6: diff = (dist - EDGE_LEN) / dist * 0.5; self.local[i] += delta * diff; self.local[j] -= delta * diff

class PastTetrahedron(Tetrahedron):
    def __init__(self, pos):
        super().__init__(pos)
        self.colors = [(0,0,0)] * 4

class PastClump:
    def __init__(self):
        self.tets = []
        self.yaw, self.pitch, self.roll = 0, 0, 0
        self.pos = np.array([0, 0, -MAX_DIST_FROM_ORIGIN * 2.5])
    def update(self, num_tets_in_world, time_scale):
        target_num_tets = max(1, num_tets_in_world - 3)
        while len(self.tets) < target_num_tets: self.tets.append(PastTetrahedron(np.random.uniform(-10, 10, 3)))
        while len(self.tets) > target_num_tets: self.tets.pop()

        spin_factor = (time_scale - 1.0) * 0.5
        if time_scale < 0.5: spin_factor += (0.5 - time_scale) * 2.0
        if time_scale > 7.5: spin_factor += (time_scale - 7.5) * 0.5

        self.yaw += 0.002 * spin_factor
        self.pitch += 0.003 * spin_factor
        self.roll += 0.005 * spin_factor

        cy, sy = math.cos(self.yaw), math.sin(self.yaw); cp, sp = math.cos(self.pitch), math.sin(self.pitch)
        cr, sr = math.cos(self.roll), math.sin(self.roll)

        rot_matrix = np.array([
            [cp*cy, sp*sr - cp*sy*cr, sp*cr + cp*sy*sr], [sy, cy*cr, -cy*sr], [-sp*cy, cp*sr + sp*sy*cr, cp*cr - sp*sy*sr]
        ])

        color_lerp = np.clip((time_scale - 0.5) / 7.0, 0, 1)
        color = np.array([180, 50, 50]) * color_lerp + np.array([50, 50, 180]) * (1 - color_lerp)

        for i, tet in enumerate(self.tets):
            offset = np.array([math.sin(i*2.1), math.cos(i*1.7), math.sin(i*0.8)]) * (len(self.tets) * 3)
            tet.pos = self.pos + np.dot(rot_matrix, offset)
            tet.local = np.dot(tet.rest, rot_matrix.T)
            tet.colors = [np.clip(color, 0, 255)] * 4

class World:
    def __init__(self, sound):
        self.tets, self.joints, self.sticky_pairs = [], [], []; self.center_of_mass, self.sound = np.zeros(3), sound
    def spawn(self, give_special_colors=False):
        new_tet = Tetrahedron(np.random.uniform(-8, 8, 3) + self.center_of_mass)
        if give_special_colors:
            cols = [(255,255,255), (0,0,0), (255,0,0), (0,255,255)]; random.shuffle(cols); new_tet.colors = cols
        self.tets.append(new_tet)
    def explode(self):
        self.joints.clear(); self.sticky_pairs.clear()
        for t in self.tets:
            t.pos_prev = t.pos - np.random.uniform(-1, 1, 3)
            t.local_prev = t.local - np.random.uniform(-0.5, 0.5, (4,3))
    def try_snap(self, A, ia, B, ib):
        for j in self.joints:
            if (j.A.id, j.ia, j.B.id, j.ib) in [(A.id,ia,B.id,ib), (B.id,ib,A.id,ia)]: return
        self.joints.append(VertexJoint(A, ia, B, ib))
        if self.sound: self.sound.play()
    def calculate_dynamic_center(self):
        if not self.tets: return np.zeros(3)
        if not self.joints: return sum(t.pos for t in self.tets) / len(self.tets)
        tet_map = {t.id: t for t in self.tets}; adj = {t.id: [] for t in self.tets}
        for j in self.joints:
            if j.A.id in adj and j.B.id in adj:
                adj[j.A.id].append(j.B.id); adj[j.B.id].append(j.A.id)
        visited = set(); components = []
        for tet_id in tet_map:
            if tet_id not in visited:
                component = []; q = deque([tet_id]); visited.add(tet_id)
                while q:
                    curr_id = q.popleft(); component.append(tet_map[curr_id])
                    for neighbor_id in adj.get(curr_id, []):
                        if neighbor_id not in visited: visited.add(neighbor_id); q.append(neighbor_id)
                components.append(component)
        if not components: return np.zeros(3)
        max_size = max(len(c) for c in components if c) if any(components) else 0
        if max_size == 0: return sum(t.pos for t in self.tets) / len(self.tets)
        largest_components = [comp for comp in components if len(comp) == max_size]
        total_pos = np.zeros(3); total_count = 0
        for comp in largest_components:
            for tet in comp: total_pos += tet.pos; total_count += 1
        return total_pos / total_count if total_count > 0 else np.zeros(3)
    def update(self, scaled_dt, unscaled_dt, time_scale):
        self.center_of_mass = self.calculate_dynamic_center()
        accelerations = {t: np.zeros(3) for t in self.tets}
        for t in self.tets:
            acc = -t.pos * K_ORIGIN_PULL; r_com = t.pos - self.center_of_mass; d_com = np.linalg.norm(r_com)
            dist_from_origin = np.linalg.norm(t.pos)

            if d_com < BATTERY_CHARGE_RADIUS:
                t.battery += BATTERY_CHARGE_RATE * scaled_dt
            else:
                drain_multiplier = 1.0 + (dist_from_origin / BATTERY_DRAIN_RADIUS)
                t.battery -= BATTERY_DRAIN_RATE * drain_multiplier * scaled_dt

            spin_magnitude = min(MAX_SPIN_FORCE, t.battery * K_SPIN / (time_scale + 1e-6))
            spin_force_dir = np.cross(r_com, np.array([0.0, 1.0, 0.1]))
            acc += norm(spin_force_dir) * spin_magnitude; t.battery -= SPIN_ENERGY_COST * scaled_dt

            t.battery = np.clip(t.battery, 0, 1); acc += norm(r_com) * (t.battery - 0.5) * K_BATTERY_FORCE * d_com

            if dist_from_origin > MAX_DIST_FROM_ORIGIN:
                spring_force = (dist_from_origin - MAX_DIST_FROM_ORIGIN) * K_CONTAINMENT * (t.battery + 0.1)
                acc += -norm(t.pos) * spring_force

            accelerations[t] = acc
        for t in self.tets: t.update_physics(scaled_dt, accelerations[t])
        for _ in range(2):
            for i, t1 in enumerate(self.tets):
                for t2 in self.tets[i+1:]:
                    delta = t2.pos - t1.pos; dist_sq = np.dot(delta, delta)
                    min_dist = COLLISION_RADIUS * 2
                    if dist_sq < min_dist * min_dist and dist_sq > 1e-6:
                        dist = math.sqrt(dist_sq); overlap = (min_dist - dist) * 0.5
                        correction = delta / dist * overlap; t1.pos -= correction; t2.pos += correction
        for pair in self.sticky_pairs[:]:
            t1, i1, t2, i2 = pair; p1, p2 = t1.verts()[i1], t2.verts()[i2]; delta = p2 - p1; dist = np.linalg.norm(delta)
            if dist < SNAP_DIST: self.try_snap(t1, i1, t2, i2); self.sticky_pairs.remove(pair)
            elif dist > 1e-6:
                correction_amount = STICKY_PULL_SPEED * unscaled_dt
                correction = delta / dist * min(correction_amount, dist) * 0.5
                t1.local[i1] += correction; t2.local[i2] -= correction
        for t in self.tets: t.apply_internal_forces()
        for j in self.joints: j.resolve()
    def get_state(self):
        tet_states = [{'id': t.id, 'pos': t.pos, 'pos_prev': t.pos_prev, 'local': t.local, 'local_prev': t.local_prev, 'battery': t.battery, 'colors': t.colors, 'label': t.label} for t in self.tets]
        joint_states = [{'A_id': j.A.id, 'ia': j.ia, 'B_id': j.B.id, 'ib': j.ib} for j in self.joints]
        return {'tets': tet_states, 'joints': joint_states}
    def set_state(self, state):
        self.tets.clear(); self.joints.clear(); self.sticky_pairs.clear(); tet_map = {}
        for ts in state['tets']:
            t = Tetrahedron(ts['pos']); t.id = ts['id']; t.pos_prev = np.array(ts['pos_prev']);
            t.local = np.array(ts['local']); t.local_prev = np.array(ts['local_prev'])
            t.battery = ts['battery']; t.colors = ts['colors']
            t.label = ts.get('label', "")
            self.tets.append(t); tet_map[t.id] = t
        for js in state['joints']:
            if js['A_id'] in tet_map and js['B_id'] in tet_map:
                self.joints.append(VertexJoint(tet_map[js['A_id']], js['ia'], tet_map[js['B_id']], js['ib']))

net_avatars = {}; net_messages = deque(maxlen=5)
game_mode = 'single_player'; host_instance, guest_instance = None, None

# ============================
# UI & NETWORKING
# ============================
def show_intro(screen):
    start = pygame.time.get_ticks()
    while pygame.time.get_ticks() - start < 2000:
        for e in pygame.event.get():
            if e.type == pygame.QUIT: pygame.quit(); sys.exit()
        screen.fill((10,10,20)); font_lg = pygame.font.SysFont('Arial Black', min(WIDTH, HEIGHT)//8); font_sm = pygame.font.SysFont('Arial', min(WIDTH, HEIGHT)//25)
        title = font_lg.render("TET~CRAFT", True, (255, 50, 50)); sub = font_sm.render("A Klein universe of your own!", True, (255, 255, 255))
        screen.blit(title, title.get_rect(center=(WIDTH//2, HEIGHT//2-50))); screen.blit(sub, sub.get_rect(center=(WIDTH//2, HEIGHT//2+50))); pygame.display.flip()

def show_void_screen(screen, world):
    font_lg = pygame.font.SysFont('Georgia', 40); font_sm = pygame.font.SysFont('Arial', 24)
    line1 = font_lg.render("Welcome to the void of (mis)understanding...", True, (200,200,200)); line2 = font_sm.render("(Press SPACE to begin)", True, (150,150,150))
    waiting = True
    while waiting:
        for e in pygame.event.get():
            if e.type == pygame.QUIT: pygame.quit(); sys.exit()
            if e.type == pygame.KEYDOWN and e.key == pygame.K_SPACE: world.spawn(give_special_colors=False); waiting = False
        screen.fill((10,10,20)); screen.blit(line1, line1.get_rect(center=(WIDTH//2, HEIGHT//2-30))); screen.blit(line2, line2.get_rect(center=(WIDTH//2, HEIGHT//2+30))); pygame.display.flip()
        clock.tick(15)

def draw_avatar(screen, cam, pos, color):
    r, a = EDGE_LEN*math.sqrt(3/8), EDGE_LEN/math.sqrt(3)
    base_verts = np.array([[0,0,r], [EDGE_LEN/2,-a/2,-r/3], [-EDGE_LEN/2,-a/2,-r/3], [0,a,-r/3]])
    verts1 = base_verts + pos; verts2 = np.array([v * [1,-1,1] for v in base_verts]) + pos
    all_verts = np.vstack([verts1, np.array([verts2[0], verts2[2], verts2[1], verts2[3]])])
    screen_pts = [cam.project(v) for v in all_verts]
    faces = [(0,1,3), (0,2,1), (0,3,2), (1,2,3), (4,5,7), (4,6,5), (4,7,6), (5,6,7)]
    sorted_faces = sorted(faces, key=lambda face: sum(cam.get_transformed_z(all_verts[i]) for i in face), reverse=True)
    for face_indices in sorted_faces:
        face_pts = [screen_pts[i] for i in face_indices]
        try: pygame.draw.polygon(screen, color, face_pts); pygame.draw.aalines(screen, (20,20,20), True, face_pts)
        except: pass

def get_user_input(screen, prompt, initial_text=""):
    input_text = initial_text; font = pygame.font.SysFont(None, 32); active = True
    while active:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN: active = False
                elif event.key == pygame.K_BACKSPACE: input_text = input_text[:-1]
                else: input_text += event.unicode
        screen.fill((10,10,20))
        prompt_surf = font.render(prompt, True, (255,255,255)); input_surf = font.render(input_text, True, (255,255,0))
        screen.blit(prompt_surf, (WIDTH//2 - prompt_surf.get_width()//2, HEIGHT//2 - 50))
        screen.blit(input_surf, (WIDTH//2 - input_surf.get_width()//2, HEIGHT//2))
        pygame.display.flip(); clock.tick(30)
    return input_text

def send_msg(sock, msg_dict):
    try:
        msg_json = json.dumps(msg_dict, cls=NumpyEncoder).encode('utf-8'); msg_len = len(msg_json).to_bytes(4, 'big')
        sock.sendall(msg_len + msg_json)
    except (ConnectionResetError, BrokenPipeError, OSError): pass

def recv_msg(sock):
    try:
        len_bytes = sock.recv(4)
        if not len_bytes: return None
        msg_len = int.from_bytes(len_bytes, 'big'); data = b''
        while len(data) < msg_len:
            packet = sock.recv(msg_len - len(data))
            if not packet: return None
            data += packet
        return json.loads(data.decode('utf-8'))
    except (ConnectionResetError, json.JSONDecodeError, ValueError, OSError): return None

class Host:
    def __init__(self, world, add_msg_fn, port=None):
        self.world = world; self.add_msg = add_msg_fn; self.clients = {}; self.lock = threading.Lock()
        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM); self.port = 0
        ports_to_try = [port] if port else PORT_RANGE
        for p in ports_to_try:
            try: self.server.bind(('', p)); self.port = p; break
            except OSError: continue
        if self.port == 0: self.server.bind(('', 0)); self.port = self.server.getsockname()[1]
        self.running = True
        threading.Thread(target=self.discovery_thread, daemon=True).start()
        threading.Thread(target=self.start, daemon=True).start()
    def discovery_thread(self):
        udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); udp_sock.bind(('', DISCOVERY_PORT))
        while self.running:
            try:
                data, addr = udp_sock.recvfrom(1024)
                if data == b"DISCOVER_TETCRAFT_HOST":
                    response = f"TETCRAFT_HOST_HERE:{self.port}".encode('utf-8')
                    udp_sock.sendto(response, addr)
            except OSError: break
    def start(self):
        self.server.listen(); hostname = socket.gethostbyname(socket.gethostname())
        print(f"### HOSTING on {hostname}:{self.port} ###")
        while self.running:
            try:
                client_sock, addr = self.server.accept(); client_id = f"guest_{addr[0]}:{addr[1]}"
                print(f"Accepted connection from {addr}")
                with self.lock:
                    self.clients[client_sock] = {'id': client_id, 'addr': addr}
                    net_avatars[client_id] = {'pos': [0,0,0], 'color': [random.randint(50,200) for _ in range(3)]}
                threading.Thread(target=self.handle_client, args=(client_sock, client_id), daemon=True).start()
            except OSError: break
    def handle_client(self, sock, client_id):
        while self.running:
            msg = recv_msg(sock)
            if msg is None: break
            if msg['type'] == 'cam_update':
                with self.lock:
                    if client_id in net_avatars: net_avatars[client_id]['pos'] = np.array(msg['data']['pan'])
            elif msg['type'] == 'chat': self.add_msg(f"<{client_id.split(':')[0]}>: {msg['data']}")
            elif msg['type'] == 'set_label':
                with self.lock:
                    for t in self.world.tets:
                        if t.id == msg['id']: t.label = msg['label']; break
        print(f"Client {client_id} disconnected.")
        with self.lock: self.clients.pop(sock, None); net_avatars.pop(client_id, None)
        sock.close()
    def broadcast_state(self):
        state = self.world.get_state(); full_state = {'type': 'world_state', 'data': {'world': state, 'avatars': net_avatars}}
        with self.lock:
            for sock in list(self.clients.keys()): send_msg(sock, full_state)
    def stop(self):
        self.running = False
        with self.lock:
            for sock in self.clients: sock.close()
        self.server.close()

class Guest:
    def __init__(self, host_ip, port, world, cam, add_msg_fn):
        self.world = world; self.cam = cam; self.add_msg = add_msg_fn
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM); self.sock.connect((host_ip, port))
        self.host_id = f"host_{host_ip}:{port}"; self.running = True; self.latest_world_state = None
        threading.Thread(target=self.listen, daemon=True).start()
    def listen(self):
        global net_avatars
        while self.running:
            msg = recv_msg(self.sock)
            if msg is None: self.add_msg("Disconnected from host."); self.running = False; break
            if msg['type'] == 'world_state':
                self.latest_world_state = msg['data']['world']
                host_avatar = {'pos': msg['data']['world'].get('center_of_mass', [0,0,0]), 'color': (50, 50, 255)}
                net_avatars = {self.host_id: host_avatar}
            elif msg['type'] == 'chat': self.add_msg(f"<HOST>: {msg['data']}")
    def send_cam_update(self): send_msg(self.sock, {'type': 'cam_update', 'data': self.cam.get_state()})
    def send_chat(self, text): send_msg(self.sock, {'type': 'chat', 'data': text})
    def send_label(self, tet_id, label): send_msg(self.sock, {'type': 'set_label', 'id': tet_id, 'label': label})
    def stop(self): self.running = False; self.sock.close()

def main():
    print("CLI Options:")
    print("  -connect <ip>:<port>   (Connect directly to a server)")
    print("  -listen <port>         (Launch directly as a host on a port)")
    print("  -file <filename>       (Load a specific save file on start)")
    print("TET~CRAFT Initializing...")

    cli_connect_addr, cli_listen_port, cli_load_file = None, None, None
    if len(sys.argv) > 1:
        if sys.argv[1] == '-connect' and len(sys.argv) > 2: cli_connect_addr = sys.argv[2]
        if sys.argv[1] == '-listen' and len(sys.argv) > 2: cli_listen_port = int(sys.argv[2])
        elif sys.argv[1] == '-listen': cli_listen_port = DEFAULT_PORT
        if sys.argv[1] == '-file' and len(sys.argv) > 2: cli_load_file = sys.argv[2]

    global WIDTH, HEIGHT, clock, game_mode, host_instance, guest_instance, net_avatars, net_messages
    os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "1"
    pygame.init(); pygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=512)
    screen = pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE); pygame.display.set_caption("TET~CRAFT")
    clock = pygame.time.Clock(); font_l = pygame.font.SysFont('Georgia', 32); font_s = pygame.font.SysFont(None, 24)
    world, cam = World(generate_boing_sound()), Camera()
    flags = {'t1': False, 't2': False, 'j1': False, 't3': False}; msgs = []
    dragging, rotating, last_mouse = None, False, (0,0); time_scale = 1.0; governor_active = False; reset_timer = None
    locked_sticky_target, sticky_unlock_timer = None, None; frame_count = 0
    rmb_down_timer = None; rmb_start_pos = None

    past_clump = PastClump()
    particles = []

    def add_timed_message(text, y_offset=0, duration=4): msgs.append([text, y_offset, pygame.time.get_ticks() + duration * 1000])
    def add_network_message(text): net_messages.append([text, time.time() + 8])
    def reset_simulation(show_message=True):
        nonlocal flags, time_scale, world, cam, dragging, rotating, locked_sticky_target, sticky_unlock_timer
        global game_mode, host_instance, guest_instance, net_avatars, net_messages
        world.tets.clear(); world.joints.clear(); world.sticky_pairs.clear()
        flags = {'t1': False, 't2': False, 'j1': False, 't3': False}; cam.__init__()
        time_scale = 1.0; game_mode = 'single_player'
        dragging, rotating, locked_sticky_target, sticky_unlock_timer = None, False, None, None
        net_avatars.clear(); net_messages.clear()
        if host_instance: host_instance.stop(); host_instance = None
        if guest_instance: guest_instance.stop(); guest_instance = None
        if show_message: add_timed_message("Simulation Reset", duration=2)
    def save_world_to_file():
        if not world.tets: return
        with open(SAVE_FILENAME, 'w') as f: json.dump(world.get_state(), f, cls=NumpyEncoder, indent=2)
        add_timed_message(f"Saved universe to {SAVE_FILENAME}", duration=3)

    def connect_as_guest(host_ip, port):
        global guest_instance, game_mode
        try:
            save_world_to_file();
            guest_instance = Guest(host_ip, int(port), world, cam, add_network_message)
            game_mode = 'guest'; add_timed_message(f"Connected to {host_ip}:{port}", duration=3)
            world.tets.clear(); world.joints.clear(); world.sticky_pairs.clear()
            return True
        except Exception as e:
            add_timed_message(f"Failed to connect: {e}", duration=4)
            return False

    def discover_and_join():
        global guest_instance, game_mode
        if game_mode != 'single_player': return
        host_addr = None

        add_timed_message("Scanning localhost for hosts...", duration=1); pygame.display.flip()
        for port in PORT_RANGE:
            try:
                with socket.create_connection(('127.0.0.1', port), timeout=0.05) as s:
                    host_addr = ('127.0.0.1', port); break
            except (socket.timeout, ConnectionRefusedError): continue

        if not host_addr:
            add_timed_message("Discovering hosts on LAN...", duration=2); pygame.display.flip()
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1); sock.settimeout(2.0)
                try:
                    local_ip = socket.gethostbyname(socket.gethostname())
                    broadcast_ip = '.'.join(local_ip.split('.')[:-1]) + '.255'
                    sock.sendto(b"DISCOVER_TETCRAFT_HOST", (broadcast_ip, DISCOVERY_PORT))
                    data, addr = sock.recvfrom(1024)
                    if data.startswith(b"TETCRAFT_HOST_HERE:"):
                        port = int(data.split(b':')[1]); host_addr = (addr[0], port)
                except socket.timeout: pass

        if host_addr:
            connect_as_guest(host_addr[0], host_addr[1])
        else:
            add_timed_message("No host found, please enter manually.", duration=2)
            pygame.time.wait(1000)
            user_input = get_user_input(screen, "Enter Host IP:Port (e.g. 192.168.1.5:65420):")
            if user_input:
                ip, port = user_input, DEFAULT_PORT
                if ':' in user_input: ip, port = user_input.split(':')
                connect_as_guest(ip, port)

    def initiate_host_mode(port=None):
        global host_instance, game_mode
        if game_mode != 'single_player': return
        host_instance = Host(world, add_network_message, port); game_mode = 'host'
        add_timed_message("Hosting Mode Activated", duration=3)

    show_intro(screen)
    loaded_from_save = False

    if cli_connect_addr:
        ip, port = cli_connect_addr, DEFAULT_PORT
        if ':' in cli_connect_addr: ip, port = cli_connect_addr.split(':')
        connect_as_guest(ip, port)
    elif cli_listen_port:
        initiate_host_mode(cli_listen_port)
        print("Starting in host mode.")
    elif cli_load_file:
        if os.path.exists(cli_load_file):
            try:
                with open(cli_load_file, 'r', encoding='utf-8-sig') as f:
                    state = json.load(f)
                    world.set_state(state)
                print(f"Loaded universe from {cli_load_file}")
                add_timed_message(f"Loaded {cli_load_file}")
                loaded_from_save = True
            except Exception as e:
                print(f"Error loading file '{cli_load_file}': {e}. Starting new universe.")
        else:
            print(f"File '{cli_load_file}' not found. Starting new universe.")

    if not loaded_from_save and not cli_connect_addr and not cli_listen_port:
        print("No save file found. Starting a new universe.")
        show_void_screen(screen, world)

    running = True
    while running:
        unscaled_dt = min(0.1, clock.tick(FPS) / 1000.0); scaled_dt = unscaled_dt * time_scale
        frame_count += 1; fps = clock.get_fps()
        if fps > 0 and fps < 45 and time_scale > 1.0: time_scale = max(1.0, time_scale * 0.99)
        governor_active = fps < 55; is_interactive = game_mode in ['single_player', 'host']

        hovered_vertex = None
        if is_interactive and not rotating:
            mx, my = pygame.mouse.get_pos(); hover_radius_sq = 24*24; min_dist_sq = float('inf')
            for t in world.tets:
                for i, v in enumerate(t.verts()):
                    px, py = cam.project(v); dist_sq = (mx - px)**2 + (my - py)**2
                    if dist_sq < hover_radius_sq and dist_sq < min_dist_sq: hovered_vertex = (t, i); min_dist_sq = dist_sq

        for e in pygame.event.get():
            if e.type == pygame.QUIT: running = False
            if e.type == pygame.VIDEORESIZE: WIDTH, HEIGHT = e.w, e.h; screen = pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE)
            if e.type == pygame.KEYDOWN:
                if e.key == pygame.K_v and is_interactive: save_world_to_file()
                if e.key == pygame.K_BACKQUOTE:
                    if not reset_timer:
                        if is_interactive: world.explode()
                        add_timed_message("RESETTING...", duration=2); reset_timer = pygame.time.get_ticks() + 2000
                if is_interactive and e.key == pygame.K_SPACE:
                    if len(world.tets) < 2 or flags['j1']: world.spawn(give_special_colors=flags['j1'])
                if e.key == pygame.K_x: cam.__init__()
                if e.key == pygame.K_h: initiate_host_mode()
                if e.key == pygame.K_TAB: discover_and_join()
            if e.type == pygame.MOUSEBUTTONDOWN:
                if is_interactive and e.button == 1 and hovered_vertex:
                    t, i = hovered_vertex; drag_depth = cam.get_transformed_z(t.verts()[i]); dragging = (t, i, drag_depth)
                    locked_sticky_target, sticky_unlock_timer = None, None
                if e.button == 3:
                    rotating, last_mouse = True, e.pos; rmb_down_timer = pygame.time.get_ticks(); rmb_start_pos = e.pos
                if e.button == 1:
                    mx, my = e.pos; clicked_avatar_id = None
                    for avatar_id, avatar_data in net_avatars.items():
                        px, py = cam.project(avatar_data['pos'])
                        if (mx - px)**2 + (my - py)**2 < 20**2: clicked_avatar_id = avatar_id; break
                    if clicked_avatar_id:
                        chat_msg = get_user_input(screen, f"Message to {clicked_avatar_id.split('_')[0]}:")
                        if chat_msg:
                            if game_mode == 'guest' and guest_instance: guest_instance.send_chat(chat_msg)
                            elif game_mode == 'host' and host_instance:
                                target_sock = None
                                with host_instance.lock:
                                    for sock, client_data in host_instance.clients.items():
                                        if client_data['id'] == clicked_avatar_id: target_sock = sock; break
                                if target_sock: send_msg(target_sock, {'type': 'chat', 'data': chat_msg})
                    else:
                        if is_interactive:
                            clicked_joint = None; min_dist = 5
                            for joint in world.joints:
                                p1 = cam.project(joint.A.verts()[joint.ia])
                                p2 = cam.project(joint.B.verts()[joint.ib])
                                dist = dist_point_to_line_segment((mx, my), p1, p2)
                                if dist < min_dist: min_dist, clicked_joint = dist, joint
                            if clicked_joint:
                                world.joints.remove(clicked_joint)
            if e.type == pygame.MOUSEBUTTONUP:
                if is_interactive and e.button == 1 and dragging and locked_sticky_target:
                    t_drag, i_drag, _ = dragging; t_snap, j_snap = locked_sticky_target
                    if not (t_drag == t_snap and i_drag == j_snap):
                        vertex_id = (t_drag.id, i_drag)
                        world.sticky_pairs = [p for p in world.sticky_pairs if (p[0].id, p[1]) != vertex_id]
                        world.sticky_pairs.append((t_drag, i_drag, t_snap, j_snap))
                if e.button == 1: dragging, locked_sticky_target, sticky_unlock_timer = None, None, None
                if e.button == 3:
                    if rmb_down_timer is not None:
                        is_drag = np.linalg.norm(np.array(e.pos) - np.array(rmb_start_pos)) > 5
                        if pygame.time.get_ticks() - rmb_down_timer < 300 and not is_drag:
                            mx, my = e.pos; best_dist = float('inf'); target_tet = None
                            for t in world.tets:
                                sx, sy = cam.project(t.pos); dist_sq = (mx - sx)**2 + (my - sy)**2
                                if dist_sq < best_dist: best_dist, target_tet = dist_sq, t
                            if target_tet and best_dist < (EDGE_LEN * 20 / (cam.dist/DEFAULT_CAM_DIST))**2:
                                new_label = get_user_input(screen, "Enter label:", target_tet.label)
                                if game_mode == 'guest' and guest_instance:
                                    guest_instance.send_label(target_tet.id, new_label)
                                else: target_tet.label = new_label
                    rotating = False; rmb_down_timer = None; rmb_start_pos = None
            if e.type == pygame.MOUSEWHEEL: cam.zoom(ZOOM_SPEED if e.y < 0 else 1/ZOOM_SPEED)

        keys = pygame.key.get_pressed()
        pitch_delta = 0
        if keys[pygame.K_w]: pitch_delta += ORBIT_SPEED * unscaled_dt
        if keys[pygame.K_s]: pitch_delta -= ORBIT_SPEED * unscaled_dt
        if pitch_delta != 0:
            cam.pitch += pitch_delta; cam.pitch %= (2 * math.pi)
        if keys[pygame.K_a]: cam.yaw -= ORBIT_SPEED * unscaled_dt
        if keys[pygame.K_d]: cam.yaw += ORBIT_SPEED * unscaled_dt
        if keys[pygame.K_r]: cam.zoom(1/ZOOM_SPEED)
        if keys[pygame.K_f]: cam.zoom(ZOOM_SPEED)
        if keys[pygame.K_q] or keys[pygame.K_e]:
            pan_dir = 1 if keys[pygame.K_q] else -1; cam_right = np.array([math.cos(cam.yaw), 0, -math.sin(cam.yaw)])
            cam.pan += cam_right * pan_dir * PAN_SPEED * unscaled_dt
        if is_interactive and keys[pygame.K_c] and not governor_active: time_scale = min(10.0, time_scale + 2.0 * unscaled_dt)
        if is_interactive and keys[pygame.K_z]: time_scale = max(0.1, time_scale - 2.0 * unscaled_dt)

        if rotating:
            mx,my=pygame.mouse.get_pos(); dx,dy=mx-last_mouse[0],my-last_mouse[1]
            cam.yaw += dx*0.005; cam.pitch = np.clip(cam.pitch - dy*0.005, -math.pi/2, math.pi/2); last_mouse=(mx,my)
            if is_interactive:
                hover_radius_sq = 24*24; min_dist_sq = float('inf'); hovered_vertex = None
                for t in world.tets:
                    for i, v in enumerate(t.verts()):
                        px, py = cam.project(v); dist_sq = (mx - px)**2 + (my - py)**2
                        if dist_sq < hover_radius_sq and dist_sq < min_dist_sq: hovered_vertex = (t, i); min_dist_sq = dist_sq

        if is_interactive and dragging:
            t_drag, i_drag, drag_depth = dragging; mouse_pos_3d = cam.unproject(pygame.mouse.get_pos(), drag_depth)
            delta = mouse_pos_3d - t_drag.verts()[i_drag]; t_drag.local[i_drag] += delta * MOUSE_PULL_STRENGTH
            t_drag.pos += delta * BODY_PULL_STRENGTH
            screen_pos_dragged = np.array(cam.project(t_drag.verts()[i_drag])); mouse_pos_2d = np.array(pygame.mouse.get_pos())
            current_hover_target = None; best_dist = 50
            for t_target in world.tets:
                if not pygame.mouse.get_pressed()[0]: break
                for j_target, v_target in enumerate(t_target.verts()):
                    if t_target == t_drag and j_target == i_drag: continue
                    dist = dist_point_to_line_segment(np.array(cam.project(v_target)), screen_pos_dragged, mouse_pos_2d)
                    if dist < best_dist: best_dist, current_hover_target = dist, (t_target, j_target)
            if current_hover_target:
                if locked_sticky_target != current_hover_target: sticky_unlock_timer = pygame.time.get_ticks() + 5000
                locked_sticky_target = current_hover_target
            if sticky_unlock_timer and pygame.time.get_ticks() > sticky_unlock_timer:
                if not current_hover_target: locked_sticky_target, sticky_unlock_timer = None, None

        if is_interactive and rotating and hovered_vertex:
            paused_tet = hovered_vertex[0]; paused_tet.pos_prev = paused_tet.pos; paused_tet.local_prev = paused_tet.local

        calc_indicator_rect = pygame.Rect(10, HEIGHT - 30, 20, 20)
        if is_interactive:
            pygame.draw.rect(screen, (255,255,0), calc_indicator_rect); pygame.display.flip()
            world.update(scaled_dt, unscaled_dt, time_scale)
            if game_mode == 'host' and host_instance and frame_count % 2 == 0:
                state_with_center = world.get_state(); state_with_center['center_of_mass'] = world.center_of_mass
                host_instance.broadcast_state()
        elif game_mode == 'guest':
            if guest_instance and guest_instance.latest_world_state:
                world.set_state(guest_instance.latest_world_state)
                if frame_count % 5 == 0: guest_instance.send_cam_update()

        if game_mode == 'guest':
             cam.pan = world.center_of_mass

        if is_interactive and hovered_vertex: t, i = hovered_vertex; t.local[i] = t.local_prev[i]
        if reset_timer and pygame.time.get_ticks() > reset_timer: reset_simulation(); reset_timer = None

        if is_interactive:
            if len(world.tets) >= 1 and not flags['t1']: flags['t1'] = True
            if len(world.tets) >= 2 and not flags['t2']: flags['t2'] = True; add_timed_message("LET THERE BE SEPARATION!", -20); add_timed_message("And let it chase time ever into the future.", 20)
            if len(world.tets) >= 2 and len(world.joints) >= 1 and not flags['j1']:
                flags['j1'] = True; add_timed_message("LET THERE BE LIGHT", -20); add_timed_message("To grow old and wise!", 20)
                for t in world.tets:
                    if t.colors is None: cols = [(255,255,255), (0,0,0), (255,0,0), (0,255,255)]; random.shuffle(cols); t.colors = cols
            if len(world.tets) >= 3 and flags['j1'] and not flags['t3']:
                flags['t3'] = True; add_timed_message("...and, LET THERE BE DARKNESS!", -20); add_timed_message("So light can be seen!", 20)

        if flags['t3']:
            past_clump.update(len(world.tets), time_scale)
            if len(particles) != len(world.tets) * 5:
                particles = [np.random.uniform(-1, 1, 3) for _ in range(len(world.tets) * 5)]

            time_lerp = np.clip((time_scale - 0.1) / 9.9, 0, 1)
            bg_color_alt = np.array([30,0,0]) * (1-time_lerp) + np.array([10,10,20]) * time_lerp
            screen.fill(np.clip(bg_color_alt, 0, 255))

            particle_color = np.clip(np.array([120, 100, 100]) + min(len(world.tets), 50), 0, 255)
            for p in particles:
                screen_pos = cam.project(p * MAX_DIST_FROM_ORIGIN * 1.5)
                screen.set_at(screen_pos, particle_color)

            cam_forward = np.array([math.sin(cam.yaw)*math.cos(cam.pitch), -math.sin(cam.pitch), math.cos(cam.yaw)*math.cos(cam.pitch)])
            dot_backward = np.dot(norm(cam.pan - (cam.pan - cam_forward)), [0,0,-1])
            dot_forward = np.dot(norm(cam.pan - (cam.pan - cam_forward)), [0,0,1])

            if dot_backward > 0.5:
                for t in past_clump.tets:
                    screen_pts = [cam.project(v) for v in t.verts()]
                    try:
                        pygame.draw.polygon(screen, t.colors[0], [screen_pts[i] for i in t.faces[0]])
                    except: pass
        else:
             screen.fill((255,255,255) if flags['j1'] else (10,10,20))

        axis_colors = [(255, 0, 0), (255, 255, 255), (0, 255, 255)]
        center = world.center_of_mass
        for i, color in enumerate(axis_colors):
            pos_vec, neg_vec = np.zeros(3), np.zeros(3); pos_vec[i], neg_vec[i] = AXIS_LEN, -AXIS_LEN
            pygame.draw.line(screen, color, cam.project(neg_vec + center), cam.project(pos_vec + center), 2)

        for avatar_id, avatar_data in list(net_avatars.items()):
            if 'pos' in avatar_data and 'color' in avatar_data: draw_avatar(screen, cam, avatar_data['pos'], avatar_data['color'])
        orange = (255, 140, 0); gray = (100, 100, 100)
        if is_interactive and dragging and locked_sticky_target:
            t_drag, i_drag, _ = dragging; t_snap, j_snap = locked_sticky_target
            start_pos = cam.project(t_drag.verts()[i_drag]); end_pos = cam.project(t_snap.verts()[j_snap])
            pygame.draw.line(screen, orange, start_pos, end_pos, 2)
        for t1, i1, t2, i2 in world.sticky_pairs:
            p1, p2 = cam.project(t1.verts()[i1]), cam.project(t2.verts()[i2]); pygame.draw.line(screen, orange, p1, p2, 1)
        for j in world.joints:
            p1 = cam.project(j.A.verts()[j.ia]); p2 = cam.project(j.B.verts()[j.ib])
            pygame.draw.line(screen, gray, p1, p2, 1)
        for t in sorted(world.tets, key=lambda t: cam.get_transformed_z(t.pos), reverse=True):
            world_verts, screen_pts = t.verts(), [cam.project(v) for v in t.verts()]
            sorted_faces = sorted(t.faces, key=lambda face: sum(cam.get_transformed_z(world_verts[i]) for i in face), reverse=True)
            if t.colors:
                for face_indices in sorted_faces:
                    face_pts = [screen_pts[i] for i in face_indices]; original_face_index = t.faces.index(face_indices)
                    pygame.draw.polygon(screen, t.colors[original_face_index], face_pts); pygame.draw.aalines(screen, (0,0,0), True, face_pts)
            else:
                bright_color = np.array((200, int(200*t.battery), 255-int(200*t.battery))); ambient_color = bright_color * 0.35
                for face_indices in sorted_faces: pygame.draw.polygon(screen, np.clip(ambient_color, 0, 255), [screen_pts[i] for i in face_indices])
                for i, j in t.edges: pygame.draw.line(screen, bright_color, screen_pts[i], screen_pts[j], 1)
            vert_col = (0,0,0) if (flags['j1'] and not flags['t3']) else (255,255,255)
            for p in screen_pts: pygame.draw.circle(screen, vert_col, p, 1)
            if t.label:
                label_surf = font_s.render(t.label, True, (255,255,0))
                label_pos = cam.project(t.pos + np.array([0, EDGE_LEN * 4, 0]))
                screen.blit(label_surf, label_surf.get_rect(center=label_pos))
        if is_interactive and hovered_vertex:
            t, i = hovered_vertex; p = cam.project(t.verts()[i]); pygame.draw.circle(screen, (255,255,0), p, 4, 1)

        if flags['t3'] and dot_forward > 0.7:
            void_radius = int((WIDTH / 2.2) * np.clip((time_scale - 0.1) / 9.9, 0, 1))
            pygame.draw.circle(screen, (0,0,0), (WIDTH//2, HEIGHT//2), void_radius)

        now_ticks = pygame.time.get_ticks(); now_time = time.time(); msgs = [m for m in msgs if now_ticks < m[2]]
        text_color = (0,0,0) if (flags['j1'] and not flags['t3']) else (200,200,200)
        for text_string, y_offset, end_time in msgs:
            surf = font_l.render(text_string, True, text_color); surf.set_alpha(max(0, min(255, (end_time - now_ticks) / 1000 * 255)))
            screen.blit(surf, surf.get_rect(center=(WIDTH//2, HEIGHT//2 + y_offset)))
        for i, (text, end_time) in enumerate(list(net_messages)):
            if now_time > end_time: net_messages.popleft()
            else:
                surf = font_s.render(text, True, (255, 200, 100)); surf.set_alpha(max(0, min(255, (end_time - now_time) * 100)))
                screen.blit(surf, (10, 40 + i * 25))

        fps_text = f"FPS: {int(fps)}"; fps_surf = font_s.render(fps_text, True, (255, 255, 0)); screen.blit(fps_surf, (10, 10))

        zoom_factor = DEFAULT_CAM_DIST / cam.dist
        zoom_text = f"{zoom_factor:.2f}x"
        if zoom_factor < 0.1: zoom_text = f"{zoom_factor:.4f}x"
        elif zoom_factor > 10: zoom_text = f"{zoom_factor:.1f}x"

        mode_text = f"Mode: {game_mode.replace('_', ' ').title()} | Tets: {len(world.tets)} | Joints: {len(world.joints)} | Desires: {len(world.sticky_pairs)} | Zoom: {zoom_text} | Z/C Time ({time_scale:.1f}x)"
        if governor_active and time_scale > 1 and is_interactive: mode_text += " (GOV)"
        top_leg = font_s.render(mode_text, True, (0,255,255))
        top_leg_rect = top_leg.get_rect(center=(WIDTH // 2, 10 + top_leg.get_height() // 2))
        screen.blit(top_leg, top_leg_rect)

        leg_text = "WASD/RMB View | QE Pan | R/F/Wheel Zoom | 'V' Save | H Host | TAB Join | ~ Reset | X Center"
        bot_leg = font_s.render(leg_text, True, (0, 255, 255)); screen.blit(bot_leg, (WIDTH//2 - bot_leg.get_width()//2, HEIGHT-25))

        pygame.display.flip()

    if host_instance: host_instance.stop()
    if guest_instance: guest_instance.stop()
    pygame.quit(); sys.exit()

if __name__ == "__main__":
    main()




------------------v2.1 optimized

PSEUDOCODE="""

TetCraft Program Explained in Pseudo-Code
1. Configuration & Constants

This section defines the global parameters that govern the simulation's behavior.

code
Code
download
content_copy
expand_less
// -- Core Simulation --
EDGE_LEN = 2.0                // The fixed length of a tetrahedron edge
COLLISION_RADIUS = 1.5        // The size of a tetrahedron for collision
DAMPING = 0.995               // Energy loss factor for Verlet integration

// -- Metaphysical / Behavioral Laws (Refactored) --
K_ORIGIN_PULL = 0.00005       // Gentle pull towards the universe's center of mass

// [Critique #3] Cohesion based on Harmony
K_STICKY_PULL = 0.001         // Base strength of the "desire" connection
STICKY_PULL_HARMONY_SENSITIVITY = 0.1 // How sensitive the pull is to energy differences

// [Critique #2] Magnetism as a Memory-Based Influence
K_MAGNETIC_TORQUE = 0.05      // Strength of the rotational "nudge" from magnetism
K_MAGNETIC_BIAS_BUILDUP = 0.1 // How quickly magnetic memory forms
MAGNETIC_BIAS_DECAY = 0.998   // How slowly magnetic memory fades (hysteresis)

// -- Energy and Emergent Containment (Refactored) --
// [Critique #1] Replaced hard walls with a "cold edge"
BATTERY_CHARGE_RATE = 0.03    // Rate of energy gain near the center
BATTERY_DRAIN_RATE = 0.005    // Base rate of energy loss
CRITICAL_RADIUS = 1200        // Distance from origin where energy drain becomes severe
2. Main Data Structures (Classes)

These are the primary objects that make up the simulation world.

code
Code
download
content_copy
expand_less
CLASS Camera:
    PROPERTIES:
        yaw, pitch, distance, pan_vector(x,y,z)
    METHODS:
        project(world_vec): Converts a 3D world coordinate to a 2D screen coordinate.
        unproject(screen_pos, depth): Converts a 2D screen coordinate back to 3D.
        zoom(factor): Adjusts the camera distance.

CLASS Tetrahedron:
    PROPERTIES:
        id
        position(x,y,z), previous_position(x,y,z)       // For Verlet physics
        local_vertices[4], previous_local_vertices[4]   // Stores shape/rotation
        battery (0.0 to 1.0)                            // Represents energy or "heat"
        is_magnetized (boolean)
        magnetism (polarity: +1 or -1)
        orientation_bias(x,y,z)                         // [Critique #2] Vector storing magnetic memory

CLASS World:
    PROPERTIES:
        list_of_tetrahedrons
        list_of_joints
        list_of_sticky_pairs (desires)
        center_of_mass_vector
    METHODS:
        spawn(): Creates a new tetrahedron.
        update(dt): Runs one full physics and logic tick for the entire simulation.
        get_state(): Serializes the entire world state into a dictionary for saving/networking.
        set_state(state_dict): Reconstructs the world from a saved state.
3. Core Physics Engine (JIT-Optimized Functions)

These are the high-performance Numba functions that handle all the heavy calculations. They operate on large NumPy arrays for maximum speed.

code
Code
download
content_copy
expand_less
FUNCTION world_update_physics_jit(all_positions, all_batteries, ...):
    // This is the heart of the "Law of Universal Balance"

    1. // -- Gravity & Cohesion --
       Initialize an `acceleration` array for all tets to zeros.
       Apply a gentle `K_ORIGIN_PULL` towards the center of mass for all tets.

    2. // [Critique #3] Apply Desire Forces (Cohesion Law)
       FOR each sticky_pair (desire):
           Calculate the energy difference between the two connected tets.
           Calculate a `harmony_factor` = 1 / (energy_difference + sensitivity).
           The force of the desire is `K_STICKY_PULL * harmony_factor`.
           Apply this force to pull the two tets together.

    3. // [Critique #1] Apply Energy Dynamics & Emergent Containment
       Calculate each tet's distance from the origin.
       IF a tet is past the `CRITICAL_RADIUS`:
           Calculate a `drain_multiplier` that increases sharply with distance.
           Apply a severe energy drain: `battery -= drain_rate * drain_multiplier`.
       ELSE:
           Apply normal energy charge/drain rates.
       Clip all battery values between 0 and 1.

    4. // [Critique #1] Apply Battery Force & Emergent Orbital Stability
       Calculate the implicit tangential velocity for each tet.
       Calculate a `repulsion_damp_factor` based on this velocity (faster = more dampening).
       Calculate the base battery force (attraction if cold, repulsion if hot).
       IF the force is repulsive:
           Multiply it by the `repulsion_damp_factor`.
       Apply the final (potentially dampened) battery force.

    5. // -- Verlet Integration --
       Update all `positions` based on `previous_positions` and accumulated `accelerations`.

    6. // -- Internal Shape Constraint --
       Iterate 3 times:
           FOR each tetrahedron:
               Check the length of all 6 internal edges.
               If an edge is too long or too short, slightly move its two vertices to correct the length.
       RETURN updated positions, batteries, etc.

FUNCTION update_magnetic_effects_jit(all_locals, all_biases, ...):
    // This function handles the "Law of Magnetic Constraint" as a memory-based influence.

    1. // [Critique #2] Update Magnetic Memory (Hysteresis)
       FOR each magnetized tet (`tet_A`):
           Calculate the net magnetic field vector at its position from all OTHER magnets.
           Nudge `tet_A`'s `orientation_bias` vector towards this net field.
           Apply a slow decay to the `orientation_bias` (`bias *= MAGNETIC_BIAS_DECAY`).

    2. // [Critique #2] Apply Torque
       Calculate the magnetic moment of `tet_A` (its internal magnetic direction).
       Calculate the `torque` required to align the moment with the (net_field + orientation_bias).
       Apply this `torque` as a small, cumulative rotation to `tet_A`'s local vertices.

    RETURN updated local vertices and orientation biases.

FUNCTION conserve_momentum_jit(...)
    Calculate the total momentum of the entire system.
    Subtract the average momentum from every tetrahedron to prevent the whole system from drifting.

FUNCTION resolve_collisions_jit(...)
    Use a k-d tree to find all pairs of tets that are too close.
    For each overlapping pair, push them directly apart.
4. Networking Subsystem

Handles multiplayer functionality, clearly separating the "host" (who runs the simulation) from "guests" (who just receive updates).

code
Code
download
content_copy
expand_less
CLASS Host:
    Starts a server and listens for connecting guests.
    Maintains a list of connected clients.
    Periodically calls `world.get_state()` and broadcasts the result to all guests.
    Receives camera position updates from guests to display their avatars.

CLASS Guest:
    Connects to a host's IP address.
    Runs a listener thread in the background.
    WHEN a 'world_state' message is received:
        It overwrites its local world by calling `world.set_state(received_state)`.
    Periodically sends its own camera position to the host.
5. Main Application Logic (The main function)

This is the high-level conductor that orchestrates initialization, the game loop, input, and rendering.

code
Code
download
content_copy
expand_less
PROCEDURE main():
    // -- 1. Initialization --
    Initialize Pygame, the screen, and the clock.
    Create a `World` object and a `Camera` object.
    Start a background thread to "prime" (pre-compile) all JIT functions while showing an intro screen.
    Check for command-line arguments to start as a host, connect as a guest, or load a file.
    IF no arguments are given:
        Attempt to load `tetcraft_save.json`.
        IF no save file, show a "void screen" until the user presses SPACE to spawn the first tet.

    // -- 2. Main Game Loop --
    LOOP forever:
        // -- A. Timekeeping --
        Calculate `delta_time` since the last frame.
        Update the simulation `time_scale` based on key presses (Z/C keys) or animations.
        `scaled_dt = delta_time * time_scale`.

        // -- B. Input Handling --
        Process all Pygame events (quit, resize, keyboard, mouse).
        Handle camera movement (WASD, QE, mouse drag).
        Handle simulation controls (SPACE to spawn, `~` to reset, V to save).
        Handle networking controls (H to host, TAB to join).

        // -- C. Physics & State Update --
        IF game_mode is 'single_player' OR 'host':
            // We are in charge of the simulation
            CALL `world.update(scaled_dt)`.
            IF game_mode is 'host':
                Broadcast the world state to all guests.
        ELSE IF game_mode is 'guest':
            // We are just a viewer, so we load the state received from the network
            IF a new state has arrived from the host:
                CALL `world.set_state(latest_received_state)`.
            Send our camera position back to the host.

        // -- D. Rendering --
        Clear the screen with the appropriate background color (changes with game progress).
        Draw decorative elements (axes, background particle field).
        Draw lines for all joints (white) and desires (orange).
        Get a list of all tetrahedrons and sort them by their distance from the camera (depth sorting).
        FOR each tetrahedron IN the sorted list:
            Determine its color based on its state (normal, magnetized).
            Sort its 4 faces by their distance from the camera.
            Draw each face as a filled polygon.
            Draw the edges of the tetrahedron.
        Draw all UI overlays (FPS, info text, help text, chat messages).

        // -- E. Display --
        Flip the Pygame display to show the newly drawn frame.
    END LOOP

    // -- 3. Cleanup --
    Stop any running network threads.
    Quit Pygame.
END PROCEDURE
"""
PSEUDOCODE="""

TetCraft Program Explained in Pseudo-Code
1. Configuration & Constants

This section defines the global parameters that govern the simulation's behavior.

code
Code
download
content_copy
expand_less
// -- Core Simulation --
EDGE_LEN = 2.0                // The fixed length of a tetrahedron edge
COLLISION_RADIUS = 1.5        // The size of a tetrahedron for collision
DAMPING = 0.995               // Energy loss factor for Verlet integration

// -- Metaphysical / Behavioral Laws (Refactored) --
K_ORIGIN_PULL = 0.00005       // Gentle pull towards the universe's center of mass

// [Critique #3] Cohesion based on Harmony
K_STICKY_PULL = 0.001         // Base strength of the "desire" connection
STICKY_PULL_HARMONY_SENSITIVITY = 0.1 // How sensitive the pull is to energy differences

// [Critique #2] Magnetism as a Memory-Based Influence
K_MAGNETIC_TORQUE = 0.05      // Strength of the rotational "nudge" from magnetism
K_MAGNETIC_BIAS_BUILDUP = 0.1 // How quickly magnetic memory forms
MAGNETIC_BIAS_DECAY = 0.998   // How slowly magnetic memory fades (hysteresis)

// -- Energy and Emergent Containment (Refactored) --
// [Critique #1] Replaced hard walls with a "cold edge"
BATTERY_CHARGE_RATE = 0.03    // Rate of energy gain near the center
BATTERY_DRAIN_RATE = 0.005    // Base rate of energy loss
CRITICAL_RADIUS = 1200        // Distance from origin where energy drain becomes severe
2. Main Data Structures (Classes)

These are the primary objects that make up the simulation world.

code
Code
download
content_copy
expand_less
CLASS Camera:
    PROPERTIES:
        yaw, pitch, distance, pan_vector(x,y,z)
    METHODS:
        project(world_vec): Converts a 3D world coordinate to a 2D screen coordinate.
        unproject(screen_pos, depth): Converts a 2D screen coordinate back to 3D.
        zoom(factor): Adjusts the camera distance.

CLASS Tetrahedron:
    PROPERTIES:
        id
        position(x,y,z), previous_position(x,y,z)       // For Verlet physics
        local_vertices[4], previous_local_vertices[4]   // Stores shape/rotation
        battery (0.0 to 1.0)                            // Represents energy or "heat"
        is_magnetized (boolean)
        magnetism (polarity: +1 or -1)
        orientation_bias(x,y,z)                         // [Critique #2] Vector storing magnetic memory

CLASS World:
    PROPERTIES:
        list_of_tetrahedrons
        list_of_joints
        list_of_sticky_pairs (desires)
        center_of_mass_vector
    METHODS:
        spawn(): Creates a new tetrahedron.
        update(dt): Runs one full physics and logic tick for the entire simulation.
        get_state(): Serializes the entire world state into a dictionary for saving/networking.
        set_state(state_dict): Reconstructs the world from a saved state.
3. Core Physics Engine (JIT-Optimized Functions)

These are the high-performance Numba functions that handle all the heavy calculations. They operate on large NumPy arrays for maximum speed.

code
Code
download
content_copy
expand_less
FUNCTION world_update_physics_jit(all_positions, all_batteries, ...):
    // This is the heart of the "Law of Universal Balance"

    1. // -- Gravity & Cohesion --
       Initialize an `acceleration` array for all tets to zeros.
       Apply a gentle `K_ORIGIN_PULL` towards the center of mass for all tets.

    2. // [Critique #3] Apply Desire Forces (Cohesion Law)
       FOR each sticky_pair (desire):
           Calculate the energy difference between the two connected tets.
           Calculate a `harmony_factor` = 1 / (energy_difference + sensitivity).
           The force of the desire is `K_STICKY_PULL * harmony_factor`.
           Apply this force to pull the two tets together.

    3. // [Critique #1] Apply Energy Dynamics & Emergent Containment
       Calculate each tet's distance from the origin.
       IF a tet is past the `CRITICAL_RADIUS`:
           Calculate a `drain_multiplier` that increases sharply with distance.
           Apply a severe energy drain: `battery -= drain_rate * drain_multiplier`.
       ELSE:
           Apply normal energy charge/drain rates.
       Clip all battery values between 0 and 1.

    4. // [Critique #1] Apply Battery Force & Emergent Orbital Stability
       Calculate the implicit tangential velocity for each tet.
       Calculate a `repulsion_damp_factor` based on this velocity (faster = more dampening).
       Calculate the base battery force (attraction if cold, repulsion if hot).
       IF the force is repulsive:
           Multiply it by the `repulsion_damp_factor`.
       Apply the final (potentially dampened) battery force.

    5. // -- Verlet Integration --
       Update all `positions` based on `previous_positions` and accumulated `accelerations`.

    6. // -- Internal Shape Constraint --
       Iterate 3 times:
           FOR each tetrahedron:
               Check the length of all 6 internal edges.
               If an edge is too long or too short, slightly move its two vertices to correct the length.
       RETURN updated positions, batteries, etc.

FUNCTION update_magnetic_effects_jit(all_locals, all_biases, ...):
    // This function handles the "Law of Magnetic Constraint" as a memory-based influence.

    1. // [Critique #2] Update Magnetic Memory (Hysteresis)
       FOR each magnetized tet (`tet_A`):
           Calculate the net magnetic field vector at its position from all OTHER magnets.
           Nudge `tet_A`'s `orientation_bias` vector towards this net field.
           Apply a slow decay to the `orientation_bias` (`bias *= MAGNETIC_BIAS_DECAY`).

    2. // [Critique #2] Apply Torque
       Calculate the magnetic moment of `tet_A` (its internal magnetic direction).
       Calculate the `torque` required to align the moment with the (net_field + orientation_bias).
       Apply this `torque` as a small, cumulative rotation to `tet_A`'s local vertices.

    RETURN updated local vertices and orientation biases.

FUNCTION conserve_momentum_jit(...)
    Calculate the total momentum of the entire system.
    Subtract the average momentum from every tetrahedron to prevent the whole system from drifting.

FUNCTION resolve_collisions_jit(...)
    Use a k-d tree to find all pairs of tets that are too close.
    For each overlapping pair, push them directly apart.
4. Networking Subsystem

Handles multiplayer functionality, clearly separating the "host" (who runs the simulation) from "guests" (who just receive updates).

code
Code
download
content_copy
expand_less
CLASS Host:
    Starts a server and listens for connecting guests.
    Maintains a list of connected clients.
    Periodically calls `world.get_state()` and broadcasts the result to all guests.
    Receives camera position updates from guests to display their avatars.

CLASS Guest:
    Connects to a host's IP address.
    Runs a listener thread in the background.
    WHEN a 'world_state' message is received:
        It overwrites its local world by calling `world.set_state(received_state)`.
    Periodically sends its own camera position to the host.
5. Main Application Logic (The main function)

This is the high-level conductor that orchestrates initialization, the game loop, input, and rendering.

code
Code
download
content_copy
expand_less
PROCEDURE main():
    // -- 1. Initialization --
    Initialize Pygame, the screen, and the clock.
    Create a `World` object and a `Camera` object.
    Start a background thread to "prime" (pre-compile) all JIT functions while showing an intro screen.
    Check for command-line arguments to start as a host, connect as a guest, or load a file.
    IF no arguments are given:
        Attempt to load `tetcraft_save.json`.
        IF no save file, show a "void screen" until the user presses SPACE to spawn the first tet.

    // -- 2. Main Game Loop --
    LOOP forever:
        // -- A. Timekeeping --
        Calculate `delta_time` since the last frame.
        Update the simulation `time_scale` based on key presses (Z/C keys) or animations.
        `scaled_dt = delta_time * time_scale`.

        // -- B. Input Handling --
        Process all Pygame events (quit, resize, keyboard, mouse).
        Handle camera movement (WASD, QE, mouse drag).
        Handle simulation controls (SPACE to spawn, `~` to reset, V to save).
        Handle networking controls (H to host, TAB to join).

        // -- C. Physics & State Update --
        IF game_mode is 'single_player' OR 'host':
            // We are in charge of the simulation
            CALL `world.update(scaled_dt)`.
            IF game_mode is 'host':
                Broadcast the world state to all guests.
        ELSE IF game_mode is 'guest':
            // We are just a viewer, so we load the state received from the network
            IF a new state has arrived from the host:
                CALL `world.set_state(latest_received_state)`.
            Send our camera position back to the host.

        // -- D. Rendering --
        Clear the screen with the appropriate background color (changes with game progress).
        Draw decorative elements (axes, background particle field).
        Draw lines for all joints (white) and desires (orange).
        Get a list of all tetrahedrons and sort them by their distance from the camera (depth sorting).
        FOR each tetrahedron IN the sorted list:
            Determine its color based on its state (normal, magnetized).
            Sort its 4 faces by their distance from the camera.
            Draw each face as a filled polygon.
            Draw the edges of the tetrahedron.
        Draw all UI overlays (FPS, info text, help text, chat messages).

        // -- E. Display --
        Flip the Pygame display to show the newly drawn frame.
    END LOOP

    // -- 3. Cleanup --
    Stop any running network threads.
    Quit Pygame.
END PROCEDURE
"""
import pygame
import numpy as np
import math
import random
import sys
import os
import json
from collections import deque
import socket
import threading
import select
import time

# +++ OPTIMIZATION IMPORTS +++
from numba import njit
from scipy.spatial import cKDTree

# ============================
# CONFIG
# ============================
WIDTH, HEIGHT = 1200, 800
FPS = 60

EDGE_LEN = 2.0
SNAP_DIST = 0.75
AXIS_LEN = 20

# --- REFACTORED COHESION CONSTANTS ---
K_STICKY_PULL = 0.001
STICKY_PULL_HARMONY_SENSITIVITY = 0.1
STICKY_EXPONENTIAL_THRESHOLD = 100.0 * EDGE_LEN
NEIGHBOR_DESIRE_THRESHOLD = 1000.0 * EDGE_LEN

DEFAULT_PORT = 65420
PORT_RANGE = range(DEFAULT_PORT, DEFAULT_PORT + 10)
DISCOVERY_PORT = 65419

# --- VERLET PHYSICS CONSTANTS ---
DAMPING = 0.995
MOUSE_PULL_STRENGTH = 0.0005
BODY_PULL_STRENGTH = 0.0008
COLLISION_RADIUS = EDGE_LEN * 0.75

# --- REFACTORED MAGNETISM CONSTANTS ---
K_MAGNETIC_TORQUE = 0.05
K_MAGNETIC_BIAS_BUILDUP = 0.1
MAGNETIC_BIAS_DECAY = 0.998
MAGNETIC_EPSILON_SQ = 0.1

# --- CAMERA CONTROL CONSTANTS ---
ORBIT_SPEED = 1.5
PAN_SPEED = 200.0
ZOOM_SPEED = 1.05
FOCAL_LENGTH = 650.0
DEFAULT_CAM_DIST = 70.0
MIN_ZOOM_DIST = DEFAULT_CAM_DIST / 100.0
MAX_ZOOM_DIST = DEFAULT_CAM_DIST / 0.01

# =========================================================================
# v3.0 UNIFIED LAW OF BALANCE CONSTANTS
# =========================================================================
K_UNIFIED_FORCE = 0.0000002

# --- AMBIENT ENERGY FIELD PARAMETERS ---
FIELD_AMPLITUDE = 1.2
FIELD_SCALE = 250.0
FIELD_LINEAR_DECAY = 0.0001
FIELD_QUADRATIC_DECAY = 0.000001

# --- ENERGY EQUILIBRIUM PARAMETERS ---
ENERGY_EQUILIBRIUM_RATE = 0.05
# =========================================================================

SAVE_FILENAME = "tetcraft_save.json"

class NumpyEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, np.ndarray): return obj.tolist()
        if isinstance(obj, np.integer): return int(obj)
        if isinstance(obj, np.floating): return float(obj)
        return json.JSONEncoder.default(self, obj)

# ============================
# OPTIMIZED JIT FUNCTIONS
# ============================
@njit(fastmath=True, cache=True)
def norm_njit(v):
    norm = np.sqrt(v[0]**2 + v[1]**2 + v[2]**2)
    if norm > 1e-9:
        return v / norm
    return np.zeros_like(v)

@njit(fastmath=True, cache=True)
def norm_axis_njit(arr):
    out = np.empty_like(arr)
    for i in range(arr.shape[0]):
        norm_val = np.sqrt(arr[i,0]**2 + arr[i,1]**2 + arr[i,2]**2)
        if norm_val > 1e-9:
            out[i] = arr[i] / norm_val
        else:
            out[i, :] = 0.0
    return out

@njit(fastmath=True, cache=True)
def get_ambient_energy_field(dist_from_origin):
    exp_term = FIELD_AMPLITUDE * np.exp(-(dist_from_origin / FIELD_SCALE)**2)
    linear_decay = FIELD_LINEAR_DECAY * dist_from_origin
    quadratic_decay = FIELD_QUADRATIC_DECAY * dist_from_origin**2
    return exp_term - linear_decay - quadratic_decay

@njit(fastmath=True, cache=True)
def project_many_jit(vecs, pan, yaw, pitch, dist, width, height):
    cy, sy = math.cos(yaw), math.sin(yaw)
    cp, sp = math.cos(pitch), math.sin(pitch)
    transformed = vecs - pan
    x, y, z = transformed[:, 0], transformed[:, 1], transformed[:, 2]
    x_rot = cy * x - sy * z
    z_rot = sy * x + cy * z
    y_rot = cp * y - sp * z_rot
    z_final = sp * y + cp * z_rot
    depth = dist + z_final
    depth[np.abs(depth) < 0.1] = 0.1
    scale = FOCAL_LENGTH / depth
    screen_x = width / 2 + x_rot * scale
    screen_y = height / 2 - y_rot * scale
    screen_x[depth <= 0.1] = -1000
    screen_y[depth <= 0.1] = -1000
    return np.stack((screen_x, screen_y), axis=1)

@njit(fastmath=True, cache=True)
def get_transformed_z_many_jit(vecs, pan, yaw, pitch):
    cy, sy = math.cos(yaw), math.sin(yaw)
    cp, sp = math.cos(pitch), math.sin(pitch)
    transformed = vecs - pan
    x, y, z = transformed[:, 0], transformed[:, 1], transformed[:, 2]
    zz = sy * x + cy * z
    zz2 = sp * y + cp * zz
    return zz2

@njit(fastmath=True, cache=True)
def world_update_physics_jit(
    positions, positions_prev, locals, locals_prev, batteries,
    scaled_dt, time_scale, edges, sticky_pairs_data
):
    num_tets = positions.shape[0]
    dt_sq = scaled_dt * scaled_dt
    acc = np.zeros_like(positions)

    dist_from_origin = np.sqrt(np.sum(positions**2, axis=1))
    ambient_energies = get_ambient_energy_field(dist_from_origin)
    energy_delta = ambient_energies - batteries
    force_magnitudes = energy_delta * K_UNIFIED_FORCE * (dist_from_origin + 1.0)
    radial_directions = norm_axis_njit(positions)
    acc += radial_directions * force_magnitudes[:, np.newaxis]

    energy_transfer = (ambient_energies - batteries) * ENERGY_EQUILIBRIUM_RATE * scaled_dt
    batteries += energy_transfer
    batteries = np.clip(batteries, 0.0, 1.0)

    for i in range(sticky_pairs_data.shape[0]):
        idx1, v_idx1, idx2, v_idx2 = sticky_pairs_data[i]
        p1 = positions[idx1] + locals[idx1, v_idx1]
        p2 = positions[idx2] + locals[idx2, v_idx2]
        delta = p2 - p1
        dist = np.linalg.norm(delta)
        if dist > 1e-6:
            battery_diff = abs(batteries[idx1] - batteries[idx2])
            harmony_factor = 1.0 / (battery_diff + STICKY_PULL_HARMONY_SENSITIVITY)
            harmony_factor = min(harmony_factor, 1.0 / STICKY_PULL_HARMONY_SENSITIVITY)
            force_magnitude = K_STICKY_PULL * harmony_factor
            if dist > STICKY_EXPONENTIAL_THRESHOLD:
                multiplier = (dist / STICKY_EXPONENTIAL_THRESHOLD)**2
                multiplier = min(100.0, multiplier)
                force_magnitude *= multiplier
            force_vec = delta / dist * force_magnitude
            acc[idx1] += force_vec
            acc[idx2] -= force_vec

    pos_temp = positions.copy()
    positions += (positions - positions_prev) * DAMPING + acc * dt_sq
    positions_prev[:] = pos_temp

    local_temp = locals.copy()
    locals += (locals - locals_prev) * DAMPING
    locals_prev[:] = local_temp
    mean_centers = np.sum(locals, axis=1) / 4.0
    locals -= mean_centers[:, np.newaxis, :]
    for _ in range(3):
        p1 = locals[:, edges[:, 0], :]
        p2 = locals[:, edges[:, 1], :]
        delta = p2 - p1
        dist = np.sqrt(np.sum(delta**2, axis=2))
        mask = dist > 1e-6
        safe_dist = np.where(mask, dist, 1.0)
        diff = (safe_dist - EDGE_LEN) / safe_dist * 0.5
        correction = delta * diff[:, :, np.newaxis]
        for i in range(num_tets):
            if not np.any(mask[i]): continue
            for j in range(edges.shape[0]):
                if mask[i, j]:
                    locals[i, edges[j, 0], :] += correction[i, j, :]
                    locals[i, edges[j, 1], :] -= correction[i, j, :]
    return positions, positions_prev, locals, locals_prev, batteries

@njit(fastmath=True, cache=True)
def update_magnetic_effects_jit(locals_arr, orientation_biases, positions, magnet_indices, magnet_polarities, scaled_dt):
    num_magnets = magnet_indices.shape[0]
    orientation_biases *= MAGNETIC_BIAS_DECAY
    if num_magnets < 2: return locals_arr, orientation_biases

    for i_idx, tet_idx1 in enumerate(magnet_indices):
        net_b_field = np.zeros(3)
        for j_idx, tet_idx2 in enumerate(magnet_indices):
            if tet_idx1 == tet_idx2: continue
            delta = positions[tet_idx2] - positions[tet_idx1]
            dist_sq = np.dot(delta, delta)
            if dist_sq > 1e-6:
                field_strength = magnet_polarities[j_idx] / (dist_sq + MAGNETIC_EPSILON_SQ)
                net_b_field += delta * (field_strength / np.sqrt(dist_sq))

        bias = orientation_biases[tet_idx1]
        bias += (net_b_field - bias) * K_MAGNETIC_BIAS_BUILDUP * scaled_dt
        orientation_biases[tet_idx1] = bias

        moment_vec = norm_njit(locals_arr[tet_idx1, 0]) * magnet_polarities[i_idx]
        total_field = net_b_field + bias
        torque_vec = np.cross(moment_vec, total_field)
        torque_magnitude = np.linalg.norm(torque_vec)
        if torque_magnitude > 1e-6:
            rotation_amount = torque_magnitude * K_MAGNETIC_TORQUE * scaled_dt
            for v_idx in range(4):
                 rotated_vec = locals_arr[tet_idx1, v_idx] + np.cross(torque_vec, locals_arr[tet_idx1, v_idx]) * rotation_amount
                 locals_arr[tet_idx1, v_idx] = rotated_vec
    return locals_arr, orientation_biases

@njit(fastmath=True, cache=True)
def conserve_momentum_jit(positions, positions_prev):
    num_tets = positions.shape[0]
    if num_tets == 0: return positions_prev
    velocities = positions - positions_prev
    total_momentum = np.sum(velocities, axis=0)
    avg_momentum = total_momentum / num_tets
    new_velocities = velocities - avg_momentum
    positions_prev = positions - new_velocities
    return positions_prev

@njit(fastmath=True, cache=True)
def resolve_collisions_jit(positions, pairs):
    min_dist_sq = (COLLISION_RADIUS * 2) ** 2
    for i, j in pairs:
        delta = positions[j] - positions[i]
        dist_sq = np.dot(delta, delta)
        if 1e-6 < dist_sq < min_dist_sq:
            dist = np.sqrt(dist_sq)
            overlap = (np.sqrt(min_dist_sq) - dist) * 0.5
            correction = delta / dist * overlap
            positions[i] -= correction
            positions[j] += correction
    return positions

@njit(fastmath=True, cache=True)
def resolve_joints_jit(locals_arr, joints_data):
    for i in range(joints_data.shape[0]):
        a_idx, ia, b_idx, ib = joints_data[i]
        p1 = locals_arr[a_idx, ia]
        p2 = locals_arr[b_idx, ib]
        delta = p2 - p1
        dist = np.sqrt(np.dot(delta, delta))
        if dist > 1e-6:
            diff = 0.5
            correction = delta * (diff / dist)
            locals_arr[a_idx, ia] += correction
            locals_arr[b_idx, ib] -= correction
    return locals_arr

# ============================
# CAMERA & CORE CLASSES
# ============================
class Camera:
    def __init__(self):
        self.yaw, self.pitch, self.dist, self.pan = 0.0, 0.35, DEFAULT_CAM_DIST, np.zeros(3)
    def get_transformed_z(self, v):
        v = v - self.pan; cy, sy = math.cos(self.yaw), math.sin(self.yaw); cp, sp = math.cos(self.pitch), math.sin(self.pitch)
        x, y, z = v; zz = sy*x + cy*z; zz2 = sp*y + cp*zz
        return zz2
    def project(self, v):
        global WIDTH, HEIGHT
        v = v - self.pan; cy, sy = math.cos(self.yaw), math.sin(self.yaw); cp, sp = math.cos(self.pitch), math.sin(self.pitch)
        x, y, z = v; x, z = cy*x - sy*z, sy*x + cy*z; y, z = cp*y - sp*z, sp*y + cp*z
        depth = self.dist + z
        if depth <= 0.1: return (-1000, -1000)
        scale = FOCAL_LENGTH / depth
        return (WIDTH//2 + int(x * scale), HEIGHT//2 - int(y * scale))
    def project_many(self, vecs):
        global WIDTH, HEIGHT
        return project_many_jit(vecs, self.pan, self.yaw, self.pitch, self.dist, WIDTH, HEIGHT)
    def get_transformed_z_many(self, vecs):
        return get_transformed_z_many_jit(vecs, self.pan, self.yaw, self.pitch)
    def unproject(self, screen_pos, depth_z):
        global WIDTH, HEIGHT; mx, my = screen_pos
        scale = FOCAL_LENGTH / (self.dist + depth_z + 1e-9)
        if abs(scale) < 1e-9: return self.pan
        x_cam = (mx - WIDTH // 2) / scale; y_cam = -(my - HEIGHT // 2) / scale
        cy, sy = math.cos(self.yaw), math.sin(self.yaw); cp, sp = math.cos(self.pitch), math.sin(self.pitch)
        y_rot, z_rot = cp * y_cam + sp * depth_z, -sp * y_cam + cp * depth_z
        x_world, z_world = cy * x_cam + sy * z_rot, -sy * x_cam + cy * z_rot
        return np.array([x_world, y_rot, z_world]) + self.pan
    def zoom(self, factor): self.dist = np.clip(self.dist * factor, MIN_ZOOM_DIST, MAX_ZOOM_DIST)
    def get_state(self): return {'yaw': self.yaw, 'pitch': self.pitch, 'dist': self.dist, 'pan': self.pan}
    def set_state(self, state): self.yaw, self.pitch, self.dist, self.pan = state['yaw'], state['pitch'], state['dist'], np.array(state['pan'])

@njit(cache=True)
def norm(v):
    n = np.linalg.norm(v); return v / n if n > 1e-9 else np.zeros_like(v)
@njit(cache=True)
def dist_point_to_line_segment(p, a, b):
    ap = p - a; ab = b - a
    t = np.dot(ap, ab) / (np.dot(ab, ab) + 1e-9)
    t = max(0, min(1, t))
    closest = a + t * ab
    return np.linalg.norm(p - closest)

def generate_boing_sound():
    mixer_settings = pygame.mixer.get_init()
    if mixer_settings is None: return None
    sample_rate, _, channels = mixer_settings; duration = 0.2; num_samples = int(duration * sample_rate)
    t = np.linspace(0, duration, num_samples, False); freq = np.linspace(660.0, 220.0, num_samples); wave = np.sin(2 * np.pi * freq * t) * np.exp(-t * 10)
    sound_array = (wave * 32767).astype(np.int16)
    if channels == 2: sound_array = np.column_stack((sound_array, sound_array))
    return pygame.sndarray.make_sound(sound_array)

class VertexJoint:
    def __init__(self, A, ia, B, ib): self.A, self.ia, self.B, self.ib = A, ia, B, ib

class Tetrahedron:
    EDGES_NP = np.array([(i, j) for i in range(4) for j in range(i+1, 4)], dtype=np.int32)
    FACES_NP = np.array([(1, 2, 3), (0, 1, 2), (0, 2, 3), (0, 1, 3)], dtype=np.int32)
    FACE_COLORS = [(255,255,255), (0,0,0), (255,0,0), (0,255,255)]
    FACE_POLARITY_MAP = {2: 1, 3: -1}
    r, a = EDGE_LEN*math.sqrt(3/8), EDGE_LEN/math.sqrt(3)
    REST_NP = np.array([[0,0,r], [EDGE_LEN/2,-a/2,-r/3], [-EDGE_LEN/2,-a/2,-r/3], [0,a,-r/3]], dtype=np.float64)
    def __init__(self, pos):
        self.pos = np.array(pos, float); self.pos_prev = self.pos.copy()
        self.local = self.REST_NP.copy(); self.local_prev = self.local.copy()
        self.battery = random.uniform(0.3, 0.6)
        self.orientation_bias = np.zeros(3, dtype=np.float64)
        self.colors = None; self.label = ""; self.id = id(self)
        self.is_magnetized = False; self.magnetism = 0
    def verts(self): return self.local + self.pos

class PastTetrahedron(Tetrahedron):
    def __init__(self, pos):
        super().__init__(pos)
        self.colors = [(0,0,0)] * 4

class PastClump:
    def __init__(self):
        self.tets = []
        self.yaw, self.pitch, self.roll = 0, 0, 0
        self.pos = np.array([0, 0, -2500])
    def update(self, num_tets_in_world, time_scale, center_of_mass):
        self.pos = center_of_mass + np.array([0, 0, -2500])
        target_num_tets = max(1, num_tets_in_world - 3)
        while len(self.tets) < target_num_tets: self.tets.append(PastTetrahedron(np.random.uniform(-10, 10, 3)))
        while len(self.tets) > target_num_tets: self.tets.pop()
        spin_factor = (time_scale - 1.0) * 0.5
        if time_scale < 0.5: spin_factor += (0.5 - time_scale) * 2.0
        if time_scale > 7.5: spin_factor += (time_scale - 7.5) * 0.5
        self.yaw += 0.002 * spin_factor; self.pitch += 0.003 * spin_factor; self.roll += 0.005 * spin_factor
        cy, sy = math.cos(self.yaw), math.sin(self.yaw); cp, sp = math.cos(self.pitch), math.sin(self.pitch); cr, sr = math.cos(self.roll), math.sin(self.roll)
        rot_matrix = np.array([[cp*cy, sp*sr - cp*sy*cr, sp*cr + cp*sy*sr], [sy, cy*cr, -cy*sr], [-sp*cy, cp*sr + sp*sy*cr, cp*cr - sp*sy*sr]])
        color_lerp = np.clip((time_scale - 0.5) / 7.0, 0, 1)
        color = np.array([180, 50, 50]) * color_lerp + np.array([50, 50, 180]) * (1 - color_lerp)
        for i, tet in enumerate(self.tets):
            offset = np.array([math.sin(i*2.1), math.cos(i*1.7), math.sin(i*0.8)]) * (len(self.tets) * 3)
            tet.pos = self.pos + np.dot(rot_matrix, offset)
            tet.local = np.dot(tet.REST_NP, rot_matrix.T)
            tet.colors = [np.clip(color, 0, 255)] * 4

class World:
    def __init__(self, sound):
        self.tets, self.joints, self.sticky_pairs = [], [], []; self.center_of_mass, self.sound = np.zeros(3), sound
    def spawn(self, give_special_colors=False):
        if self.tets:
            parent_tet = random.choice(self.tets); parent_vertex_pos = parent_tet.verts()[random.randint(0, 3)]
            offset_dir = norm(np.random.uniform(-1, 1, 3)); spawn_pos = parent_vertex_pos + offset_dir * (COLLISION_RADIUS * 2.1)
            new_tet = Tetrahedron(spawn_pos)
        else: new_tet = Tetrahedron(np.random.uniform(-8, 8, 3) + self.center_of_mass)
        if give_special_colors:
            cols = [(255,255,255), (0,0,0), (255,0,0), (0,255,255)]; random.shuffle(cols); new_tet.colors = cols
        else: new_tet.colors = list(Tetrahedron.FACE_COLORS)
        self.tets.append(new_tet)
    def spawn_polar_pair(self):
        if not self.tets: return
        parent_tet = random.choice(self.tets); pos1 = parent_tet.pos + norm(np.random.rand(3)) * EDGE_LEN * 5
        pos2 = pos1 + norm(np.random.rand(3)) * EDGE_LEN * 3; tet1, tet2 = Tetrahedron(pos1), Tetrahedron(pos2)
        self.tets.extend([tet1, tet2]); polar_face_idx = random.choice([2, 3]); face_verts = Tetrahedron.FACES_NP[polar_face_idx]
        for i in range(3): self.sticky_pairs.append((tet1, face_verts[i], tet2, face_verts[i]))
    def check_magnetization(self):
        tet_map = {t.id: t for t in self.tets}
        for t in self.tets: t.is_magnetized, t.magnetism = False, 0
        for t in self.tets:
            joints_by_partner = {}
            for j in self.joints:
                partner_id, my_idx = (j.B.id, j.ia) if j.A.id == t.id else ((j.A.id, j.ib) if j.B.id == t.id else (None, None))
                if partner_id:
                    if partner_id not in joints_by_partner: joints_by_partner[partner_id] = set()
                    joints_by_partner[partner_id].add(my_idx)
            for partner_id, connected_indices in joints_by_partner.items():
                for face_idx, polarity in Tetrahedron.FACE_POLARITY_MAP.items():
                    face_verts = set(Tetrahedron.FACES_NP[face_idx])
                    if connected_indices.issuperset(face_verts):
                        t.is_magnetized, t.magnetism = True, polarity
                        partner_tet = tet_map.get(partner_id)
                        if partner_tet: partner_tet.is_magnetized, partner_tet.magnetism = True, polarity
                        break
                if t.is_magnetized: break
    def explode(self):
        self.joints.clear(); self.sticky_pairs.clear()
        for t in self.tets: t.pos_prev = t.pos - np.random.uniform(-1, 1, 3); t.local_prev = t.local - np.random.uniform(-0.5, 0.5, (4,3))
    def try_snap(self, A, ia, B, ib):
        for j in self.joints:
            if (j.A.id, j.ia, j.B.id, j.ib) in [(A.id,ia,B.id,ib), (B.id,ib,A.id,ia)]: return
        self.joints.append(VertexJoint(A, ia, B, ib))
        if self.sound: self.sound.play()
    def calculate_dynamic_center(self):
        if not self.tets: return np.zeros(3)
        return np.mean(np.array([t.pos for t in self.tets]), axis=0)

    def update(self, scaled_dt, unscaled_dt, time_scale, add_msg_fn):
        if not self.tets: return
        self.check_magnetization()
        self.center_of_mass = self.calculate_dynamic_center()

        positions, positions_prev = np.array([t.pos for t in self.tets]), np.array([t.pos_prev for t in self.tets])
        locals_arr, locals_prev = np.array([t.local for t in self.tets]), np.array([t.local_prev for t in self.tets])
        batteries, id_to_idx = np.array([t.battery for t in self.tets]), {t.id: i for i, t in enumerate(self.tets)}
        orientation_biases = np.array([t.orientation_bias for t in self.tets])
        sticky_pairs_data = np.array([[id_to_idx[p[0].id], p[1], id_to_idx[p[2].id], p[3]] for p in self.sticky_pairs if p[0].id in id_to_idx and p[2].id in id_to_idx], dtype=np.int32) if self.sticky_pairs else np.empty((0, 4), dtype=np.int32)

        positions, positions_prev, locals_arr, locals_prev, batteries = world_update_physics_jit(
            positions, positions_prev, locals_arr, locals_prev, batteries,
            scaled_dt, time_scale, Tetrahedron.EDGES_NP, sticky_pairs_data
        )

        magnet_indices = np.array([i for i, t in enumerate(self.tets) if t.is_magnetized], dtype=np.int32)
        magnet_polarities = np.array([t.magnetism for t in self.tets if t.is_magnetized], dtype=np.float64)
        locals_arr, orientation_biases = update_magnetic_effects_jit(locals_arr, orientation_biases, positions, magnet_indices, magnet_polarities, scaled_dt)

        positions_prev = conserve_momentum_jit(positions, positions_prev)

        tree = cKDTree(positions)
        if len(self.tets) >= 2:
            distances, indices = tree.query(positions, k=2); stray_indices = np.where(distances[:, 1] > NEIGHBOR_DESIRE_THRESHOLD)[0]
            if stray_indices.size > 0:
                existing_connections = set(tuple(sorted((j.A.id, j.B.id))) for j in self.joints)
                existing_connections.update(set(tuple(sorted((p[0].id, p[2].id))) for p in self.sticky_pairs))
                for idx in stray_indices:
                    stray_tet, neighbor_tet = self.tets[idx], self.tets[indices[idx, 1]]
                    if tuple(sorted((stray_tet.id, neighbor_tet.id))) in existing_connections: continue
                    self.sticky_pairs.append((stray_tet, random.randint(0, 3), neighbor_tet, random.randint(0, 3)))
                    add_msg_fn("Forced Desire to prevent drifting", duration=2); break

        pairs = tree.query_pairs(r=COLLISION_RADIUS * 2)
        if pairs: positions = resolve_collisions_jit(positions, np.array(list(pairs)))

        if self.joints:
            joint_data = [[id_to_idx.get(j.A.id), j.ia, id_to_idx.get(j.B.id), j.ib] for j in self.joints if id_to_idx.get(j.A.id) is not None and id_to_idx.get(j.B.id) is not None]
            if joint_data:
                joint_data_np = np.array(joint_data, dtype=np.int32)
                for _ in range(3): locals_arr = resolve_joints_jit(locals_arr, joint_data_np)

        for pair in self.sticky_pairs[:]:
            t1, i1, t2, i2 = pair; idx1, idx2 = id_to_idx.get(t1.id), id_to_idx.get(t2.id)
            if idx1 is None or idx2 is None: continue
            p1, p2 = locals_arr[idx1, i1] + positions[idx1], locals_arr[idx2, i2] + positions[idx2]
            if np.linalg.norm(p2 - p1) < SNAP_DIST: self.try_snap(t1, i1, t2, i2); self.sticky_pairs.remove(pair)

        for i, t in enumerate(self.tets):
            t.pos, t.pos_prev, t.local, t.local_prev, t.battery, t.orientation_bias = positions[i], positions_prev[i], locals_arr[i], locals_prev[i], batteries[i], orientation_biases[i]

    def get_state(self):
        tet_states = [{'id': t.id, 'pos': t.pos, 'pos_prev': t.pos_prev, 'local': t.local, 'local_prev': t.local_prev, 'battery': t.battery, 'colors': t.colors, 'label': t.label, 'orientation_bias': t.orientation_bias} for t in self.tets]
        joint_states = [{'A_id': j.A.id, 'ia': j.ia, 'B_id': j.B.id, 'ib': j.ib} for j in self.joints]
        return {'tets': tet_states, 'joints': joint_states}
    def set_state(self, state):
        self.tets.clear(); self.joints.clear(); self.sticky_pairs.clear(); tet_map = {}
        for ts in state['tets']:
            t = Tetrahedron(ts['pos'])
            t.id = ts['id']
            t.pos_prev = np.array(ts['pos_prev'])
            t.local = np.array(ts['local'])
            t.local_prev = np.array(ts['local_prev'])
            t.battery = ts['battery']
            t.colors = ts['colors']
            t.label = ts.get('label', "")
            # Safely load orientation_bias, providing a default for older save files
            t.orientation_bias = np.array(ts.get('orientation_bias', [0.0, 0.0, 0.0]))
            self.tets.append(t)
            tet_map[t.id] = t
        for js in state['joints']:
            if js['A_id'] in tet_map and js['B_id'] in tet_map:
                self.joints.append(VertexJoint(tet_map[js['A_id']], js['ia'], tet_map[js['B_id']], js['ib']))

net_avatars = {}; net_messages = deque(maxlen=5); game_mode = 'single_player'; host_instance, guest_instance = None, None

def prime_jit_functions(cam):
    num_dummy = 4; dummy_pos = np.random.rand(num_dummy, 3) * 100; dummy_pos_prev = dummy_pos.copy()
    dummy_locals = np.random.rand(num_dummy, 4, 3); dummy_locals_prev = dummy_locals.copy(); dummy_batteries = np.random.rand(num_dummy)
    dummy_edges, dummy_sticky_pairs = Tetrahedron.EDGES_NP, np.array([[0, 0, 1, 1], [2, 3, 1, 0]], dtype=np.int32)
    dummy_magnet_indices, dummy_magnet_polarities, dummy_orientation_biases, dummy_joints = np.array([0, 1], dtype=np.int32), np.array([1.0, -1.0], dtype=np.float64), np.zeros((num_dummy, 3)), np.array([[0, 2, 3, 1]], dtype=np.int32)
    _ = norm_njit(np.array([1.0, 2.0, 3.0])); _ = norm_axis_njit(dummy_pos); _ = project_many_jit(dummy_pos, cam.pan, cam.yaw, cam.pitch, cam.dist, WIDTH, HEIGHT); _ = get_transformed_z_many_jit(dummy_pos, cam.pan, cam.yaw, cam.pitch)
    _ = world_update_physics_jit(dummy_pos, dummy_pos_prev, dummy_locals, dummy_locals_prev, dummy_batteries, 1/60.0, 1.0, dummy_edges, dummy_sticky_pairs)
    _ = update_magnetic_effects_jit(dummy_locals, dummy_orientation_biases, dummy_pos, dummy_magnet_indices, dummy_magnet_polarities, 1/60.0)
    _ = conserve_momentum_jit(dummy_pos, dummy_pos_prev); _ = resolve_collisions_jit(dummy_pos, np.array([[0, 1], [2, 3]])); _ = resolve_joints_jit(dummy_locals, dummy_joints)

def show_intro(screen, cam):
    font_lg, font_sm, font_jit = pygame.font.SysFont('Arial Black', min(WIDTH, HEIGHT)//8), pygame.font.SysFont('Arial', min(WIDTH, HEIGHT)//25), pygame.font.SysFont('Monospace', 18)
    threading.Thread(target=prime_jit_functions, args=(cam,), daemon=True).start()
    while threading.active_count() > 1:
        for e in pygame.event.get():
            if e.type == pygame.QUIT: pygame.quit(); sys.exit()
        screen.fill((10,10,20)); title, sub = font_lg.render("TET~CRAFT", True, (255, 50, 50)), font_sm.render("A Klein-a-verse of your own!", True, (255, 255, 255))
        screen.blit(title, title.get_rect(center=(WIDTH//2, HEIGHT//2-50))); screen.blit(sub, sub.get_rect(center=(WIDTH//2, HEIGHT//2+50))); jit_surf = font_jit.render("Confining Universe...", True, (0, 255, 0)); screen.blit(jit_surf, (10, 10))
        if pygame.time.get_ticks() % 1000 < 500: screen.blit(font_jit.render("_", True, (0, 255, 0)), (10 + jit_surf.get_width(), 10))
        pygame.display.flip(); clock.tick(30)

def show_void_screen(screen, world):
    font_lg, font_sm = pygame.font.SysFont('Georgia', 40), pygame.font.SysFont('Arial', 24); line1, line2 = font_lg.render("Welcome to the void of (mis)understanding...", True, (200,200,200)), font_sm.render("(Press SPACE to begin)", True, (150,150,150))
    waiting = True
    while waiting:
        for e in pygame.event.get():
            if e.type == pygame.QUIT: pygame.quit(); sys.exit()
            if e.type == pygame.KEYDOWN and e.key == pygame.K_SPACE: world.spawn(); waiting = False
        screen.fill((10,10,20)); screen.blit(line1, line1.get_rect(center=(WIDTH//2, HEIGHT//2-30))); screen.blit(line2, line2.get_rect(center=(WIDTH//2, HEIGHT//2+30))); pygame.display.flip(); clock.tick(15)

def draw_avatar(screen, cam, pos, color):
    r, a = EDGE_LEN*math.sqrt(3/8), EDGE_LEN/math.sqrt(3); base_verts = np.array([[0,0,r], [EDGE_LEN/2,-a/2,-r/3], [-EDGE_LEN/2,-a/2,-r/3], [0,a,-r/3]])
    verts1, verts2 = base_verts + pos, np.array([v * [1,-1,1] for v in base_verts]) + pos; all_verts = np.vstack([verts1, np.array([verts2[0], verts2[2], verts2[1], verts2[3]])]); screen_pts_list, faces = [cam.project(v) for v in all_verts], [(0,1,3), (0,2,1), (0,3,2), (1,2,3), (4,5,7), (4,6,5), (4,7,6), (5,6,7)]
    for face_indices in sorted(faces, key=lambda face: sum(cam.get_transformed_z(all_verts[i]) for i in face), reverse=True):
        face_pts = [screen_pts_list[i] for i in face_indices]
        try: pygame.draw.polygon(screen, color, face_pts); pygame.draw.aalines(screen, (20,20,20), True, face_pts)
        except: pass

def get_user_input(screen, prompt, initial_text=""):
    input_text, font, active = initial_text, pygame.font.SysFont(None, 32), True
    while active:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN: active = False
                elif event.key == pygame.K_BACKSPACE: input_text = input_text[:-1]
                else: input_text += event.unicode
        screen.fill((10,10,20)); prompt_surf, input_surf = font.render(prompt, True, (255,255,255)), font.render(input_text, True, (255,255,0)); screen.blit(prompt_surf, (WIDTH//2 - prompt_surf.get_width()//2, HEIGHT//2 - 50)); screen.blit(input_surf, (WIDTH//2 - input_surf.get_width()//2, HEIGHT//2)); pygame.display.flip(); clock.tick(30)
    return input_text

def send_msg(sock, msg_dict):
    try: msg_json = json.dumps(msg_dict, cls=NumpyEncoder).encode('utf-8'); sock.sendall(len(msg_json).to_bytes(4, 'big') + msg_json)
    except (ConnectionResetError, BrokenPipeError, OSError): pass

def recv_msg(sock):
    try:
        len_bytes = sock.recv(4)
        if not len_bytes: return None
        msg_len, data = int.from_bytes(len_bytes, 'big'), b''
        while len(data) < msg_len:
            packet = sock.recv(msg_len - len(data))
            if not packet: return None
            data += packet
        return json.loads(data.decode('utf-8'))
    except (ConnectionResetError, json.JSONDecodeError, ValueError, OSError): return None

class Host:
    def __init__(self, world, add_msg_fn, port=None):
        self.world, self.add_msg, self.clients, self.lock, self.server, self.port, self.running = world, add_msg_fn, {}, threading.Lock(), socket.socket(socket.AF_INET, socket.SOCK_STREAM), 0, True
        for p in ([port] if port else PORT_RANGE):
            try: self.server.bind(('', p)); self.port = p; break
            except OSError: continue
        if self.port == 0: self.server.bind(('', 0)); self.port = self.server.getsockname()[1]
        threading.Thread(target=self.discovery_thread, daemon=True).start(); threading.Thread(target=self.start, daemon=True).start()
    def discovery_thread(self):
        udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); udp_sock.bind(('', DISCOVERY_PORT))
        while self.running:
            try:
                data, addr = udp_sock.recvfrom(1024)
                if data == b"DISCOVER_TETCRAFT_HOST": udp_sock.sendto(f"TETCRAFT_HOST_HERE:{self.port}".encode('utf-8'), addr)
            except OSError: break
    def start(self):
        self.server.listen(); print(f"### HOSTING on {socket.gethostbyname(socket.gethostname())}:{self.port} ###")
        while self.running:
            try:
                client_sock, addr = self.server.accept(); client_id = f"guest_{addr[0]}:{addr[1]}"
                with self.lock: self.clients[client_sock], net_avatars[client_id] = {'id': client_id, 'addr': addr}, {'pos': [0,0,0], 'color': [random.randint(50,200) for _ in range(3)]}
                threading.Thread(target=self.handle_client, args=(client_sock, client_id), daemon=True).start()
            except OSError: break
    def handle_client(self, sock, client_id):
        while self.running:
            msg = recv_msg(sock)
            if msg is None: break
            if msg['type'] == 'cam_update':
                with self.lock:
                    if client_id in net_avatars: net_avatars[client_id]['pos'] = np.array(msg['data']['pan'])
            elif msg['type'] == 'chat': self.add_msg(f"<{client_id.split(':')[0]}>: {msg['data']}")
            elif msg['type'] == 'set_label':
                with self.lock:
                    for t in self.world.tets:
                        if t.id == msg['id']: t.label = msg['label']; break
        with self.lock: self.clients.pop(sock, None); net_avatars.pop(client_id, None); sock.close()
    def broadcast_state(self):
        state = self.world.get_state(); full_state = {'type': 'world_state', 'data': {'world': state, 'avatars': net_avatars}}
        with self.lock:
            for sock in list(self.clients.keys()): send_msg(sock, full_state)
    def stop(self):
        self.running = False
        with self.lock:
            for sock in self.clients: sock.close()
        self.server.close()

class Guest:
    def __init__(self, host_ip, port, world, cam, add_msg_fn):
        self.world, self.cam, self.add_msg, self.sock, self.host_id, self.running, self.latest_world_state = world, cam, add_msg_fn, socket.socket(socket.AF_INET, socket.SOCK_STREAM), f"host_{host_ip}:{port}", True, None
        self.sock.connect((host_ip, port)); threading.Thread(target=self.listen, daemon=True).start()
    def listen(self):
        global net_avatars
        while self.running:
            msg = recv_msg(self.sock)
            if msg is None:
                self.add_msg("Disconnected from host.")
                self.running = False
                break
            if msg['type'] == 'world_state':
                self.latest_world_state = msg['data']['world']
                net_avatars = {self.host_id: {'pos': self.latest_world_state.get('center_of_mass', [0,0,0]), 'color': (50, 50, 255)}}
                if 'avatars' in msg['data']:
                    for av_id, av_data in msg['data']['avatars'].items():
                        if av_id != 'host':
                            net_avatars[av_id] = av_data
            elif msg['type'] == 'chat': self.add_msg(f"<HOST>: {msg['data']}")
    def send_cam_update(self): send_msg(self.sock, {'type': 'cam_update', 'data': self.cam.get_state()})
    def send_chat(self, text): send_msg(self.sock, {'type': 'chat', 'data': text})
    def send_label(self, tet_id, label): send_msg(self.sock, {'type': 'set_label', 'id': tet_id, 'label': label})
    def stop(self):
        self.running = False
        try:
            self.sock.shutdown(socket.SHUT_RDWR); self.sock.close()
        except OSError: pass

def main():
    print("CLI Options:")
    print("  -connect <ip>:<port>   (Connect directly to a server)")
    print("  -listen <port>         (Launch directly as a host on a port)")
    print("  -file <filename>       (Load a specific save file on start)")
    print("TET~CRAFT Initializing...")

    cli_connect_addr, cli_listen_port, cli_load_file = None, None, None
    args = sys.argv[1:]; i = 0
    while i < len(args):
        if args[i] == '-connect' and i + 1 < len(args):
            cli_connect_addr = args[i+1]; i += 1
        elif args[i] == '-listen':
            cli_listen_port = DEFAULT_PORT
            if i + 1 < len(args) and args[i+1].isdigit():
                cli_listen_port = int(args[i+1]); i += 1
        elif args[i] == '-file' and i + 1 < len(args):
            cli_load_file = args[i+1]; i += 1
        i += 1

    global WIDTH, HEIGHT, clock, game_mode, host_instance, guest_instance, net_avatars, net_messages
    os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "1"; pygame.init(); pygame.mixer.init(44100, -16, 2, 512)
    screen = pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE); pygame.display.set_caption("TET~CRAFT")
    clock = pygame.time.Clock(); font_l = pygame.font.SysFont('Georgia', 32); font_s = pygame.font.SysFont(None, 24)
    world = World(generate_boing_sound()); cam = Camera(); show_intro(screen, cam)

    flags = {'t0': False, 't1': False, 't2': False, 'j1': False, 't3': False}; msgs = []
    dragging, rotating, last_mouse = None, False, (0,0); time_scale = 1.0; reset_timer = None
    locked_sticky_target, sticky_unlock_timer = None, None; frame_count = 0
    rmb_down_timer, rmb_start_pos = None, None; past_clump = PastClump(); particles = []
    animation_state = 'IDLE'; animation_start_time, animation_duration = 0, 0
    start_zoom, start_time_scale = 0, 1.0; t2_triggered_animation = False

    def add_timed_message(text, y_offset=0, duration=4):
        msgs.append([text, y_offset, pygame.time.get_ticks() + duration * 1000])
    def add_network_message(text):
        net_messages.append([text, time.time() + 8])

    def reset_simulation(show_message=True):
        nonlocal flags, time_scale, world, cam, dragging, rotating, locked_sticky_target, sticky_unlock_timer, animation_state, t2_triggered_animation
        global game_mode, host_instance, guest_instance, net_avatars, net_messages
        if host_instance: host_instance.stop(); host_instance = None
        if guest_instance: guest_instance.stop(); guest_instance = None
        world.tets.clear(); world.joints.clear(); world.sticky_pairs.clear()
        net_avatars.clear(); net_messages.clear()
        flags = {'t0': False, 't1': False, 't2': False, 'j1': False, 't3': False}
        cam.__init__(); time_scale = 1.0; game_mode = 'single_player'
        dragging, rotating = None, False; locked_sticky_target, sticky_unlock_timer = None, None
        animation_state = 'IDLE'; t2_triggered_animation = False
        if show_message: add_timed_message("Simulation Reset", duration=2)

    def save_world_to_file():
        if world.tets:
            with open(SAVE_FILENAME, 'w') as f: json.dump(world.get_state(), f, cls=NumpyEncoder, indent=2)
            add_timed_message(f"Saved universe to {SAVE_FILENAME}", duration=3)
    def connect_as_guest(host_ip, port):
        global guest_instance, game_mode
        try:
            save_world_to_file(); guest_instance, game_mode = Guest(host_ip, int(port), world, cam, add_network_message), 'guest'
            add_timed_message(f"Connected to {host_ip}:{port}", duration=3)
            world.tets.clear(); world.joints.clear(); world.sticky_pairs.clear(); return True
        except Exception as e:
            add_timed_message(f"Failed to connect: {e}", duration=4); return False
    def discover_and_join():
        global guest_instance, game_mode
        if game_mode != 'single_player': return
        host_addr = None
        for port in PORT_RANGE:
            try:
                with socket.create_connection(('127.0.0.1', port), timeout=0.05): host_addr = ('127.0.0.1', port); break
            except: continue
        if not host_addr:
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1); sock.settimeout(2.0)
                try:
                    sock.sendto(b"DISCOVER_TETCRAFT_HOST", ('.'.join(socket.gethostbyname(socket.gethostname()).split('.')[:-1]) + '.255', DISCOVERY_PORT)); data, addr = sock.recvfrom(1024)
                    if data.startswith(b"TETCRAFT_HOST_HERE:"): host_addr = (addr[0], int(data.split(b':')[1]))
                except: pass
        if host_addr: connect_as_guest(host_addr[0], host_addr[1])
        else:
            user_input = get_user_input(screen, "Enter Host IP:Port:")
            if user_input: connect_as_guest(*(user_input.split(':') if ':' in user_input else (user_input, DEFAULT_PORT)))
    def initiate_host_mode(port=None):
        global host_instance, game_mode
        if game_mode == 'single_player':
            host_instance, game_mode = Host(world, add_network_message, port), 'host'
            add_timed_message("Hosting Mode Activated", duration=3)

    loaded_from_save = False
    if cli_connect_addr:
        connect_as_guest(*(cli_connect_addr.split(':') if ':' in cli_connect_addr else (cli_connect_addr, DEFAULT_PORT)))
    elif cli_listen_port:
        initiate_host_mode(cli_listen_port)
    elif cli_load_file:
        if os.path.exists(cli_load_file):
            try:
                with open(cli_load_file, 'r', encoding='utf-8-sig') as f:
                    world.set_state(json.load(f))
                add_timed_message(f"Loaded {cli_load_file}"); loaded_from_save = True
            except (json.JSONDecodeError, TypeError, KeyError) as e:
                print(f"Error loading file '{cli_load_file}': {e}. Starting new universe.")
        else:
            print(f"File '{cli_load_file}' not found. Starting new universe.")

    if not (loaded_from_save or cli_connect_addr or cli_listen_port):
        show_void_screen(screen, world)

    running = True
    while running:
        unscaled_dt = min(0.1, clock.tick(FPS) / 1000.0)
        governor_active = clock.get_fps() < 55 if frame_count > 60 else False

        if animation_state != 'IDLE':
            elapsed = pygame.time.get_ticks() - animation_start_time; progress = min(1.0, elapsed / animation_duration)
            if animation_state == 'ZOOMING_OUT':
                cam.dist = start_zoom + (MAX_ZOOM_DIST - start_zoom) * progress
                if progress >= 1.0: animation_state, animation_start_time, animation_duration, start_time_scale = 'SPEEDING_UP', pygame.time.get_ticks(), 30000, time_scale
            elif animation_state == 'SPEEDING_UP':
                time_scale = start_time_scale + (10.0 - start_time_scale) * progress
                if progress >= 1.0: animation_state = 'IDLE'

        scaled_dt, frame_count, fps = unscaled_dt * time_scale, frame_count + 1, clock.get_fps()
        if 0 < fps < 45 and time_scale > 1.0: time_scale = max(1.0, time_scale * 0.99)
        is_interactive, hovered_vertex = (game_mode in ['single_player', 'host']), None

        if is_interactive and not rotating and world.tets:
            mx, my = pygame.mouse.get_pos(); all_verts_screen = cam.project_many(np.array([t.local + t.pos for t in world.tets]).reshape(-1, 3))
            dist_sq = np.sum((all_verts_screen - np.array([mx, my]))**2, axis=1); min_idx = np.argmin(dist_sq)
            if dist_sq[min_idx] < 576: hovered_vertex = (world.tets[min_idx // 4], min_idx % 4)

        for e in pygame.event.get():
            if e.type == pygame.QUIT: running = False
            if e.type == pygame.VIDEORESIZE: WIDTH, HEIGHT = e.w, e.h; screen = pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE)
            if e.type == pygame.KEYDOWN:
                if e.key == pygame.K_v and is_interactive: save_world_to_file()
                if e.key == pygame.K_BACKQUOTE and not reset_timer:
                    if is_interactive: world.explode()
                    add_timed_message("RESETTING...", duration=2); reset_timer = pygame.time.get_ticks() + 2000
                if is_interactive and e.key == pygame.K_SPACE: (world.spawn() if len(world.tets) < 2 else (world.spawn_polar_pair() if flags['j1'] else None))
                if e.key == pygame.K_x: cam.pan = world.center_of_mass.copy(); add_timed_message("Camera recentered")
                if e.key == pygame.K_h: initiate_host_mode()
                if e.key == pygame.K_TAB: discover_and_join()
                if e.key == pygame.K_t: time_scale = 1.0; add_timed_message("Time scale reset")
            if e.type == pygame.MOUSEBUTTONDOWN:
                if is_interactive and e.button == 1 and hovered_vertex:
                    dragging = (hovered_vertex[0], hovered_vertex[1], cam.get_transformed_z(hovered_vertex[0].verts()[hovered_vertex[1]]))
                    locked_sticky_target, sticky_unlock_timer = None, None
                if e.button == 3: rotating, last_mouse, rmb_down_timer, rmb_start_pos = True, e.pos, pygame.time.get_ticks(), e.pos
                if e.button == 1:
                    clicked_avatar_id = next((aid for aid, ad in net_avatars.items() if np.linalg.norm(np.array(e.pos) - cam.project(ad['pos'])) < 20), None)
                    if clicked_avatar_id:
                        chat_msg = get_user_input(screen, "Message:")
                        if chat_msg:
                            if game_mode == 'guest' and guest_instance: guest_instance.send_chat(chat_msg)
                            elif game_mode == 'host' and host_instance:
                                target_sock = next((s for s, d in host_instance.clients.items() if d['id'] == clicked_avatar_id), None)
                                if target_sock: send_msg(target_sock, {'type': 'chat', 'data': chat_msg})
                    elif is_interactive and world.joints:
                        cj = min(world.joints, key=lambda j: dist_point_to_line_segment(np.array(e.pos, float), np.array(cam.project(j.A.verts()[j.ia]), float), np.array(cam.project(j.B.verts()[j.ib]), float)), default=None)
                        if cj and dist_point_to_line_segment(np.array(e.pos, float), np.array(cam.project(cj.A.verts()[cj.ia]), float), np.array(cam.project(cj.B.verts()[cj.ib]), float)) < 5:
                            world.joints.remove(cj)
            if e.type == pygame.MOUSEBUTTONUP:
                if is_interactive and e.button == 1 and dragging and locked_sticky_target:
                    if dragging[0] != locked_sticky_target[0] or dragging[1] != locked_sticky_target[1]:
                        world.sticky_pairs.append((dragging[0], dragging[1], *locked_sticky_target))
                if e.button == 1: dragging, locked_sticky_target, sticky_unlock_timer = None, None, None
                if e.button == 3:
                    if rmb_down_timer and pygame.time.get_ticks() - rmb_down_timer < 300 and np.linalg.norm(np.array(e.pos) - rmb_start_pos) < 5 and world.tets:
                        tet_positions = np.array([t.pos for t in world.tets])
                        screen_positions = cam.project_many(tet_positions)
                        dist_sq = np.sum((screen_positions - e.pos)**2, axis=1)
                        idx = np.argmin(dist_sq)
                        if dist_sq[idx] < (20 * DEFAULT_CAM_DIST / cam.dist)**2:
                            target_tet = world.tets[idx]
                            new_label = get_user_input(screen, "Label:", target_tet.label)
                            if game_mode == 'guest' and guest_instance: guest_instance.send_label(target_tet.id, new_label)
                            else: target_tet.label = new_label
                    rotating = False
            if e.type == pygame.MOUSEWHEEL: cam.zoom(ZOOM_SPEED if e.y < 0 else 1/ZOOM_SPEED)

        keys = pygame.key.get_pressed()
        cam.pitch += ORBIT_SPEED * unscaled_dt * (int(keys[pygame.K_w]) - int(keys[pygame.K_s]))
        cam.yaw += ORBIT_SPEED * unscaled_dt * (int(keys[pygame.K_d]) - int(keys[pygame.K_a]))
        if keys[pygame.K_r]: cam.zoom(1/ZOOM_SPEED)
        if keys[pygame.K_f]: cam.zoom(ZOOM_SPEED)
        if keys[pygame.K_q] or keys[pygame.K_e]: cam.pan += np.array([math.cos(cam.yaw), 0, -math.sin(cam.yaw)]) * (1 if keys[pygame.K_q] else -1) * PAN_SPEED * unscaled_dt * cam.dist / DEFAULT_CAM_DIST
        if is_interactive and keys[pygame.K_c] and not governor_active and animation_state == 'IDLE': time_scale = min(10.0, time_scale + 2.0 * unscaled_dt)
        if is_interactive and keys[pygame.K_z] and animation_state == 'IDLE': time_scale = max(0.1, time_scale - 2.0 * unscaled_dt)

        if rotating:
            mx, my = pygame.mouse.get_pos(); cam.yaw += (mx - last_mouse[0]) * 0.005; cam.pitch = np.clip(cam.pitch - (my - last_mouse[1]) * 0.005, -1.57, 1.57); last_mouse = (mx, my)

        if is_interactive and dragging:
            t_drag, i_drag, dd = dragging; m3d = cam.unproject(pygame.mouse.get_pos(), dd); delta = m3d - t_drag.verts()[i_drag]
            t_drag.local[i_drag] += delta * MOUSE_PULL_STRENGTH; t_drag.pos += delta * BODY_PULL_STRENGTH
            mp2, best_dist = np.array(pygame.mouse.get_pos(), float), 50
            avs = cam.project_many(np.array([t.local + t.pos for t in world.tets]).reshape(-1, 3))
            current_hover_target = None
            for tidx, tt in enumerate(world.tets):
                for vidx in range(4):
                    if tt == t_drag and vidx == i_drag: continue
                    projected_start_pos = np.array(cam.project(t_drag.verts()[i_drag]), dtype=np.float64)
                    d = dist_point_to_line_segment(avs[tidx*4+vidx], projected_start_pos, mp2)
                    if d < best_dist: best_dist, current_hover_target = d, (tt, vidx)
            locked_sticky_target = current_hover_target
            if locked_sticky_target: sticky_unlock_timer = pygame.time.get_ticks() + 5000

        if is_interactive:
            world.update(scaled_dt, unscaled_dt, time_scale, add_timed_message)
            if game_mode == 'host' and host_instance and frame_count % 2 == 0: host_instance.broadcast_state()
        elif game_mode == 'guest':
            if guest_instance and guest_instance.running:
                if guest_instance.latest_world_state: world.set_state(guest_instance.latest_world_state)
                if frame_count % 5 == 0: guest_instance.send_cam_update()
                if world.tets: cam.pan = world.center_of_mass
            else:
                reset_simulation(show_message=False)
                show_void_screen(screen, world)

        if reset_timer and pygame.time.get_ticks() > reset_timer: reset_simulation(); reset_timer = None

        if is_interactive:
            if len(world.tets) == 1 and not flags['t0']: flags['t0'] = True; add_timed_message("LET THERE BE TIME!", -20); add_timed_message("... and let it have a beginning.", 20)
            if len(world.tets) >= 2 and not flags['t2']:
                flags['t2'] = True; animation_state, animation_start_time, animation_duration, start_zoom = 'ZOOMING_OUT', pygame.time.get_ticks(), 10000, cam.dist
                add_timed_message("LET THERE BE SEPARATION!", -20); add_timed_message("And let it chase time ever into the future.", 20)
                if len(world.tets) == 2:
                    world.sticky_pairs.extend([(world.tets[0], Tetrahedron.FACES_NP[2,0], world.tets[1], Tetrahedron.FACES_NP[2,0]), (world.tets[0], Tetrahedron.FACES_NP[3,0], world.tets[1], Tetrahedron.FACES_NP[3,0])])
            if len(world.tets) >= 2 and world.joints and not flags['j1']: flags['j1'] = True; add_timed_message("LET THERE BE LIGHT", -20); add_timed_message("To grow old and wise!", 20)
            if len(world.tets) >= 3 and flags['j1'] and not flags['t3']: flags['t3'] = True; add_timed_message("...and, LET THERE BE DARKNESS!", -20); add_timed_message("So light can be seen!", 20)

        tl = np.clip((time_scale - 0.1) / 9.9, 0, 1)
        bg_color = (np.array([30,0,0]) * (1-tl) + np.array([10,10,20]) * tl if flags['t3'] else ((255,255,255) if flags['j1'] else (10,10,20)))
        screen.fill(bg_color)

        if flags['t3']:
            past_clump.update(len(world.tets), time_scale, world.center_of_mass)
            if len(particles) < len(world.tets)*5: particles.extend([np.random.uniform(-1, 1, 3) for _ in range(len(world.tets)*5 - len(particles))])
            pc = np.clip(np.array([120, 100, 100]) + min(len(world.tets), 50), 0, 255)
            for p in particles:
                sp = cam.project(world.center_of_mass + p * FIELD_SCALE * 4)
                if 0 <= sp[0] < WIDTH and 0 <= sp[1] < HEIGHT: screen.set_at(sp, pc)
            cam_forward = np.array([math.sin(cam.yaw)*math.cos(cam.pitch), -math.sin(cam.pitch), math.cos(cam.yaw)*math.cos(cam.pitch)])
            if np.dot(norm(cam.pan - (cam.pan - cam_forward)), [0,0,-1]) > 0.5:
                for ptet in past_clump.tets:
                    try: pygame.draw.polygon(screen, ptet.colors[0], [cam.project(v) for v in ptet.verts()[ptet.FACES_NP[0]]])
                    except: pass

        if flags['j1']:
            ac = [(255,0,0), (255,255,255) if flags['t3'] else (0,0,0)]
            if flags['t3']: ac.append((0,255,255))
            for i, c in enumerate(ac):
                pv, nv = np.zeros(3), np.zeros(3); pv[i], nv[i] = AXIS_LEN, -AXIS_LEN
                pygame.draw.line(screen, c, cam.project(nv + world.center_of_mass), cam.project(pv + world.center_of_mass), 2)
        elif len(world.tets) > 0 and not flags['j1']: pygame.draw.circle(screen, (255,255,255), cam.project(world.center_of_mass), 3)

        if world.tets:
            awv = np.array([t.local + t.pos for t in world.tets]).reshape(-1, 3)
            id_idx = {t.id: i for i, t in enumerate(world.tets)}; asv = cam.project_many(awv).reshape(len(world.tets), 4, 2)
            if is_interactive and dragging and locked_sticky_target:
                pygame.draw.line(screen, (255, 140, 0), asv[id_idx[dragging[0].id], dragging[1]], asv[id_idx[locked_sticky_target[0].id], locked_sticky_target[1]], 2)
            for t1, i1, t2, i2 in world.sticky_pairs:
                if t1.id in id_idx and t2.id in id_idx: pygame.draw.line(screen, (255, 140, 0), asv[id_idx[t1.id], i1], asv[id_idx[t2.id], i2], 1)
            for j in world.joints:
                if j.A.id in id_idx and j.B.id in id_idx: pygame.draw.line(screen, (255, 255, 255), asv[id_idx[j.A.id], j.ia], asv[id_idx[j.B.id], j.ib], 1)

            for idx in np.argsort(cam.get_transformed_z_many(np.array([t.pos for t in world.tets]))):
                t, world_verts, screen_pts = world.tets[idx], awv[idx*4:(idx+1)*4], asv[idx]
                cc = list(t.colors) if t.colors else list(Tetrahedron.FACE_COLORS)
                if t.is_magnetized:
                    polar_idx = 2 if t.magnetism == 1 else 3; cc = [(0,0,0)]*4
                    if t.colors: cc[polar_idx] = Tetrahedron.FACE_COLORS[polar_idx]

                face_depths = np.mean(cam.get_transformed_z_many(world_verts[Tetrahedron.FACES_NP]), axis=1); sorted_face_indices = np.argsort(face_depths)

                if not flags['j1'] and not t.is_magnetized:
                    bc = np.array((200, int(200*t.battery), 255-int(200*t.battery))); am = bc * 0.35
                    for fidx in sorted_face_indices: pygame.draw.polygon(screen, np.clip(am, 0, 255), screen_pts[Tetrahedron.FACES_NP[fidx]])
                    for i, j in t.EDGES_NP: pygame.draw.line(screen, bc, screen_pts[i], screen_pts[j], 1)
                else:
                    for fidx in sorted_face_indices[::-1]: pygame.draw.polygon(screen, cc[fidx], screen_pts[Tetrahedron.FACES_NP[fidx]])
                    for i, j in t.EDGES_NP: pygame.draw.line(screen, (0,0,0), screen_pts[i], screen_pts[j], 1)

                vert_color = (0,0,0) if (flags['j1'] and not flags['t3']) else (255,255,255)
                for p in screen_pts: pygame.draw.circle(screen, vert_color, p, 1)
                if t.label: surf = font_s.render(t.label, True, (255,255,0)); screen.blit(surf, surf.get_rect(center=cam.project(t.pos + [0, 8, 0])))

        if flags['t3'] and np.dot(norm(cam.pan - (cam.pan - cam_forward)), [0,0,1]) > 0.7:
            pygame.draw.circle(screen, (0,0,0), (WIDTH//2, HEIGHT//2), int((WIDTH / 2.2) * tl))

        now_ticks = pygame.time.get_ticks(); text_color = (0,0,0) if (flags['j1'] and not flags['t3']) else (200,200,200)
        msgs = [m for m in msgs if now_ticks < m[2]]
        for ts, yo, et in msgs:
            s = font_l.render(ts, True, text_color); s.set_alpha(max(0, min(255, (et - now_ticks) * 255 / 1000)))
            screen.blit(s, s.get_rect(center=(WIDTH//2, HEIGHT//2 + yo)))

        for i, (txt, et) in enumerate(list(net_messages)):
            if time.time() > et: net_messages.popleft()
            else:
                s = font_s.render(txt, True, (255, 200, 100)); s.set_alpha(max(0, min(255, (et - time.time()) * 100))); screen.blit(s, (10, 40 + i * 25))

        screen.blit(font_s.render(f"FPS: {int(fps)}", True, (255, 255, 0)), (10, 10))
        zf = DEFAULT_CAM_DIST / cam.dist
        zoom_text = f"{zf:.1f}x" if zf > 10 else f"{zf:.4f}x" if zf < 0.1 else f"{zf:.2f}x"
        mode_text = f"Mode: {game_mode.replace('_',' ').title()} | Tets: {len(world.tets)} | Zoom: {zoom_text} | Z/C Time ({time_scale:.1f}x)"
        if governor_active and time_scale > 1: mode_text += " (GOV)"
        top_leg = font_s.render(mode_text, True, (0,255,255)); screen.blit(top_leg, top_leg.get_rect(center=(WIDTH//2, 20)))
        leg_text = "WASD/RMB View | QE Pan | R/F Zoom | V Save | H Host | TAB Join | ~ Reset | T/X Utils"
        bot_leg = font_s.render(leg_text, True, (0, 255, 255)); screen.blit(bot_leg, bot_leg.get_rect(center=(WIDTH//2, HEIGHT-25)))

        pygame.display.flip()

    if host_instance: host_instance.stop()
    if guest_instance: guest_instance.stop()
    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()
