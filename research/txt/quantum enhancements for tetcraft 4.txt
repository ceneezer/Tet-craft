# Complete TET~CRAFT with Phase 1 (Multi-Face Detection) & Phase 2 (Battery Oscillation)
# Due to size limits, copy your original code and apply these specific changes:

"""
CHANGES SUMMARY:
================
1. After MATH_SYMBOLS: Add MOLECULE_DATABASE and MOLECULE_SYMBOLS
2. In Tetrahedron class: Add FACE_COLOR_NAMES = ['W', 'B', 'R', 'C']
3. In Tetrahedron.__init__: Add magnetic_strength, locked_faces, molecule_type, aura_color
4. Replace check_magnetization() with enhanced multi-face version
5. Add update_magnetic_batteries() method after check_magnetization
6. In World.update(): Call self.update_magnetic_batteries(scaled_dt) after check_magnetization
7. In rendering loop: Add aura rendering before face_z calculation
8. In bot thoughts: Add molecule name preference logic

APPLY THESE EXACT REPLACEMENTS TO YOUR CODE:
"""

# ============================================================================
# CHANGE 1: After line with MATH_SYMBOLS, ADD:
# ============================================================================
"""
# --- MOLECULE DATABASE ---
# Format: {pattern_key: (aura_color, symbolic_name, description)}
# Pattern key: "F{faces_locked}_R{red_count}_C{cyan_count}_W{white_count}_B{black_count}"
MOLECULE_DATABASE = {
    # Single face locked (current system)
    "F1_R1_C1_W1_B1": ((255, 100, 150), "FeO4", "Iron Oxide - Magnetic Dipole"),
    "F1_R0_C0_W3_B1": ((200, 200, 255), "CH4", "Methane - Stable Neutral"),
    "F1_R3_C0_W1_B0": ((255, 50, 50), "H3O+", "Hydronium - Positive Ion"),
    "F1_R0_C3_W1_B0": ((50, 255, 255), "PO4", "Phosphate - Negative Ion"),

    # Double face locked (advanced)
    "F2_R2_C2_W0_B0": ((255, 0, 255), "SO4", "Sulfate - Balanced Dipole"),
    "F2_R2_C0_W2_B0": ((255, 200, 100), "B2O3", "Boron Oxide - Self-Repelling"),

    # Triple face locked (complex)
    "F3_R0_C3_W1_B0": ((100, 255, 200), "SiO4", "Silicate - Rock Former"),

    # Fully locked (complete cage)
    "F4_R2_C2_W0_B0": ((255, 255, 0), "CrO4", "Chromate - Stable Complex"),
}

# Symbolic names for bot thoughts (extract from database)
MOLECULE_SYMBOLS = list(set(data[1] for data in MOLECULE_DATABASE.values()))
"""

# ============================================================================
# CHANGE 2: In Tetrahedron class, AFTER "FACE_POLARITY_MAP = {2: 1, 3: -1}", ADD:
# ============================================================================
"""
    FACE_COLOR_NAMES = ['W', 'B', 'R', 'C']  # White, Black, Red, Cyan
"""

# ============================================================================
# CHANGE 3: In Tetrahedron.__init__, AFTER "self.magnetism = 0", ADD:
# ============================================================================
"""
        # PHASE 1: Enhanced magnetization tracking
        self.magnetic_strength = 0.0  # 0.0 to 1.0
        self.locked_faces = []  # List of face indices that are locked
        self.molecule_type = None  # Pattern key for molecule database
        self.aura_color = None  # RGB tuple if molecule is identified
"""

# ============================================================================
# CHANGE 4: REPLACE entire check_magnetization() method with:
# ============================================================================
"""
    def check_magnetization(self):
        \"\"\"PHASE 1: Enhanced - Detect 1-4 locked faces and identify molecule types\"\"\"
        tet_map = {t.id: t for t in self.tets}

        # Reset all magnetization
        for t in self.tets:
            t.is_magnetized = False
            t.magnetism = 0
            t.magnetic_strength = 0.0
            t.locked_faces = []
            t.molecule_type = None
            t.aura_color = None

        # Check each TET for locked faces
        for t in self.tets:
            joints_by_partner = {}
            for j in self.joints:
                partner_id, my_idx = (j.B.id, j.ia) if j.A.id == t.id else ((j.A.id, j.ib) if j.B.id == t.id else (None, None))
                if partner_id:
                    joints_by_partner.setdefault(partner_id, set()).add(my_idx)

            # Check each face for complete locking
            for face_idx in range(4):
                face_verts = set(Tetrahedron.FACES_NP[face_idx])
                for partner_id, connected_indices in joints_by_partner.items():
                    if connected_indices.issuperset(face_verts):
                        t.locked_faces.append(face_idx)

                        # First locked face determines base magnetism (backward compatibility)
                        if not t.is_magnetized:
                            polarity = Tetrahedron.FACE_POLARITY_MAP.get(face_idx, 0)
                            if polarity != 0:
                                t.is_magnetized = True
                                t.magnetism = polarity
                                partner_tet = tet_map.get(partner_id)
                                if partner_tet and not partner_tet.is_magnetized:
                                    partner_tet.is_magnetized = True
                                    partner_tet.magnetism = polarity

            # Calculate magnetic strength based on locked faces
            if t.is_magnetized and len(t.locked_faces) > 0:
                # Strength increases with more locked faces: 0.25, 0.5, 0.75, 1.0
                t.magnetic_strength = min(1.0, len(t.locked_faces) * 0.25)

            # Identify molecule type from face pattern
            if len(t.locked_faces) > 0:
                color_counts = {'R': 0, 'C': 0, 'W': 0, 'B': 0}
                for face_idx in range(4):
                    color = t.colors[face_idx] if t.colors else Tetrahedron.FACE_COLORS[face_idx]
                    # Determine color name from RGB
                    if color == (255,0,0): color_counts['R'] += 1
                    elif color == (0,255,255): color_counts['C'] += 1
                    elif color == (255,255,255): color_counts['W'] += 1
                    elif color == (0,0,0): color_counts['B'] += 1

                pattern_key = f"F{len(t.locked_faces)}_R{color_counts['R']}_C{color_counts['C']}_W{color_counts['W']}_B{color_counts['B']}"
                t.molecule_type = pattern_key

                # Check if this is a known molecule
                if pattern_key in MOLECULE_DATABASE:
                    molecule_data = MOLECULE_DATABASE[pattern_key]
                    t.aura_color = molecule_data[0]
                    # Optionally update label with symbolic name
                    if not t.label or t.label in ["Time", "Separation", "Light", "Darkness"]:
                        t.label = molecule_data[1]
"""

# ============================================================================
# CHANGE 5: AFTER check_magnetization() method, ADD this new method:
# ============================================================================
"""
    def update_magnetic_batteries(self, scaled_dt):
        \"\"\"PHASE 2: Battery oscillation - emptiness transfers between magnetic pairs\"\"\"
        if not self.joints:
            return

        # Find magnetic pairs (TETs connected by locked faces)
        tet_map = {t.id: t for t in self.tets}
        processed_pairs = set()

        for t in self.tets:
            if not t.is_magnetized or t.magnetic_strength <= 0:
                continue

            # Find magnetic partner
            for j in self.joints:
                partner_id = None
                if j.A.id == t.id:
                    partner_id = j.B.id
                elif j.B.id == t.id:
                    partner_id = j.A.id

                if partner_id and partner_id in tet_map:
                    partner = tet_map[partner_id]
                    if partner.is_magnetized:
                        # Create unique pair identifier
                        pair_key = tuple(sorted([t.id, partner_id]))
                        if pair_key in processed_pairs:
                            continue
                        processed_pairs.add(pair_key)

                        # Calculate emptiness (1 - battery)
                        emptiness_t = 1.0 - t.battery
                        emptiness_p = 1.0 - partner.battery

                        # Transfer rate based on magnetic strength and emptiness differential
                        transfer_rate = 0.1 * t.magnetic_strength * scaled_dt
                        emptiness_diff = emptiness_t - emptiness_p

                        # Transfer emptiness (which fills the other's battery)
                        transfer_amount = emptiness_diff * transfer_rate

                        # Apply transfer (clamped to prevent overshoot)
                        new_emptiness_t = emptiness_t - transfer_amount
                        new_emptiness_p = emptiness_p + transfer_amount

                        t.battery = np.clip(1.0 - new_emptiness_t, 0.0, 1.0)
                        partner.battery = np.clip(1.0 - new_emptiness_p, 0.0, 1.0)
"""

# ============================================================================
# CHANGE 6: In World.update(), REPLACE:
#   "self.check_magnetization(); self.center_of_mass = self.calculate_dynamic_center()"
# WITH:
# ============================================================================
"""
        self.check_magnetization()
        self.update_magnetic_batteries(scaled_dt)  # PHASE 2: Battery oscillation
        self.center_of_mass = self.calculate_dynamic_center()
"""

# ============================================================================
# CHANGE 7: In rendering loop, BEFORE the line:
#   "face_z = np.mean(cam.get_transformed_z_many(world_verts[Tetrahedron.FACES_NP]), axis=1)"
# ADD:
# ============================================================================
"""
                # PHASE 1: Draw molecule aura if identified
                if t.aura_color and t.magnetic_strength > 0:
                    center_screen = cam.project(t.pos)
                    if center_screen[0] > -10000:
                        aura_radius = int(EDGE_LEN * 8 * t.magnetic_strength)
                        aura_alpha = int(80 * t.magnetic_strength * combined_alpha)
                        aura_surf = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
                        for ring in range(3):
                            ring_radius = aura_radius - ring * 3
                            ring_alpha = aura_alpha // (ring + 1)
                            pygame.draw.circle(aura_surf, (*t.aura_color, ring_alpha), center_screen, ring_radius, 2)
                        screen.blit(aura_surf, (0, 0))

"""

# ============================================================================
# CHANGE 8: In bot thoughts section, REPLACE:
#   The entire "# 3. Thoughts (Every 10 mins)" block
# WITH:
# ============================================================================
"""
            # 3. Thoughts (Every 10 mins)
            if now - last_bot_thought > 600:
                if world.tets:
                    # PHASE 1: Gather both mystic words and molecule names
                    labels = [t.label for t in world.tets if t.label]
                    molecules = [t.label for t in world.tets if t.aura_color and t.label in MOLECULE_SYMBOLS]

                    if not labels: labels = ["Void", "Silence"]

                    # Prefer molecule names for chemical thoughts
                    if molecules and random.random() < 0.6:  # 60% chance to use molecules
                        thought = f"{random.choice(molecules)} {random.choice(MATH_SYMBOLS)} {random.choice(labels)}"
                    else:
                        thought = f"{random.choice(labels)} {random.choice(MATH_SYMBOLS)} {random.choice(labels)} {random.choice(MATH_SYMBOLS)} {random.choice(labels)}"
                    net_messages.append([f"[Thought]: {thought}", time.time() + 15])
                    print(f"[BOT THOUGHT] {thought}")
                last_bot_thought = now
"""

print("""
✅ Phase 1 & 2 Implementation Guide
====================================

Apply the 8 changes above to your TET~CRAFT code in order.

What you'll get:
• Multi-face locking detection (1-4 locked faces per TET)
• Magnetic strength scaling (0.25, 0.5, 0.75, 1.0)
• Molecule identification from face color patterns
• Colored auras around identified molecules
• Battery oscillation between magnetic pairs
• Bot thoughts include molecule names

Ready for Phase 3? That adds:
• Corner desires (Red seeks Cyan, Cyan seeks Red)
• Same-pole repulsion
• Negative-pole orientation toward origin
""")

















***************************************************



# Complete TET~CRAFT with Phases 1-3 (Multi-Face Detection + Battery Oscillation + Corner Desires)
# Apply these changes to your original code in order

"""
PHASE SUMMARY:
================
Phase 1: Multi-face locking detection (1-4 locked faces) + molecule identification + auras
Phase 2: Battery oscillation (emptiness transfer between magnetic pairs)
Phase 3: Corner desires (color attraction) + same-pole repulsion + orientation toward origin

CHANGES TO APPLY:
"""

# ============================================================================
# CHANGE 1: After MATH_SYMBOLS, ADD MOLECULE_DATABASE:
# ============================================================================
"""
# --- MOLECULE DATABASE ---
# Format: {pattern_key: (aura_color, symbolic_name, description)}
# Pattern key: "F{faces_locked}_R{red_count}_C{cyan_count}_W{white_count}_B{black_count}"
MOLECULE_DATABASE = {
    # Single face locked (current system)
    "F1_R1_C1_W1_B1": ((255, 100, 150), "FeO4", "Iron Oxide - Magnetic Dipole"),
    "F1_R0_C0_W3_B1": ((200, 200, 255), "CH4", "Methane - Stable Neutral"),
    "F1_R3_C0_W1_B0": ((255, 50, 50), "H3O+", "Hydronium - Positive Ion"),
    "F1_R0_C3_W1_B0": ((50, 255, 255), "PO4", "Phosphate - Negative Ion"),

    # Double face locked (advanced)
    "F2_R2_C2_W0_B0": ((255, 0, 255), "SO4", "Sulfate - Balanced Dipole"),
    "F2_R2_C0_W2_B0": ((255, 200, 100), "B2O3", "Boron Oxide - Self-Repelling"),

    # Triple face locked (complex)
    "F3_R0_C3_W1_B0": ((100, 255, 200), "SiO4", "Silicate - Rock Former"),

    # Fully locked (complete cage)
    "F4_R2_C2_W0_B0": ((255, 255, 0), "CrO4", "Chromate - Stable Complex"),
}

# Symbolic names for bot thoughts (extract from database)
MOLECULE_SYMBOLS = list(set(data[1] for data in MOLECULE_DATABASE.values()))

# PHASE 3: Corner desire and repulsion constants
K_CORNER_DESIRE = 0.002  # Attraction strength between opposite-colored corners
K_SAME_POLE_REPULSION = 0.008  # Repulsion between same-polarity magnets
K_ORIENTATION_PULL = 0.003  # Strength of negative-pole orientation toward origin
CORNER_DESIRE_RANGE = EDGE_LEN * 8.0  # Maximum distance for corner attraction
"""

# ============================================================================
# CHANGE 2: In Tetrahedron class, AFTER "FACE_POLARITY_MAP = {2: 1, 3: -1}", ADD:
# ============================================================================
"""
    FACE_COLOR_NAMES = ['W', 'B', 'R', 'C']  # White, Black, Red, Cyan

    # PHASE 3: Corner-to-face-color mapping (which corners belong to which face)
    FACE_TO_CORNERS = {
        0: [1, 2, 3],  # White face (indices into verts)
        1: [0, 1, 2],  # Black face
        2: [0, 2, 3],  # Red face
        3: [0, 1, 3]   # Cyan face
    }
"""

# ============================================================================
# CHANGE 3: In Tetrahedron.__init__, AFTER "self.magnetism = 0", ADD:
# ============================================================================
"""
        # PHASE 1: Enhanced magnetization tracking
        self.magnetic_strength = 0.0  # 0.0 to 1.0
        self.locked_faces = []  # List of face indices that are locked
        self.molecule_type = None  # Pattern key for molecule database
        self.aura_color = None  # RGB tuple if molecule is identified

        # PHASE 3: Track polarity face for orientation
        self.polarity_face_idx = None  # Which face determines polarity (2=Red=+1, 3=Cyan=-1)
"""

# ============================================================================
# CHANGE 4: REPLACE entire check_magnetization() method with:
# ============================================================================
"""
    def check_magnetization(self):
        \"\"\"PHASE 1: Enhanced - Detect 1-4 locked faces and identify molecule types\"\"\"
        tet_map = {t.id: t for t in self.tets}

        # Reset all magnetization
        for t in self.tets:
            t.is_magnetized = False
            t.magnetism = 0
            t.magnetic_strength = 0.0
            t.locked_faces = []
            t.molecule_type = None
            t.aura_color = None
            t.polarity_face_idx = None  # PHASE 3

        # Check each TET for locked faces
        for t in self.tets:
            joints_by_partner = {}
            for j in self.joints:
                partner_id, my_idx = (j.B.id, j.ia) if j.A.id == t.id else ((j.A.id, j.ib) if j.B.id == t.id else (None, None))
                if partner_id:
                    joints_by_partner.setdefault(partner_id, set()).add(my_idx)

            # Check each face for complete locking
            for face_idx in range(4):
                face_verts = set(Tetrahedron.FACES_NP[face_idx])
                for partner_id, connected_indices in joints_by_partner.items():
                    if connected_indices.issuperset(face_verts):
                        t.locked_faces.append(face_idx)

                        # First locked face determines base magnetism (backward compatibility)
                        if not t.is_magnetized:
                            polarity = Tetrahedron.FACE_POLARITY_MAP.get(face_idx, 0)
                            if polarity != 0:
                                t.is_magnetized = True
                                t.magnetism = polarity
                                t.polarity_face_idx = face_idx  # PHASE 3: Track which face
                                partner_tet = tet_map.get(partner_id)
                                if partner_tet and not partner_tet.is_magnetized:
                                    partner_tet.is_magnetized = True
                                    partner_tet.magnetism = polarity
                                    partner_tet.polarity_face_idx = face_idx  # PHASE 3

            # Calculate magnetic strength based on locked faces
            if t.is_magnetized and len(t.locked_faces) > 0:
                # Strength increases with more locked faces: 0.25, 0.5, 0.75, 1.0
                t.magnetic_strength = min(1.0, len(t.locked_faces) * 0.25)

            # Identify molecule type from face pattern
            if len(t.locked_faces) > 0:
                color_counts = {'R': 0, 'C': 0, 'W': 0, 'B': 0}
                for face_idx in range(4):
                    color = t.colors[face_idx] if t.colors else Tetrahedron.FACE_COLORS[face_idx]
                    # Determine color name from RGB
                    if color == (255,0,0): color_counts['R'] += 1
                    elif color == (0,255,255): color_counts['C'] += 1
                    elif color == (255,255,255): color_counts['W'] += 1
                    elif color == (0,0,0): color_counts['B'] += 1

                pattern_key = f"F{len(t.locked_faces)}_R{color_counts['R']}_C{color_counts['C']}_W{color_counts['W']}_B{color_counts['B']}"
                t.molecule_type = pattern_key

                # Check if this is a known molecule
                if pattern_key in MOLECULE_DATABASE:
                    molecule_data = MOLECULE_DATABASE[pattern_key]
                    t.aura_color = molecule_data[0]
                    # Optionally update label with symbolic name
                    if not t.label or t.label in ["Time", "Separation", "Light", "Darkness"]:
                        t.label = molecule_data[1]
"""

# ============================================================================
# CHANGE 5: AFTER check_magnetization() method, ADD these new methods:
# ============================================================================
"""
    def update_magnetic_batteries(self, scaled_dt):
        \"\"\"PHASE 2: Battery oscillation - emptiness transfers between magnetic pairs\"\"\"
        if not self.joints:
            return

        # Find magnetic pairs (TETs connected by locked faces)
        tet_map = {t.id: t for t in self.tets}
        processed_pairs = set()

        for t in self.tets:
            if not t.is_magnetized or t.magnetic_strength <= 0:
                continue

            # Find magnetic partner
            for j in self.joints:
                partner_id = None
                if j.A.id == t.id:
                    partner_id = j.B.id
                elif j.B.id == t.id:
                    partner_id = j.A.id

                if partner_id and partner_id in tet_map:
                    partner = tet_map[partner_id]
                    if partner.is_magnetized:
                        # Create unique pair identifier
                        pair_key = tuple(sorted([t.id, partner_id]))
                        if pair_key in processed_pairs:
                            continue
                        processed_pairs.add(pair_key)

                        # Calculate emptiness (1 - battery)
                        emptiness_t = 1.0 - t.battery
                        emptiness_p = 1.0 - partner.battery

                        # Transfer rate based on magnetic strength and emptiness differential
                        transfer_rate = 0.1 * t.magnetic_strength * scaled_dt
                        emptiness_diff = emptiness_t - emptiness_p

                        # Transfer emptiness (which fills the other's battery)
                        transfer_amount = emptiness_diff * transfer_rate

                        # Apply transfer (clamped to prevent overshoot)
                        new_emptiness_t = emptiness_t - transfer_amount
                        new_emptiness_p = emptiness_p + transfer_amount

                        t.battery = np.clip(1.0 - new_emptiness_t, 0.0, 1.0)
                        partner.battery = np.clip(1.0 - new_emptiness_p, 0.0, 1.0)

    def apply_corner_desires(self, scaled_dt):
        \"\"\"PHASE 3: Apply corner-to-corner attraction between opposite colors\"\"\"
        if len(self.tets) < 2:
            return

        # Build spatial tree for efficient corner searching
        all_corners = []
        corner_to_tet = []
        corner_colors = []

        for t in self.tets:
            verts = t.verts()
            for corner_idx in range(4):
                all_corners.append(verts[corner_idx])
                corner_to_tet.append((t, corner_idx))

                # Determine corner color (corner belongs to 3 faces, use first non-white/black)
                corner_color = None
                for face_idx in range(4):
                    if corner_idx in Tetrahedron.FACE_TO_CORNERS[face_idx]:
                        face_color = t.colors[face_idx] if t.colors else Tetrahedron.FACE_COLORS[face_idx]
                        if face_color == (255, 0, 0):  # Red
                            corner_color = 'R'
                            break
                        elif face_color == (0, 255, 255):  # Cyan
                            corner_color = 'C'
                            break
                if not corner_color:
                    corner_color = 'N'  # Neutral (white/black)
                corner_colors.append(corner_color)

        all_corners = np.array(all_corners)

        if len(all_corners) < 2:
            return

        # Build KD-tree for fast neighbor search
        tree = cKDTree(all_corners)

        # For each corner, find nearby opposite-colored corners
        for i, (t1, c1_idx) in enumerate(corner_to_tet):
            color1 = corner_colors[i]

            # Only Red and Cyan corners have desires
            if color1 not in ['R', 'C']:
                continue

            # Find nearby corners within desire range
            nearby_indices = tree.query_ball_point(all_corners[i], CORNER_DESIRE_RANGE)

            for j in nearby_indices:
                if i == j:
                    continue

                color2 = corner_colors[j]

                # Red seeks Cyan, Cyan seeks Red
                if (color1 == 'R' and color2 == 'C') or (color1 == 'C' and color2 == 'R'):
                    t2, c2_idx = corner_to_tet[j]

                    # Skip if same TET
                    if t1.id == t2.id:
                        continue

                    # Calculate attraction force
                    delta = all_corners[j] - all_corners[i]
                    dist = np.linalg.norm(delta)

                    if dist > 1e-6 and dist < CORNER_DESIRE_RANGE:
                        # Force falls off with distance
                        force_strength = K_CORNER_DESIRE * (1.0 - dist / CORNER_DESIRE_RANGE)
                        force_vec = delta / dist * force_strength

                        # Apply force to both TET's local corner and position
                        t1.local[c1_idx] += force_vec * scaled_dt * 0.5
                        t1.pos += force_vec * scaled_dt * 0.5

                        t2.local[c2_idx] -= force_vec * scaled_dt * 0.5
                        t2.pos -= force_vec * scaled_dt * 0.5

    def apply_same_pole_repulsion(self, scaled_dt):
        \"\"\"PHASE 3: Positive poles repel other positive poles\"\"\"
        positive_poles = [t for t in self.tets if t.is_magnetized and t.magnetism > 0]

        if len(positive_poles) < 2:
            return

        # Apply repulsion between all positive pole pairs
        for i, t1 in enumerate(positive_poles):
            for t2 in positive_poles[i+1:]:
                delta = t2.pos - t1.pos
                dist = np.linalg.norm(delta)

                if dist > 1e-6:
                    # Repulsion falls off with distance squared (inverse square law)
                    repulsion_strength = K_SAME_POLE_REPULSION / (dist * dist + 1.0)

                    # Scale by magnetic strength
                    repulsion_strength *= t1.magnetic_strength * t2.magnetic_strength

                    force_vec = delta / dist * repulsion_strength

                    # Push apart
                    t1.pos -= force_vec * scaled_dt
                    t2.pos += force_vec * scaled_dt

    def apply_negative_pole_orientation(self, scaled_dt):
        \"\"\"PHASE 3: Negative poles (fuller battery side) orient toward origin\"\"\"
        for t in self.tets:
            if not t.is_magnetized or t.polarity_face_idx is None:
                continue

            # Only apply to negative polarity (Cyan face = -1)
            if t.magnetism >= 0:
                continue

            # Direction to origin from TET center
            to_origin = -t.pos
            dist_to_origin = np.linalg.norm(to_origin)

            if dist_to_origin < 1e-6:
                continue

            to_origin_norm = to_origin / dist_to_origin

            # Get the negative pole face normal (the Cyan face)
            face_verts_indices = Tetrahedron.FACES_NP[t.polarity_face_idx]
            face_verts = t.local[face_verts_indices]

            # Calculate face normal
            v1 = face_verts[1] - face_verts[0]
            v2 = face_verts[2] - face_verts[0]
            face_normal = np.cross(v1, v2)
            face_normal_len = np.linalg.norm(face_normal)

            if face_normal_len < 1e-6:
                continue

            face_normal /= face_normal_len

            # Fuller battery side should point toward origin
            # If battery is high, we want the negative pole to point at origin
            orientation_strength = K_ORIENTATION_PULL * t.battery * t.magnetic_strength

            # Calculate torque to align face normal with to_origin direction
            torque_axis = np.cross(face_normal, to_origin_norm)
            torque_magnitude = np.linalg.norm(torque_axis)

            if torque_magnitude > 1e-6:
                torque_axis /= torque_magnitude

                # Apply rotation to local coordinates
                rotation_amount = torque_magnitude * orientation_strength * scaled_dt

                for v_idx in range(4):
                    # Rodrigues' rotation formula
                    rotated = (t.local[v_idx] * np.cos(rotation_amount) +
                              np.cross(torque_axis, t.local[v_idx]) * np.sin(rotation_amount) +
                              torque_axis * np.dot(torque_axis, t.local[v_idx]) * (1 - np.cos(rotation_amount)))
                    t.local[v_idx] = rotated
"""

# ============================================================================
# CHANGE 6: In World.update(), REPLACE:
#   "self.check_magnetization(); self.center_of_mass = self.calculate_dynamic_center()"
# WITH:
# ============================================================================
"""
        self.check_magnetization()
        self.update_magnetic_batteries(scaled_dt)  # PHASE 2: Battery oscillation
        self.apply_corner_desires(scaled_dt)  # PHASE 3: Color attraction
        self.apply_same_pole_repulsion(scaled_dt)  # PHASE 3: Positive repulsion
        self.apply_negative_pole_orientation(scaled_dt)  # PHASE 3: Orient to origin
        self.center_of_mass = self.calculate_dynamic_center()
"""

# ============================================================================
# CHANGE 7: In rendering loop, BEFORE the line:
#   "face_z = np.mean(cam.get_transformed_z_many(world_verts[Tetrahedron.FACES_NP]), axis=1)"
# ADD:
# ============================================================================
"""
                # PHASE 1: Draw molecule aura if identified
                if t.aura_color and t.magnetic_strength > 0:
                    center_screen = cam.project(t.pos)
                    if center_screen[0] > -10000:
                        aura_radius = int(EDGE_LEN * 8 * t.magnetic_strength)
                        aura_alpha = int(80 * t.magnetic_strength * combined_alpha)
                        aura_surf = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
                        for ring in range(3):
                            ring_radius = aura_radius - ring * 3
                            ring_alpha = aura_alpha // (ring + 1)
                            pygame.draw.circle(aura_surf, (*t.aura_color, ring_alpha), center_screen, ring_radius, 2)
                        screen.blit(aura_surf, (0, 0))

"""

# ============================================================================
# CHANGE 8: In bot thoughts section, REPLACE the entire "# 3. Thoughts" block WITH:
# ============================================================================
"""
            # 3. Thoughts (Every 10 mins)
            if now - last_bot_thought > 600:
                if world.tets:
                    # PHASE 1: Gather both mystic words and molecule names
                    labels = [t.label for t in world.tets if t.label]
                    molecules = [t.label for t in world.tets if t.aura_color and t.label in MOLECULE_SYMBOLS]

                    if not labels: labels = ["Void", "Silence"]

                    # Prefer molecule names for chemical thoughts
                    if molecules and random.random() < 0.6:  # 60% chance to use molecules
                        thought = f"{random.choice(molecules)} {random.choice(MATH_SYMBOLS)} {random.choice(labels)}"
                    else:
                        thought = f"{random.choice(labels)} {random.choice(MATH_SYMBOLS)} {random.choice(labels)} {random.choice(MATH_SYMBOLS)} {random.choice(labels)}"
                    net_messages.append([f"[Thought]: {thought}", time.time() + 15])
                    print(f"[BOT THOUGHT] {thought}")
                last_bot_thought = now
"""

print("""
✅ COMPLETE: Phases 1, 2, & 3 Implementation Guide
====================================================

PHASE 1: Multi-Face Locking ✓
  • Detects 1-4 locked faces per TET
  • Magnetic strength: 0.25 per locked face
  • Molecule identification from color patterns
  • Colored auras around identified molecules

PHASE 2: Battery Oscillation ✓
  • Emptiness transfers between magnetic pairs
  • Smooth oscillation based on magnetic strength
  • Preserves total energy in the system

PHASE 3: Corner Desires & Orientation ✓
  • Red corners seek Cyan corners (and vice versa)
  • Positive poles repel other positive poles
  • Negative poles (high battery) orient toward origin
  • Creates realistic molecular bonding behavior

BEHAVIORAL EFFECTS:
  • Molecules naturally form and stabilize
  • Same-charge compounds repel each other
  • Opposite charges attract via corners
  • Dipoles orient in the singularity field
  • Chemistry emerges from simple rules!

Apply all 8 changes to your TET~CRAFT code and watch chemistry come alive! 🧪⚛️
""")














***********************************************





# Complete TET~CRAFT Chemistry System - Phases 1-4
# Apply these changes to your original code in order

"""
COMPLETE PHASE SUMMARY:
========================
Phase 1: Multi-face locking detection + molecule identification + auras
Phase 2: Battery oscillation (emptiness transfer between magnetic pairs)
Phase 3: Corner desires + same-pole repulsion + orientation toward origin
Phase 4: Advanced chemistry - reactions, catalysts, energy release, molecule synthesis

NEW IN PHASE 4:
================
• Expanded molecule database (30+ compounds)
• Reaction system (molecules can combine/break)
• Energy release on formation (visual/audio feedback)
• Catalytic effects (some molecules help others form)
• Synthesis tracking (track molecule creation events)
• Reaction particles (visual effects for reactions)
"""

# ============================================================================
# CHANGE 1: REPLACE old MOLECULE_DATABASE with EXPANDED version:
# ============================================================================
"""
# --- EXPANDED MOLECULE DATABASE (PHASE 4) ---
# Format: {pattern_key: (aura_color, symbolic_name, description, stability, energy)}
MOLECULE_DATABASE = {
    # Single face locked - Basic compounds
    "F1_R1_C1_W1_B1": ((255, 100, 150), "FeO4", "Iron Oxide - Magnetic Dipole", 0.8, 50),
    "F1_R0_C0_W3_B1": ((200, 200, 255), "CH4", "Methane - Stable Neutral", 0.9, 30),
    "F1_R3_C0_W1_B0": ((255, 50, 50), "H3O+", "Hydronium - Positive Ion", 0.6, 80),
    "F1_R0_C3_W1_B0": ((50, 255, 255), "PO4", "Phosphate - Negative Ion", 0.6, 80),
    "F1_R2_C1_W1_B0": ((255, 150, 100), "NO3", "Nitrate - Oxidizer", 0.7, 60),
    "F1_R1_C2_W1_B0": ((100, 200, 255), "SO3", "Sulfite - Reducer", 0.7, 60),
    "F1_R1_C0_W2_B1": ((200, 150, 255), "NH3", "Ammonia - Base", 0.8, 40),
    "F1_R0_C1_W2_B1": ((150, 255, 200), "H2O", "Water - Universal", 1.0, 10),

    # Double face locked - Intermediate compounds
    "F2_R2_C2_W0_B0": ((255, 0, 255), "SO4", "Sulfate - Balanced Dipole", 0.85, 100),
    "F2_R2_C0_W2_B0": ((255, 200, 100), "B2O3", "Boron Oxide - Self-Repelling", 0.75, 90),
    "F2_R0_C2_W2_B0": ((100, 255, 255), "Ca(OH)2", "Calcium Hydroxide", 0.8, 85),
    "F2_R2_C1_W1_B0": ((255, 100, 200), "HNO3", "Nitric Acid - Strong", 0.7, 120),
    "F2_R1_C2_W1_B0": ((150, 100, 255), "H2SO4", "Sulfuric Acid - Strong", 0.7, 120),
    "F2_R1_C1_W2_B0": ((200, 255, 150), "C2H6", "Ethane - Fuel", 0.75, 70),
    "F2_R1_C1_W0_B2": ((100, 100, 200), "CO2", "Carbon Dioxide - Stable", 0.9, 50),
    "F2_R0_C0_W3_B1": ((220, 220, 255), "SiH4", "Silane - Volatile", 0.5, 110),

    # Triple face locked - Complex compounds
    "F3_R0_C3_W1_B0": ((100, 255, 200), "SiO4", "Silicate - Rock Former", 0.95, 150),
    "F3_R3_C0_W1_B0": ((255, 80, 80), "Fe2O3", "Rust - Iron Oxide", 0.9, 140),
    "F3_R2_C1_W1_B0": ((255, 150, 150), "Al2O3", "Alumina - Ceramic", 0.95, 160),
    "F3_R1_C2_W1_B0": ((150, 200, 255), "MgSO4", "Epsom Salt", 0.85, 130),
    "F3_R1_C1_W2_B0": ((200, 255, 200), "C6H12O6", "Glucose - Sugar", 0.8, 180),
    "F3_R2_C2_W0_B0": ((255, 100, 255), "CuSO4", "Copper Sulfate", 0.85, 140),
    "F3_R1_C1_W1_B1": ((180, 180, 255), "NaCl", "Salt - Ionic", 0.95, 90),

    # Fully locked - Highly stable complexes
    "F4_R2_C2_W0_B0": ((255, 255, 0), "CrO4", "Chromate - Stable Complex", 1.0, 200),
    "F4_R1_C1_W2_B0": ((150, 255, 150), "C12H22O11", "Sucrose - Complex Sugar", 0.9, 220),
    "F4_R1_C1_W1_B1": ((200, 200, 200), "CaCO3", "Limestone - Rock", 0.98, 180),
    "F4_R2_C1_W1_B0": ((255, 200, 150), "Fe3O4", "Magnetite - Magnetic", 0.95, 210),
    "F4_R1_C2_W1_B0": ((180, 220, 255), "ZnSO4", "Zinc Sulfate", 0.9, 190),
    "F4_R0_C0_W4_B0": ((255, 255, 255), "C-Diamond", "Diamond - Crystal", 1.0, 300),
    "F4_R0_C0_W0_B4": ((50, 50, 50), "C-Graphite", "Graphite - Stable", 0.98, 100),
}

# Symbolic names for bot thoughts
MOLECULE_SYMBOLS = list(set(data[1] for data in MOLECULE_DATABASE.values()))

# PHASE 3: Corner desire and repulsion constants
K_CORNER_DESIRE = 0.002
K_SAME_POLE_REPULSION = 0.008
K_ORIENTATION_PULL = 0.003
CORNER_DESIRE_RANGE = EDGE_LEN * 8.0

# PHASE 4: Reaction system constants
K_REACTION_ENERGY_RELEASE = 0.05  # Energy burst when reactions occur
REACTION_PROBABILITY_BASE = 0.001  # Base chance per frame for reactions
CATALYST_BOOST = 3.0  # Catalysts multiply reaction chance
SYNTHESIS_ENERGY_COST = 0.1  # Battery drain when forming complex molecules
REACTION_RANGE = EDGE_LEN * 4.0  # Distance for molecules to react

# PHASE 4: Catalytic molecules (these help other reactions)
CATALYSTS = ["FeO4", "CuSO4", "Fe3O4"]  # Iron-based catalysts

# PHASE 4: Synthesis reactions (simple → complex)
SYNTHESIS_REACTIONS = {
    # (reactant1, reactant2) : product
    ("H3O+", "PO4"): "H2O",  # Acid + Base → Water
    ("H2O", "H2O"): "C2H6",  # Water synthesis → Ethane
    ("CH4", "CH4"): "C2H6",  # Methane fusion
    ("H2O", "CO2"): "C6H12O6",  # Photosynthesis analog
    ("SO3", "H2O"): "H2SO4",  # Sulfuric acid formation
    ("NO3", "H2O"): "HNO3",  # Nitric acid formation
    ("FeO4", "FeO4"): "Fe2O3",  # Rust formation
    ("SiO4", "SiO4"): "C-Diamond",  # Silicon → Diamond (high pressure)
}

# PHASE 4: Decomposition reactions (complex → simple)
DECOMPOSITION_REACTIONS = {
    "H2SO4": ["SO3", "H2O"],  # Acid breaks down
    "HNO3": ["NO3", "H2O"],
    "C6H12O6": ["H2O", "CO2"],  # Sugar combustion
    "Fe2O3": ["FeO4", "FeO4"],  # Rust decomposition
}
"""

# ============================================================================
# CHANGE 2: In Tetrahedron.__init__, AFTER existing phase 3 properties, ADD:
# ============================================================================
"""
        # PHASE 4: Reaction tracking
        self.last_reaction_time = 0.0  # Time of last reaction
        self.synthesis_count = 0  # Number of times this molecule formed from reactions
        self.is_catalyst = False  # Whether this molecule catalyzes reactions
"""

# ============================================================================
# CHANGE 3: Update check_magnetization() to identify catalysts (ADD at end):
# ============================================================================
"""
                # Check if this is a known molecule
                if pattern_key in MOLECULE_DATABASE:
                    molecule_data = MOLECULE_DATABASE[pattern_key]
                    t.aura_color = molecule_data[0]
                    molecule_name = molecule_data[1]
                    # Optionally update label with symbolic name
                    if not t.label or t.label in ["Time", "Separation", "Light", "Darkness"]:
                        t.label = molecule_name
                    # PHASE 4: Check if this is a catalyst
                    t.is_catalyst = molecule_name in CATALYSTS
"""

# ============================================================================
# CHANGE 4: AFTER apply_negative_pole_orientation(), ADD these PHASE 4 methods:
# ============================================================================
"""
    def attempt_synthesis_reactions(self, scaled_dt, add_msg_fn):
        \"\"\"PHASE 4: Try to synthesize new molecules from pairs\"\"\"
        if len(self.tets) < 2:
            return

        current_time = time.time()

        # Build spatial index
        positions = np.array([t.pos for t in self.tets])
        tree = cKDTree(positions)

        # Track successful reactions this frame
        reactions_this_frame = []

        for i, t1 in enumerate(self.tets):
            # Must have a molecule type
            if not t1.label or t1.label not in MOLECULE_SYMBOLS:
                continue

            # Cooldown between reactions
            if current_time - t1.last_reaction_time < 5.0:
                continue

            # Find nearby molecules
            nearby_indices = tree.query_ball_point(positions[i], REACTION_RANGE)

            for j in nearby_indices:
                if i >= j:  # Avoid duplicate pairs
                    continue

                t2 = self.tets[j]

                # Must have a molecule type
                if not t2.label or t2.label not in MOLECULE_SYMBOLS:
                    continue

                # Cooldown check
                if current_time - t2.last_reaction_time < 5.0:
                    continue

                # Check for synthesis reaction
                reaction_key = tuple(sorted([t1.label, t2.label]))

                if reaction_key in SYNTHESIS_REACTIONS:
                    product = SYNTHESIS_REACTIONS[reaction_key]

                    # Calculate reaction probability
                    base_prob = REACTION_PROBABILITY_BASE * scaled_dt * 60  # Scale to per-second

                    # Check for nearby catalysts
                    catalyst_multiplier = 1.0
                    for t_cat in self.tets:
                        if t_cat.is_catalyst:
                            dist_to_cat = np.linalg.norm(t_cat.pos - t1.pos)
                            if dist_to_cat < REACTION_RANGE * 2:
                                catalyst_multiplier = CATALYST_BOOST
                                break

                    # Battery similarity increases reaction chance
                    battery_similarity = 1.0 - abs(t1.battery - t2.battery)
                    final_prob = base_prob * catalyst_multiplier * (0.5 + battery_similarity * 0.5)

                    if random.random() < final_prob:
                        # REACTION OCCURS!
                        # Energy release
                        energy_burst = K_REACTION_ENERGY_RELEASE

                        # Transfer energy to nearby TETs
                        for t_nearby in self.tets:
                            dist = np.linalg.norm(t_nearby.pos - t1.pos)
                            if dist < REACTION_RANGE * 1.5:
                                t_nearby.battery = min(1.0, t_nearby.battery + energy_burst * (1.0 - dist / (REACTION_RANGE * 1.5)))

                        # Change t1 to product, remove t2
                        t1.label = product
                        t1.last_reaction_time = current_time
                        t1.synthesis_count += 1

                        # Drain some battery for synthesis
                        t1.battery = max(0.1, t1.battery - SYNTHESIS_ENERGY_COST)

                        # Visual: Make t2 "evaporate" by draining battery
                        t2.battery = 0.0
                        t2.label = ""
                        t2.last_reaction_time = current_time

                        reactions_this_frame.append((t1.label, t2.label, product))

                        # Message
                        add_msg_fn(f"⚗️ Synthesized {product}!", duration=3)

                        break  # One reaction per TET per frame

        return reactions_this_frame

    def attempt_decomposition_reactions(self, scaled_dt, add_msg_fn):
        \"\"\"PHASE 4: Complex molecules can break down into simpler ones\"\"\"
        current_time = time.time()
        decompositions_this_frame = []

        for t in self.tets:
            # Only molecules with labels can decompose
            if not t.label or t.label not in MOLECULE_SYMBOLS:
                continue

            # Cooldown
            if current_time - t.last_reaction_time < 10.0:
                continue

            # Check if this molecule can decompose
            if t.label in DECOMPOSITION_REACTIONS:
                # Low battery or high entropy increases decomposition chance
                stress_factor = (1.0 - t.battery) * 2.0

                # Distance from origin (entropy) increases chance
                dist_from_origin = np.linalg.norm(t.pos - self.center_of_mass)
                entropy_factor = min(2.0, dist_from_origin / 100.0)

                decomp_prob = REACTION_PROBABILITY_BASE * 0.5 * scaled_dt * 60 * stress_factor * entropy_factor

                if random.random() < decomp_prob:
                    # DECOMPOSITION OCCURS!
                    products = DECOMPOSITION_REACTIONS[t.label]

                    # Change this TET to first product
                    old_label = t.label
                    t.label = products[0]
                    t.last_reaction_time = current_time
                    t.battery = min(1.0, t.battery + 0.2)  # Release energy

                    # Spawn second product nearby if possible
                    if len(products) > 1 and len(self.tets) < 200:  # Limit total TETs
                        offset = np.random.uniform(-1, 1, 3) * EDGE_LEN * 3
                        new_pos = t.pos + offset
                        new_tet = Tetrahedron(new_pos)
                        new_tet.label = products[1]
                        new_tet.battery = t.battery * 0.8
                        new_tet.colors = list(Tetrahedron.FACE_COLORS)
                        self.tets.append(new_tet)

                    decompositions_this_frame.append((old_label, products))
                    add_msg_fn(f"💥 {old_label} decomposed!", duration=3)

        return decompositions_this_frame

    def spawn_reaction_particles(self, screen, cam, reactions, width, height):
        \"\"\"PHASE 4: Visual effects for reactions\"\"\"
        if not hasattr(self, 'reaction_particles'):
            self.reaction_particles = []

        # Add new particles from reactions
        for r1, r2, product in reactions:
            # Find TET with product label
            for t in self.tets:
                if t.label == product:
                    particle = {
                        'pos': t.pos.copy(),
                        'vel': np.random.uniform(-1, 1, 3) * 20,
                        'color': t.aura_color if t.aura_color else (255, 255, 0),
                        'life': 1.0,
                        'size': 8
                    }
                    self.reaction_particles.append(particle)
                    # Add 5-10 particles per reaction
                    for _ in range(random.randint(4, 9)):
                        p = particle.copy()
                        p['vel'] = np.random.uniform(-1, 1, 3) * 30
                        p['color'] = tuple(np.array(p['color']) * random.uniform(0.6, 1.2))
                        self.reaction_particles.append(p)
                    break

        # Update and render particles
        particles_to_keep = []
        for p in self.reaction_particles:
            p['pos'] += p['vel'] * 0.016  # Assume 60fps
            p['vel'] *= 0.95  # Friction
            p['life'] -= 0.02

            if p['life'] > 0:
                screen_pos = cam.project(p['pos'])
                if screen_pos[0] > -10000:
                    alpha = int(p['life'] * 255)
                    size = max(1, int(p['size'] * p['life']))
                    color_with_alpha = tuple(list(p['color']) + [alpha])

                    # Draw particle
                    try:
                        particle_surf = pygame.Surface((size*2, size*2), pygame.SRCALPHA)
                        pygame.draw.circle(particle_surf, color_with_alpha, (size, size), size)
                        screen.blit(particle_surf, (screen_pos[0]-size, screen_pos[1]-size))
                    except:
                        pass

                particles_to_keep.append(p)

        self.reaction_particles = particles_to_keep
"""

# ============================================================================
# CHANGE 5: In World.update(), AFTER apply_negative_pole_orientation, ADD:
# ============================================================================
"""
        # PHASE 4: Chemistry reactions
        synthesis_reactions = self.attempt_synthesis_reactions(scaled_dt, add_msg_fn)
        decomposition_reactions = self.attempt_decomposition_reactions(scaled_dt, add_msg_fn)
"""

# ============================================================================
# CHANGE 6: In rendering, AFTER drawing all TETs, ADD:
# ============================================================================
"""
        # PHASE 4: Draw reaction particles
        if hasattr(world, 'reaction_particles'):
            # Get recent synthesis reactions for particles
            recent_synth = getattr(world, '_last_synth_reactions', [])
            world.spawn_reaction_particles(screen, cam, recent_synth, WIDTH, HEIGHT)
            world._last_synth_reactions = []  # Clear after rendering
"""

# ============================================================================
# CHANGE 7: Store reactions in World.update() so rendering can see them:
# ============================================================================
"""
        # PHASE 4: Chemistry reactions
        synthesis_reactions = self.attempt_synthesis_reactions(scaled_dt, add_msg_fn)
        decomposition_reactions = self.attempt_decomposition_reactions(scaled_dt, add_msg_fn)
        self._last_synth_reactions = synthesis_reactions  # Store for particle effects
"""

# ============================================================================
# CHANGE 8: In bot thoughts, ADD synthesis tracking:
# ============================================================================
"""
            # 3. Thoughts (Every 10 mins)
            if now - last_bot_thought > 600:
                if world.tets:
                    # Gather labels and molecules
                    labels = [t.label for t in world.tets if t.label]
                    molecules = [t.label for t in world.tets if t.aura_color and t.label in MOLECULE_SYMBOLS]

                    # PHASE 4: Track synthesis champions
                    synthesized = [t for t in world.tets if t.synthesis_count > 0]
                    if synthesized:
                        champion = max(synthesized, key=lambda t: t.synthesis_count)
                        if random.random() < 0.3:  # 30% chance
                            thought = f"{champion.label} ∫ synthesized {champion.synthesis_count}× ∞"
                            net_messages.append([f"[Thought]: {thought}", time.time() + 15])
                            print(f"[BOT THOUGHT] {thought}")
                            last_bot_thought = now
                            continue

                    if not labels: labels = ["Void", "Silence"]

                    # Prefer molecule names for chemical thoughts
                    if molecules and random.random() < 0.6:
                        thought = f"{random.choice(molecules)} {random.choice(MATH_SYMBOLS)} {random.choice(labels)}"
                    else:
                        thought = f"{random.choice(labels)} {random.choice(MATH_SYMBOLS)} {random.choice(labels)} {random.choice(MATH_SYMBOLS)} {random.choice(labels)}"
                    net_messages.append([f"[Thought]: {thought}", time.time() + 15])
                    print(f"[BOT THOUGHT] {thought}")
                last_bot_thought = now
"""

# ============================================================================
# CHANGE 9: Add catalyst visual indicator in rendering:
# ============================================================================
"""
                # PHASE 1: Draw molecule aura if identified
                if t.aura_color and t.magnetic_strength > 0:
                    center_screen = cam.project(t.pos)
                    if center_screen[0] > -10000:
                        aura_radius = int(EDGE_LEN * 8 * t.magnetic_strength)
                        aura_alpha = int(80 * t.magnetic_strength * combined_alpha)
                        aura_surf = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
                        for ring in range(3):
                            ring_radius = aura_radius - ring * 3
                            ring_alpha = aura_alpha // (ring + 1)
                            pygame.draw.circle(aura_surf, (*t.aura_color, ring_alpha), center_screen, ring_radius, 2)
                        screen.blit(aura_surf, (0, 0))

                        # PHASE 4: Extra sparkle for catalysts
                        if t.is_catalyst:
                            sparkle_radius = aura_radius + 5
                            sparkle_alpha = int(40 * combined_alpha)
                            for i in range(4):
                                angle = (time.time() * 2 + i * 1.57) % 6.28
                                sx = center_screen[0] + int(math.cos(angle) * sparkle_radius)
                                sy = center_screen[1] + int(math.sin(angle) * sparkle_radius)
                                pygame.draw.circle(aura_surf, (255, 255, 0, sparkle_alpha), (sx, sy), 3)
                        screen.blit(aura_surf, (0, 0))

"""

print("""
✅ COMPLETE: All 4 Phases Implemented!
========================================

PHASE 1: Multi-Face Locking ✓
  • Detects 1-4 locked faces per TET
  • Magnetic strength: 0.25 per locked face
  • Molecule identification from color patterns
  • Colored auras around identified molecules

PHASE 2: Battery Oscillation ✓
  • Emptiness transfers between magnetic pairs
  • Smooth oscillation based on magnetic strength
  • Preserves total energy in the system

PHASE 3: Corner Desires & Orientation ✓
  • Red corners seek Cyan corners (and vice versa)
  • Positive poles repel other positive poles
  • Negative poles (high battery) orient toward origin

PHASE 4: Advanced Chemistry & Reactions ✓
  • 30+ molecule types with stability ratings
  • Synthesis reactions (A + B → C)
  • Decomposition reactions (C → A + B)
  • Catalytic molecules boost reaction rates
  • Energy release on reactions
  • Visual particle effects
  • Synthesis tracking and bot integration

BEHAVIORAL EFFECTS:
===================
• Watch water (H2O) form from acids and bases!
• See rust (Fe2O3) form from iron oxide
• Diamond synthesis from silicon under "pressure"
• Catalysts (FeO4, CuSO4) speed up nearby reactions
  with golden sparkle effects
• Low-battery molecules decompose into simpler forms
• High-entropy (far from center) molecules break down
• Particle bursts show when reactions occur
• Bot celebrates synthesis champions in thoughts

Your chemistry simulator is now ALIVE! 🧪⚛️✨🎆
""")


















************************* quantum? *************************




























Complete TET~CRAFT Chemistry System - Phases 1-5Apply these changes to your original code in order"""
COMPLETE PHASE SUMMARY:Phase 1: Multi-face locking detection + molecule identification + auras
Phase 2: Battery oscillation (emptiness transfer between magnetic pairs)
Phase 3: Corner desires + same-pole repulsion + orientation toward origin
Phase 4: Advanced chemistry - reactions, catalysts, energy release, molecule synthesis
Phase 5: Quantum Resonance - ERD fluctuations, tunneling reactions, entanglement effects, quantum visualsNEW IN PHASE 5 (ENHANCEMENTS):• ERD-inspired random fluctuations in reaction probabilities
• Quantum tunneling: Rare reactions across longer distances
• Entanglement pairs: Synchronized reactions between linked molecules
• Quantum coherence based on battery oscillation synchronicity
• Visual quantum effects: Blue resonance waves and sparkles
• Expanded database with 15+ new real compounds (from chemical lists)
• Bot thoughts include quantum ontology terms
• Performance optimizations: Batch NumPy operations in desires/repulsion
• Audio feedback: Pygame mixer sounds for reactions/quantum events
"""============================================================================CHANGE 1: REPLACE old MOLECULE_DATABASE with SUPER-EXPANDED version (added real compounds):============================================================================"""--- SUPER-EXPANDED MOLECULE DATABASE (PHASE 5) ---Added real compounds from chemical lists (e.g., HCl, NaOH, O2, etc.)Format: {pattern_key: (aura_color, symbolic_name, description, stability, energy)}MOLECULE_DATABASE = {
    # Single face locked - Basic compounds (original + new)
    "F1_R1_C1_W1_B1": ((255, 100, 150), "FeO4", "Iron Oxide - Magnetic Dipole", 0.8, 50),
    "F1_R0_C0_W3_B1": ((200, 200, 255), "CH4", "Methane - Stable Neutral", 0.9, 30),
    "F1_R3_C0_W1_B0": ((255, 50, 50), "H3O+", "Hydronium - Positive Ion", 0.6, 80),
    "F1_R0_C3_W1_B0": ((50, 255, 255), "PO4", "Phosphate - Negative Ion", 0.6, 80),
    "F1_R2_C1_W1_B0": ((255, 150, 100), "NO3", "Nitrate - Oxidizer", 0.7, 60),
    "F1_R1_C2_W1_B0": ((100, 200, 255), "SO3", "Sulfite - Reducer", 0.7, 60),
    "F1_R1_C0_W2_B1": ((200, 150, 255), "NH3", "Ammonia - Base", 0.8, 40),
    "F1_R0_C1_W2_B1": ((150, 255, 200), "H2O", "Water - Universal", 1.0, 10),
    "F1_R0_C1_W0_B3": ((100, 100, 100), "HCl", "Hydrochloric Acid - Strong Acid", 0.7, 70),  # New
    "F1_R1_C0_W3_B0": ((200, 255, 100), "NaOH", "Sodium Hydroxide - Strong Base", 0.7, 70),  # New
    "F1_R0_C0_W1_B3": ((50, 50, 50), "CO", "Carbon Monoxide - Toxic Gas", 0.5, 90),  # New
    "F1_R2_C0_W2_B0": ((255, 100, 50), "O2", "Oxygen - Diatomic Gas", 0.9, 40),  # New# Double face locked - Intermediate compounds (original + new)
"F2_R2_C2_W0_B0": ((255, 0, 255), "SO4", "Sulfate - Balanced Dipole", 0.85, 100),
"F2_R2_C0_W2_B0": ((255, 200, 100), "B2O3", "Boron Oxide - Self-Repelling", 0.75, 90),
"F2_R0_C2_W2_B0": ((100, 255, 255), "Ca(OH)2", "Calcium Hydroxide", 0.8, 85),
"F2_R2_C1_W1_B0": ((255, 100, 200), "HNO3", "Nitric Acid - Strong", 0.7, 120),
"F2_R1_C2_W1_B0": ((150, 100, 255), "H2SO4", "Sulfuric Acid - Strong", 0.7, 120),
"F2_R1_C1_W2_B0": ((200, 255, 150), "C2H6", "Ethane - Fuel", 0.75, 70),
"F2_R1_C1_W0_B2": ((100, 100, 200), "CO2", "Carbon Dioxide - Stable", 0.9, 50),
"F2_R0_C0_W3_B1": ((220, 220, 255), "SiH4", "Silane - Volatile", 0.5, 110),
"F2_R1_C1_W1_B1": ((150, 150, 200), "CH3COOH", "Acetic Acid - Weak Acid", 0.6, 80),  # New
"F2_R0_C2_W0_B2": ((100, 200, 100), "H2CO3", "Carbonic Acid - Weak", 0.5, 90),  # New
"F2_R3_C1_W0_B0": ((255, 50, 150), "KOH", "Potassium Hydroxide - Base", 0.7, 75),  # New
"F2_R0_C0_W2_B2": ((50, 50, 100), "N2", "Nitrogen - Diatomic Gas", 0.95, 30),  # New

# Triple face locked - Complex compounds (original + new)
"F3_R0_C3_W1_B0": ((100, 255, 200), "SiO4", "Silicate - Rock Former", 0.95, 150),
"F3_R3_C0_W1_B0": ((255, 80, 80), "Fe2O3", "Rust - Iron Oxide", 0.9, 140),
"F3_R2_C1_W1_B0": ((255, 150, 150), "Al2O3", "Alumina - Ceramic", 0.95, 160),
"F3_R1_C2_W1_B0": ((150, 200, 255), "MgSO4", "Epsom Salt", 0.85, 130),
"F3_R1_C1_W2_B0": ((200, 255, 200), "C6H12O6", "Glucose - Sugar", 0.8, 180),
"F3_R2_C2_W0_B0": ((255, 100, 255), "CuSO4", "Copper Sulfate", 0.85, 140),
"F3_R1_C1_W1_B1": ((180, 180, 255), "NaCl", "Salt - Ionic", 0.95, 90),
"F3_R2_C0_W1_B1": ((255, 100, 100), "Na2[B4O5(OH)4]·8H2O", "Borax - Detergent", 0.8, 110),  # New
"F3_R1_C0_W2_B1": ((200, 100, 255), "C6H5OH", "Phenol - Antiseptic", 0.7, 120),  # New
"F3_R0_C1_W3_B0": ((100, 200, 150), "NaHCO3", "Baking Soda - Base", 0.85, 100),  # New

# Fully locked - Highly stable complexes (original + new)
"F4_R2_C2_W0_B0": ((255, 255, 0), "CrO4", "Chromate - Stable Complex", 1.0, 200),
"F4_R1_C1_W2_B0": ((150, 255, 150), "C12H22O11", "Sucrose - Complex Sugar", 0.9, 220),
"F4_R1_C1_W1_B1": ((200, 200, 200), "CaCO3", "Limestone - Rock", 0.98, 180),
"F4_R2_C1_W1_B0": ((255, 200, 150), "Fe3O4", "Magnetite - Magnetic", 0.95, 210),
"F4_R1_C2_W1_B0": ((180, 220, 255), "ZnSO4", "Zinc Sulfate", 0.9, 190),
"F4_R0_C0_W4_B0": ((255, 255, 255), "C-Diamond", "Diamond - Crystal", 1.0, 300),
"F4_R0_C0_W0_B4": ((50, 50, 50), "C-Graphite", "Graphite - Stable", 0.98, 100),
"F4_R3_C1_W0_B0": ((255, 0, 100), "KClO3", "Potassium Chlorate - Oxidizer", 0.8, 150),  # New
"F4_R1_C3_W0_B0": ((0, 255, 100), "Na3PO4", "Sodium Phosphate - Cleaner", 0.85, 140),  # New
"F4_R2_C0_W1_B1": ((255, 150, 50), "AlCl3", "Aluminum Chloride - Lewis Acid", 0.7, 160),  # New
"F4_R0_C2_W1_B1": ((50, 200, 255), "CaCl2", "Calcium Chloride - Desiccant", 0.9, 130),  # New}Symbolic names for bot thoughtsMOLECULE_SYMBOLS = list(set(data[1] for data in MOLECULE_DATABASE.values()))PHASE 3: Corner desire and repulsion constantsK_CORNER_DESIRE = 0.002
K_SAME_POLE_REPULSION = 0.008
K_ORIENTATION_PULL = 0.003
CORNER_DESIRE_RANGE = EDGE_LEN * 8.0PHASE 4: Reaction system constantsK_REACTION_ENERGY_RELEASE = 0.05
REACTION_PROBABILITY_BASE = 0.001
CATALYST_BOOST = 3.0
SYNTHESIS_ENERGY_COST = 0.1
REACTION_RANGE = EDGE_LEN * 4.0PHASE 4: Catalytic molecules (these help other reactions)CATALYSTS = ["FeO4", "CuSO4", "Fe3O4", "AlCl3"]  # Added Lewis acid catalystPHASE 4: Synthesis reactions (expanded with new compounds)SYNTHESIS_REACTIONS = {
    ("H3O+", "PO4"): "H2O",
    ("H2O", "H2O"): "C2H6",
    ("CH4", "CH4"): "C2H6",
    ("H2O", "CO2"): "C6H12O6",
    ("SO3", "H2O"): "H2SO4",
    ("NO3", "H2O"): "HNO3",
    ("FeO4", "FeO4"): "Fe2O3",
    ("SiO4", "SiO4"): "C-Diamond",
    ("H3O+", "NaOH"): "H2O",  # New: Acid-base neutralization
    ("NH3", "HCl"): "NH4Cl",  # New: Ammonium chloride
    ("Ca(OH)2", "CO2"): "CaCO3",  # New: Limestone formation
    ("NaOH", "HCl"): "NaCl",  # New: Salt formation
    ("C2H6", "O2"): "CO2",  # New: Combustion
    ("CH4", "O2"): "CO2",  # New: Methane burn
    ("Al2O3", "HCl"): "AlCl3",  # New: Aluminum chloride synthesis
}PHASE 4: Decomposition reactions (expanded)DECOMPOSITION_REACTIONS = {
    "H2SO4": ["SO3", "H2O"],
    "HNO3": ["NO3", "H2O"],
    "C6H12O6": ["H2O", "CO2"],
    "Fe2O3": ["FeO4", "FeO4"],
    "CaCO3": ["Ca(OH)2", "CO2"],  # New: Limestone decomposition
    "NH4Cl": ["NH3", "HCl"],  # New: Ammonium salt breakdown
    "NaCl": ["NaOH", "HCl"],  # New: Electrolysis analog
    "AlCl3": ["Al2O3", "HCl"],  # New: Reverse synthesis
}PHASE 5: Quantum Resonance constantsERD_FLUCTUATION_STRENGTH = 0.2  # Max random fluctuation in reaction prob
ERD_COHERENCE_THRESHOLD = 0.7  # Battery synch for quantum effects
QUANTUM_TUNNEL_PROB = 0.0005  # Chance for "tunnel" reactions over distance
QUANTUM_ENTANGLE_RANGE = EDGE_LEN * 12.0  # Range for entangled reactions
QUANTUM_SPARKLE_COLOR = (0, 100, 255)  # Blue for quantum visualsPHASE 5: Quantum-enhanced reactions (add random ERD effects)QUANTUM_REACTIONS = {
    ("H2O", "NaCl"): "NaOH",  # Base formation (entangled)
    ("NH3", "HNO3"): "NH4NO3",  # Ammonium nitrate (explosive potential)
    ("C2H6", "O2"): "CO2",  # Combustion with quantum spark
    ("CH4", "Cl2"): "CH3Cl",  # New: Chloromethane (quantum radical)
    ("H2O", "CO"): "HCOOH",  # New: Formic acid
    ("AlCl3", "C6H6"): "C6H5Cl",  # New: Friedel-Crafts analog
}PHASE 5: Entanglement pairs (molecules that can link quantumly)ENTANGLEMENT_PAIRS = [("H3O+", "OH-"), ("NH3", "H+"), ("CO2", "H2O"), ("Fe3O4", "Fe2O3")]
"""============================================================================CHANGE 2: In Tetrahedron.init, AFTER PHASE 4 properties, ADD:============================================================================"""
        # PHASE 5: Quantum properties
        self.erd_coherence = 0.0  # Current ERD coherence level (0-1)
        self.entangled_partner = None  # ID of entangled molecule
        self.quantum_state = "ground"  # "ground", "excited", "tunneled"
"""============================================================================CHANGE 3: Update check_magnetization() to calculate ERD coherence (ADD at end):============================================================================"""
                # PHASE 5: Calculate ERD coherence based on locked faces and battery
                t.erd_coherence = min(1.0, (len(t.locked_faces) / 4.0) * t.battery)            # Check for entanglement eligibility
            if t.label in [p[0] for p in ENTANGLEMENT_PAIRS] or t.label in [p[1] for p in ENTANGLEMENT_PAIRS]:
                if t.entangled_partner is None and t.erd_coherence > ERD_COHERENCE_THRESHOLD:
                    # Look for potential partner (simplified - first match)
                    for potential in self.tets:
                        if potential.id != t.id and potential.label in [pair[1 - pair.index(t.label)] if t.label in pair else None for pair in ENTANGLEMENT_PAIRS]:
                            dist = np.linalg.norm(t.pos - potential.pos)
                            if dist < QUANTUM_ENTANGLE_RANGE:
                                t.entangled_partner = potential.id
                                potential.entangled_partner = t.id
                                break"""============================================================================CHANGE 4: AFTER attempt_decomposition_reactions(), ADD these PHASE 5 methods:============================================================================"""
    def apply_erd_fluctuations(self, scaled_dt):
        """PHASE 5: Apply random ERD fluctuations to reaction probabilities"""
        for t in self.tets:
            if t.erd_coherence > 0.5:
                # Random fluctuation based on ERD strength
                fluctuation = np.random.uniform(-ERD_FLUCTUATION_STRENGTH, ERD_FLUCTUATION_STRENGTH) * t.erd_coherence
                t.battery = np.clip(t.battery + fluctuation * scaled_dt, 0.0, 1.0)            # Visual: Set quantum state if fluctuating high
            if abs(fluctuation) > 0.1:
                t.quantum_state = "excited"
            else:
                t.quantum_state = "ground"

def attempt_quantum_tunneling(self, scaled_dt, add_msg_fn):
    \"\"\"PHASE 5: Rare quantum tunneling reactions over distance\"\"\"
    current_time = time.time()
    tunnel_reactions = []

    for t in self.tets:
        if t.erd_coherence < ERD_COHERENCE_THRESHOLD:
            continue

        if current_time - t.last_reaction_time < 10.0:
            continue

        # Low probability tunnel event
        if random.random() < QUANTUM_TUNNEL_PROB * scaled_dt * 60 * t.erd_coherence:
            # Find distant partner for quantum reaction
            positions = np.array([other.pos for other in self.tets if other.id != t.id])
            if len(positions) == 0:
                continue

            tree = cKDTree(positions)
            far_indices = tree.query_ball_point(t.pos, QUANTUM_ENTANGLE_RANGE * 2)
            if not far_indices:
                continue

            partner_idx = random.choice(far_indices)
            partner = self.tets[partner_idx]

            if partner.label and (t.label, partner.label) in QUANTUM_REACTIONS:
                product = QUANTUM_REACTIONS[(t.label, partner.label)]

                # Tunnel success!
                t.label = product
                t.last_reaction_time = current_time
                t.synthesis_count += 1
                t.battery -= SYNTHESIS_ENERGY_COST / 2  # Less cost for quantum

                # Quantum drain on partner
                partner.battery -= 0.05
                partner.quantum_state = "tunneled"

                tunnel_reactions.append((t.label, partner.label, product))
                add_msg_fn(f" Quantum Tunnel: {product} formed!", duration=5)

                # Visual state
                t.quantum_state = "tunneled"

    return tunnel_reactions

def process_entangled_reactions(self, scaled_dt, add_msg_fn):
    \"\"\"PHASE 5: Synchronized reactions for entangled pairs\"\"\"
    processed_pairs = set()
    entangled_reactions = []

    for t in self.tets:
        if t.entangled_partner is None:
            continue

        partner_id = t.entangled_partner
        if partner_id in processed_pairs:
            continue

        partner = next((p for p in self.tets if p.id == partner_id), None)
        if not partner:
            t.entangled_partner = None
            continue

        processed_pairs.add(t.id)
        processed_pairs.add(partner_id)

        # Sync batteries (entanglement effect)
        avg_battery = (t.battery + partner.battery) / 2
        t.battery = avg_battery
        partner.battery = avg_battery

        # Check for entangled reaction
        pair_key = tuple(sorted([t.label, partner.label]))
        if pair_key in SYNTHESIS_REACTIONS:
            prob = REACTION_PROBABILITY_BASE * 2.0 * scaled_dt * 60  # Boosted for entangled
            if random.random() < prob:
                product = SYNTHESIS_REACTIONS[pair_key]

                # Form product on both (mirrored)
                t.label = product
                partner.label = product

                t.last_reaction_time = time.time()
                partner.last_reaction_time = time.time()

                t.synthesis_count += 1
                partner.synthesis_count += 1

                # Energy sync boost
                energy_gain = K_REACTION_ENERGY_RELEASE * 1.5  # Quantum boost
                t.battery = min(1.0, t.battery + energy_gain)
                partner.battery = min(1.0, partner.battery + energy_gain)

                entangled_reactions.append((t.label, partner.label, product))
                add_msg_fn(f" Entangled Formation: {product}!", duration=5)

    return entangled_reactions

def spawn_quantum_visuals(self, screen, cam, quantum_events, width, height):
    \"\"\"PHASE 5: Blue waves and sparkles for quantum effects\"\"\"
    if not hasattr(self, 'quantum_particles'):
        self.quantum_particles = []

    # Add particles for quantum events
    for event_type, pos in quantum_events:  # Assume events = [(type, pos), ...]
        base_color = QUANTUM_SPARKLE_COLOR
        if event_type == "tunnel":
            base_color = (0, 200, 255)
        elif event_type == "entangle":
            base_color = (100, 0, 255)

        particle = {
            'pos': np.array(pos),
            'vel': np.random.uniform(-1, 1, 3) * 40,
            'color': base_color,
            'life': 1.5,
            'size': 12
        }
        self.quantum_particles.append(particle)

        # Add wave ring
        wave = {
            'pos': np.array(pos),
            'radius': 5,
            'speed': 50,
            'alpha': 180,
            'life': 1.0
        }
        self.quantum_particles.append(wave)  # Use same list for waves

        # Extra sparkles
        for _ in range(8):
            p = particle.copy()
            p['vel'] = np.random.uniform(-1, 1, 3) * 50
            p['color'] = tuple(np.clip(np.array(base_color) * random.uniform(0.8, 1.2), 0, 255))
            p['size'] = random.randint(4, 😎
            self.quantum_particles.append(p)

    # Update and render
    to_keep = []
    for p in self.quantum_particles:
        if 'radius' in p:  # Wave ring
            p['radius'] += p['speed'] * 0.016
            p['alpha'] = int(p['alpha'] * 0.95)
            p['life'] -= 0.02

            if p['life'] > 0:
                screen_pos = cam.project(p['pos'])
                if screen_pos[0] > -10000:
                    wave_surf = pygame.Surface((width, height), pygame.SRCALPHA)
                    pygame.draw.circle(wave_surf, (*p['color'], p['alpha']//2), screen_pos, p['radius'], 2)
                    screen.blit(wave_surf, (0,0))
                to_keep.append(p)
        else:  # Particle
            p['pos'] += p['vel'] * 0.016
            p['vel'] *= 0.92
            p['life'] -= 0.025

            if p['life'] > 0:
                screen_pos = cam.project(p['pos'])
                if screen_pos[0] > -10000:
                    alpha = int(p['life'] * 255)
                    size = max(1, int(p['size'] * p['life']))
                    color_a = (*p['color'], alpha)
                    part_surf = pygame.Surface((size*2, size*2), pygame.SRCALPHA)
                    pygame.draw.circle(part_surf, color_a, (size, size), size)
                    screen.blit(part_surf, (screen_pos[0]-size, screen_pos[1]-size))
                to_keep.append(p)

    self.quantum_particles = to_keep"""============================================================================CHANGE 5: In World.update(), AFTER decomposition_reactions, ADD:============================================================================"""
        # PHASE 5: Quantum enhancements
        self.apply_erd_fluctuations(scaled_dt)
        tunnel_reactions = self.attempt_quantum_tunneling(scaled_dt, add_msg_fn)
        entangle_reactions = self.process_entangled_reactions(scaled_dt, add_msg_fn)    # Collect quantum events for visuals (type, pos)
    quantum_events = []
    for _, _, product in tunnel_reactions:
        for t in self.tets:
            if t.label == product and t.quantum_state == "tunneled":
                quantum_events.append(("tunnel", t.pos))
    for _, _, product in entangle_reactions:
        for t in self.tets:
            if t.label == product:
                quantum_events.append(("entangle", t.pos))

    self._last_quantum_events = quantum_events  # Store for rendering"""============================================================================CHANGE 6: In rendering, AFTER reaction particles, ADD:============================================================================"""
        # PHASE 5: Draw quantum visuals
        if hasattr(world, 'quantum_particles'):
            recent_quantum = getattr(world, '_last_quantum_events', [])
            world.spawn_quantum_visuals(screen, cam, recent_quantum, WIDTH, HEIGHT)
            world._last_quantum_events = []  # Clear after
"""============================================================================CHANGE 7: Optimize apply_corner_desires and apply_same_pole_repulsion with batch NumPy:============================================================================"""
    def apply_corner_desires(self, scaled_dt):
        """PHASE 3: Optimized - Apply corner-to-corner attraction between opposite colors"""
        if len(self.tets) < 2:
            return    # Collect all corners with NumPy arrays
    tet_list = list(self.tets)  # To index
    all_corners = []
    corner_colors = []
    corner_tets = []
    corner_indices = []

    for idx, t in enumerate(tet_list):
        verts = t.verts()
        for c_idx in range(4):
            all_corners.append(verts[c_idx])
            corner_tets.append(idx)
            corner_indices.append(c_idx)

            corner_color = None
            for f_idx in range(4):
                if c_idx in Tetrahedron.FACE_TO_CORNERS[f_idx]:
                    face_color = t.colors[f_idx] if t.colors else Tetrahedron.FACE_COLORS[f_idx]
                    if face_color == (255, 0, 0): corner_color = 'R'; break
                    elif face_color == (0, 255, 255): corner_color = 'C'; break
            corner_colors.append(corner_color or 'N')

    all_corners = np.array(all_corners)

    if len(all_corners) < 2:
        return

    tree = cKDTree(all_corners)

    # Process only R and C corners
    for i in range(len(all_corners)):
        color1 = corner_colors[i]
        if color1 not in ['R', 'C']:
            continue

        nearby_idx = tree.query_ball_point(all_corners[i], CORNER_DESIRE_RANGE)

        forces = np.zeros(3)
        for j in nearby_idx:
            if i == j: continue
            color2 = corner_colors[j]
            if (color1 == 'R' and color2 == 'C') or (color1 == 'C' and color2 == 'R'):
                delta = all_corners[j] - all_corners[i]
                dist = np.linalg.norm(delta)
                if dist > 1e-6:
                    force_strength = K_CORNER_DESIRE * (1.0 - dist / CORNER_DESIRE_RANGE)
                    forces += (delta / dist) * force_strength

        if np.any(forces):
            tet_idx = corner_tets[i]
            c_idx = corner_indices[i]
            t1 = tet_list[tet_idx]
            t1.local[c_idx] += forces * scaled_dt * 0.5
            t1.pos += forces * scaled_dt * 0.5

def apply_same_pole_repulsion(self, scaled_dt):
    \"\"\"PHASE 3: Optimized - Positive poles repel other positive poles\"\"\"
    positive_poles = [t for t in self.tets if t.is_magnetized and t.magnetism > 0]

    if len(positive_poles) < 2:
        return

    # NumPy batch
    pos_array = np.array([t.pos for t in positive_poles])
    strengths = np.array([t.magnetic_strength for t in positive_poles])

    for i in range(len(pos_array)):
        deltas = pos_array - pos_array[i]
        dists = np.linalg.norm(deltas, axis=1)
        mask = (dists > 1e-6)

        if np.any(mask):
            unit_deltas = deltas[mask] / dists[mask][:, np.newaxis]
            repulsions = K_SAME_POLE_REPULSION / (dists[mask]**2 + 1.0)
            repulsions *= strengths[mask] * strengths[i]

            total_force = np.sum(unit_deltas * repulsions[:, np.newaxis], axis=0)
            positive_poles[i].pos -= total_force * scaled_dt"""============================================================================CHANGE 8: In bot thoughts, ADD quantum terms:============================================================================"""
            # 3. Thoughts (Every 10 mins)
            if now - last_bot_thought > 600:
                if world.tets:
                    # Gather labels and molecules
                    labels = [t.label for t in self.tets if t.label]
                    molecules = [t.label for t in self.tets if t.aura_color and t.label in MOLECULE_SYMBOLS]                # PHASE 4: Track synthesis champions
                synthesized = [t for t in world.tets if t.synthesis_count > 0]
                if synthesized:
                    champion = max(synthesized, key=lambda t: t.synthesis_count)
                    if random.random() < 0.3:
                        thought = f"{champion.label} ∫ synthesized {champion.synthesis_count}× ∞"
                        net_messages.append([f"[Thought]: {thought}", time.time() + 15])
                        print(f"[BOT THOUGHT] {thought}")
                        last_bot_thought = now
                        continue

                # PHASE 5: 20% chance for quantum ontology thoughts
                quantum_terms = ["ERD∇", "Ψ-coherence", "OBA⊗", "QuantumFold", "EntropicBridge"]
                if random.random() < 0.2:
                    thought = f"{random.choice(quantum_terms)} {random.choice(MATH_SYMBOLS)} {random.choice(molecules or labels)}"
                else:
                    if molecules and random.random() < 0.6:
                        thought = f"{random.choice(molecules)} {random.choice(MATH_SYMBOLS)} {random.choice(labels)}"
                    else:
                        thought = f"{random.choice(labels)} {random.choice(MATH_SYMBOLS)} {random.choice(labels)} {random.choice(MATH_SYMBOLS)} {random.choice(labels)}"
                net_messages.append([f"[Thought]: {thought}", time.time() + 15])
                print(f"[BOT THOUGHT] {thought}")
            last_bot_thought = now"""============================================================================CHANGE 9: Add audio feedback (at top, after imports, ADD):============================================================================"""
from pygame import mixer
mixer.init()Load sounds (assume files exist or use placeholders)REACTION_SOUND = mixer.Sound('reaction.wav') if mixer.get_init() else None  # Explosion-like
QUANTUM_SOUND = mixer.Sound('quantum.wav') if mixer.get_init() else None  # Sci-fi hum
"""============================================================================CHANGE 10: Play sounds in reaction methods (ADD in attempt_synthesis_reactions, etc.):============================================================================"""
                    # Play sound
                    if REACTION_SOUND:
                        REACTION_SOUND.play()
"""In quantum methods:"""
                    # Play quantum sound
                    if QUANTUM_SOUND:
                        QUANTUM_SOUND.play()
"""print("""
 ENHANCED: Phase 5 Quantum Resonance Added!PHASE 5 KEY FEATURES:• ERD Fluctuations: Random battery changes based on coherence
• Quantum Tunneling: Rare long-distance reactions
• Entanglement: Paired molecules sync batteries and react together
• Expanded Database: +15 real compounds (HCl, NaOH, O2, etc.)
• Quantum Visuals: Blue waves/sparkles for events
• Audio Feedback: Sounds for reactions/quantum
• Optimized Physics: Batch NumPy for desires/repulsion
• Quantum Bot Thoughts: Includes ERD, Ψ termsBEHAVIORAL ENHANCEMENTS:• High-coherence molecules fluctuate quantumly
• Tunneling creates surprise distant syntheses
• Entangled pairs mirror each other (spooky action)
• More realistic chemistry with new reactions
• Immersive audio-visual feedbackYour simulator now has QUANTUM CHEMISTRY!
""")







***************************** more colourful! *****************************


















# ============================================================================
# CHANGE 1: SUPRA-EXPANDED DATABASE WITH ERD-TUNED COMPOUNDS
# ============================================================================
"""
# --- ERD-TUNED MOLECULE DATABASE (MOS-HSRCF v6.0 INTEGRATED) ---
# Format: {pattern_key: (aura_color, symbolic_name, description, stability, energy, Ψ_affinity)}
# Ψ_affinity = 0.0-1.0 scale of how strongly this compound responds to noospheric index

MOLECULE_DATABASE = {
    # SINGLE FACE LOCKED - Foundation Compounds
    "F1_R1_C1_W1_B1": ((255, 100, 150), "FeO4", "Iron Oxide - ERD Dipole", 0.8, 50, 0.85),
    "F1_R0_C0_W3_B1": ((200, 200, 255), "CH4", "Methane - Stable Neutral", 0.9, 30, 0.2),
    "F1_R3_C0_W1_B0": ((255, 50, 50), "H3O+", "Hydronium - Positive Ψ-Ion", 0.6, 80, 0.9),
    "F1_R0_C3_W1_B0": ((50, 255, 255), "PO4", "Phosphate - Negative Ψ-Ion", 0.6, 80, 0.9),
    "F1_R2_C1_W1_B0": ((255, 150, 100), "NO3", "Nitrate - Oxidizer", 0.7, 60, 0.3),
    "F1_R1_C2_W1_B0": ((100, 200, 255), "SO3", "Sulfite - Reducer", 0.7, 60, 0.3),
    "F1_R1_C0_W2_B1": ((200, 150, 255), "NH3", "Ammonia - Base", 0.8, 40, 0.4),
    "F1_R0_C1_W2_B1": ((150, 255, 200), "H2O", "Water - ERD Universal Solvent", 1.0, 10, 0.95),
    "F1_R0_C1_W0_B3": ((100, 100, 100), "HCl", "Hydrochloric Acid - Ψ-Conductor", 0.7, 70, 0.7),
    "F1_R1_C0_W3_B0": ((200, 255, 100), "NaOH", "Sodium Hydroxide - Ψ-Base", 0.7, 70, 0.7),
    "F1_R0_C0_W1_B3": ((50, 50, 50), "CO", "Carbon Monoxide - ERD Toxin", 0.5, 90, 0.6),
    "F1_R2_C0_W2_B0": ((255, 100, 50), "O2", "Oxygen - ERD Breath", 0.9, 40, 0.😎,
    "F1_R0_C0_W2_B2": ((100, 100, 255), "N2", "Nitrogen - ERD Inertia", 0.95, 20, 0.1),

    # DOUBLE FACE LOCKED - Structural Compounds
    "F2_R2_C2_W0_B0": ((255, 0, 255), "SO4", "Sulfate - ERD Balanced Dipole", 0.85, 100, 0.6),
    "F2_R2_C0_W2_B0": ((255, 200, 100), "B2O3", "Boron Oxide - Self-Repelling", 0.75, 90, 0.4),
    "F2_R0_C2_W2_B0": ((100, 255, 255), "Ca(OH)2", "Calcium Hydroxide", 0.8, 85, 0.5),
    "F2_R2_C1_W1_B0": ((255, 100, 200), "HNO3", "Nitric Acid - ERD Strong", 0.7, 120, 0.85),
    "F2_R1_C2_W1_B0": ((150, 100, 255), "H2SO4", "Sulfuric Acid - ERD Strong", 0.7, 120, 0.85),
    "F2_R1_C1_W2_B0": ((200, 255, 150), "C2H6", "Ethane - Fuel", 0.75, 70, 0.3),
    "F2_R1_C1_W0_B2": ((100, 100, 200), "CO2", "Carbon Dioxide - Stable", 0.9, 50, 0.4),
    "F2_R0_C0_W3_B1": ((220, 220, 255), "SiH4", "Silane - Volatile", 0.5, 110, 0.6),
    "F2_R1_C1_W1_B1": ((150, 150, 200), "CH3COOH", "Acetic Acid - Weak ERD", 0.6, 80, 0.65),
    "F2_R0_C2_W0_B2": ((100, 200, 100), "H2CO3", "Carbonic Acid - Weak", 0.5, 90, 0.5),
    "F2_R3_C1_W0_B0": ((255, 50, 150), "KOH", "Potassium Hydroxide", 0.7, 75, 0.55),
    "F2_R2_C0_W0_B2": ((200, 100, 50), "O3", "Ozone - ERD Active Oxygen", 0.7, 110, 0.😎,
    "F2_R0_C0_W1_B3": ((75, 75, 150), "C2H4", "Ethylene - Plant Hormone", 0.6, 95, 0.7),

    # TRIPLE FACE LOCKED - Complex ERD Compounds
    "F3_R0_C3_W1_B0": ((100, 255, 200), "SiO4", "Silicate - ERD Rock Former", 0.95, 150, 0.9),
    "F3_R3_C0_W1_B0": ((255, 80, 80), "Fe2O3", "Rust - Iron Oxide", 0.9, 140, 0.75),
    "F3_R2_C1_W1_B0": ((255, 150, 150), "Al2O3", "Alumina - Ceramic", 0.95, 160, 0.6),
    "F3_R1_C2_W1_B0": ((150, 200, 255), "MgSO4", "Epsom Salt", 0.85, 130, 0.5),
    "F3_R1_C1_W2_B0": ((200, 255, 200), "C6H12O6", "Glucose - ERD Sugar", 0.8, 180, 0.85),
    "F3_R2_C2_W0_B0": ((255, 100, 255), "CuSO4", "Copper Sulfate", 0.85, 140, 0.7),
    "F3_R1_C1_W1_B1": ((180, 180, 255), "NaCl", "Salt - Ionic", 0.95, 90, 0.4),
    "F3_R2_C0_W1_B1": ((255, 100, 100), "Na2[B4O5(OH)4]·8H2O", "Borax - Detergent", 0.8, 110, 0.3),
    "F3_R1_C0_W2_B1": ((200, 100, 255), "C6H5OH", "Phenol - Antiseptic", 0.7, 120, 0.65),
    "F3_R0_C1_W3_B0": ((100, 200, 150), "NaHCO3", "Baking Soda", 0.85, 100, 0.45),
    "F3_R1_C2_W0_B1": ((150, 255, 150), "C3H8O3", "Glycerol - ERD Viscous", 0.8, 130, 0.75),

    # FULLY LOCKED - Hyper-Stable ERD Complexes
    "F4_R2_C2_W0_B0": ((255, 255, 0), "CrO4", "Chromate - ERD Stable Complex", 1.0, 200, 0.95),
    "F4_R1_C1_W2_B0": ((150, 255, 150), "C12H22O11", "Sucrose - Complex ERD Sugar", 0.9, 220, 0.9),
    "F4_R1_C1_W1_B1": ((200, 200, 200), "CaCO3", "Limestone - ERD Rock", 0.98, 180, 0.85),
    "F4_R2_C1_W1_B0": ((255, 200, 150), "Fe3O4", "Magnetite - ERD Magnetic", 0.95, 210, 0.98),
    "F4_R1_C2_W1_B0": ((180, 220, 255), "ZnSO4", "Zinc Sulfate", 0.9, 190, 0.6),
    "F4_R0_C0_W4_B0": ((255, 255, 255), "C-Diamond", "Diamond - ERD Crystal", 1.0, 300, 0.99),
    "F4_R0_C0_W0_B4": ((50, 50, 50), "C-Graphite", "Graphite - Stable", 0.98, 100, 0.7),
    "F4_R3_C1_W0_B0": ((255, 0, 100), "KClO3", "Potassium Chlorate", 0.8, 150, 0.65),
    "F4_R1_C3_W0_B0": ((0, 255, 100), "Na3PO4", "Sodium Phosphate", 0.85, 140, 0.55),
    "F4_R2_C0_W1_B1": ((255, 150, 50), "AlCl3", "Aluminum Chloride", 0.7, 160, 0.7),
    "F4_R0_C2_W1_B1": ((50, 200, 255), "CaCl2", "Calcium Chloride", 0.9, 130, 0.4),
    "F4_R1_C1_W0_B2": ((150, 150, 255), "C6H6", "Benzene - ERD Aromatic", 0.8, 170, 0.😎,
}

# ERD-ENHANCED QUANTUM COMPOUNDS (SPECIAL FOR PHASE 5)
ERD_QUANTUM_COMPOUNDS = {
    "F4_R3_C3_W0_B0": ((200, 100, 255), "Ψ-Crystal", "Noospheric Resonator", 0.9, 250, 0.99),
    "F4_R2_C2_W1_B0": ((100, 255, 255), "OBA-Torsion", "Octonionic Bootstrap Field", 0.8, 280, 0.97),
    "F4_R1_C1_W3_B0": ((255, 255, 150), "ERD-Gradient", "Echo-Resonant Density", 0.85, 230, 0.96),
    "F3_R3_C3_W0_B0": ((150, 200, 255), "Chrono-Fold", "Temporal Resonance", 0.7, 200, 0.95),
}
MOLECULE_DATABASE.update(ERD_QUANTUM_COMPOUNDS)

# SYMBOLIC NAMES FOR BOT THOUGHTS
MOLECULE_SYMBOLS = list(set(data[1] for data in MOLECULE_DATABASE.values()))

# MOS-HSRCF v6.0 CONSTANTS INTEGRATION
Ψ_NOOSPHERIC_INDEX = 0.18  # Threshold from MOS-HSRCF
ERD_FLUCTUATION_BASE = 0.15  # Base ERD fluctuation from MOS-HSRCF Approach 1

# ENHANCED PHASE 3 & 4 CONSTANTS (Ψ-MODULATED)
K_CORNER_DESIRE = 0.002 * (1 + Ψ_NOOSPHERIC_INDEX)  # Ψ-boosted attraction
K_SAME_POLE_REPULSION = 0.008 * (1 + Ψ_NOOSPHERIC_INDEX)
K_ORIENTATION_PULL = 0.003 * (1 + Ψ_NOOSPHERIC_INDEX)
CORNER_DESIRE_RANGE = EDGE_LEN * 8.0 * (1 + Ψ_NOOSPHERIC_INDEX)

K_REACTION_ENERGY_RELEASE = 0.05 * (1 + Ψ_NOOSPHERIC_INDEX)
REACTION_PROBABILITY_BASE = 0.001 * (1 + Ψ_NOOSPHERIC_INDEX * 2)  # Ψ doubles reaction rate
CATALYST_BOOST = 3.0 * (1 + Ψ_NOOSPHERIC_INDEX)
SYNTHESIS_ENERGY_COST = 0.1
REACTION_RANGE = EDGE_LEN * 4.0

# ENHANCED CATALYSTS WITH ERD PROPERTIES
CATALYSTS = ["FeO4", "CuSO4", "Fe3O4", "AlCl3", "Ψ-Crystal", "OBA-Torsion"]

# Ψ-ENHANCED SYNTHESIS REACTIONS
SYNTHESIS_REACTIONS = {
    ("H3O+", "PO4"): "H2O",
    ("H2O", "H2O"): "C2H6",
    ("CH4", "CH4"): "C2H6",
    ("H2O", "CO2"): "C6H12O6",
    ("SO3", "H2O"): "H2SO4",
    ("NO3", "H2O"): "HNO3",
    ("FeO4", "FeO4"): "Fe2O3",
    ("SiO4", "SiO4"): "C-Diamond",
    ("H3O+", "NaOH"): "H2O",
    ("NH3", "HCl"): "NH4Cl",
    ("Ca(OH)2", "CO2"): "CaCO3",
    ("NaOH", "HCl"): "NaCl",
    ("C2H6", "O2"): "CO2",
    ("CH4", "O2"): "CO2",
    ("Al2O3", "HCl"): "AlCl3",
    # ERD-ENHANCED REACTIONS (SPECIAL)
    ("Ψ-Crystal", "H2O"): "ERD-Gradient",
    ("OBA-Torsion", "SiO4"): "Chrono-Fold",
    ("ERD-Gradient", "C-Diamond"): "Ψ-Crystal",
}

# DECOMPOSITION WITH ERD EFFECTS
DECOMPOSITION_REACTIONS = {
    "H2SO4": ["SO3", "H2O"],
    "HNO3": ["NO3", "H2O"],
    "C6H12O6": ["H2O", "CO2"],
    "Fe2O3": ["FeO4", "FeO4"],
    "CaCO3": ["Ca(OH)2", "CO2"],
    "NH4Cl": ["NH3", "HCl"],
    "NaCl": ["NaOH", "HCl"],
    "AlCl3": ["Al2O3", "HCl"],
    # ERD DECOMPOSITION
    "Ψ-Crystal": ["H2O", "SiO4"],
    "OBA-Torsion": ["Fe3O4", "SiO4"],
}

# PHASE 5: QUANTUM RESONANCE WITH MOS-HSRCF PARAMETERS
ERD_FLUCTUATION_STRENGTH = ERD_FLUCTUATION_BASE  # From MOS-HSRCF Approach 1
ERD_COHERENCE_THRESHOLD = Ψ_NOOSPHERIC_INDEX  # Same threshold!
QUANTUM_TUNNEL_PROB = 0.0005 * (1 + Ψ_NOOSPHERIC_INDEX * 3)  # Ψ triples tunneling
QUANTUM_ENTANGLE_RANGE = EDGE_LEN * 12.0 * (1 + Ψ_NOOSPHERIC_INDEX)
QUANTUM_SPARKLE_COLOR = (0, 100, 255)  # Blue for quantum visuals

# QUANTUM-ENHANCED REACTIONS (ERD-FACILITATED)
QUANTUM_REACTIONS = {
    ("H2O", "NaCl"): "NaOH",
    ("NH3", "HNO3"): "NH4NO3",
    ("C2H6", "O2"): "CO2",
    ("CH4", "Cl2"): "CH3Cl",
    ("H2O", "CO"): "HCOOH",
    ("AlCl3", "C6H6"): "C6H5Cl",
    # ERD QUANTUM REACTIONS
    ("Ψ-Crystal", "Fe3O4"): "ERD-Gradient",
    ("ERD-Gradient", "OBA-Torsion"): "Ψ-Crystal",
}

# ENTANGLEMENT PAIRS WITH ERD RESONANCE
ENTANGLEMENT_PAIRS = [
    ("H3O+", "OH-"), ("NH3", "H+"), ("CO2", "H2O"), ("Fe3O4", "Fe2O3"),
    # ERD ENTANGLEMENT
    ("Ψ-Crystal", "ERD-Gradient"),
    ("OBA-Torsion", "Chrono-Fold"),
]
"""
